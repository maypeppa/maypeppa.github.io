<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-31377772-3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-31377772-3');</script>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>snappy</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="work" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/htmlize.css"/><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/readtheorg.css"/><script src="https://ajax.loli.net/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script><script type="text/javascript" src="/themes/styles/lib/js/jquery.stickytableheaders.min.js"></script><script type="text/javascript" src="/themes/styles/readtheorg/js/readtheorg.js"></script></head>
<body>
<div id="content">
<h1 class="title">snappy</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org50b74c5">1. Overview</a></li>
<li><a href="#org1e881e1">2. Format</a>
<ul>
<li><a href="#org60e15f7">2.1. Literal</a></li>
<li><a href="#org87835ce">2.2. Copy</a></li>
</ul>
</li>
<li><a href="#org1ec1e19">3. Source &amp; Sink</a></li>
<li><a href="#orgdf9d9c7">4. Snippet</a>
<ul>
<li><a href="#org72e2e43">4.1. Bits</a></li>
<li><a href="#orgc7cf70b">4.2. Varint</a></li>
<li><a href="#orgafc16f5">4.3. GetUint32AtOffset</a></li>
<li><a href="#org77352ea">4.4. GetHashTable</a></li>
<li><a href="#org2552514">4.5. FindMatchLength</a></li>
<li><a href="#org8f7d7f3">4.6. MaxCompressedLength</a></li>
<li><a href="#org48bd2fb">4.7. IncrementalCopy</a></li>
<li><a href="#org78111c9">4.8. EmitLiteral</a></li>
<li><a href="#org92a71c3">4.9. EmitCopy</a></li>
</ul>
</li>
<li><a href="#orgd5385ab">5. Compress</a></li>
<li><a href="#org13d1901">6. Uncompress</a>
<ul>
<li><a href="#orgf2828eb">6.1. Writer</a></li>
<li><a href="#org945a651">6.2. SnappyDecompressor</a></li>
</ul>
</li>
<li><a href="#org9d97d08">7. Example</a></li>
</ul>
</div>
</div>
<p>
<a href="http://code.google.com/p/snappy/">http://code.google.com/p/snappy/</a>
</p>

<div id="outline-container-org50b74c5" class="outline-2">
<h2 id="org50b74c5"><span class="section-number-2">1</span> Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
Snappy is a compression/decompression library. It does not aim for maximum
compression, or compatibility with any other compression library; instead,
it aims for very high speeds and reasonable compression. For instance,
compared to the fastest mode of zlib, Snappy is an order of magnitude faster
for most inputs, but the resulting compressed files are anywhere from 20% to
100% bigger. (For more information, see "Performance", below.)
</p>

<p>
Snappy is intended to be fast. On a single core of a Core i7 processor
in 64-bit mode, it compresses at about 250 MB/sec or more and decompresses at
about 500 MB/sec or more. (These numbers are for the slowest inputs in our
benchmark suite; others are much faster.) In our tests, Snappy usually
is faster than algorithms in the same class (e.g. LZO, LZF, FastLZ, QuickLZ,
etc.) while achieving comparable compression ratios.
</p>

<p>
Typical compression ratios (based on the benchmark suite) are about 1.5-1.7x
for plain text, about 2-4x for HTML, and of course 1.0x for JPEGs, PNGs and
other already-compressed data. Similar numbers for zlib in its fastest mode
are 2.6-2.8x, 3-7x and 1.0x, respectively. More sophisticated algorithms are
capable of achieving yet higher compression rates, although usually at the
expense of speed. Of course, compression ratio will vary significantly with
the input.
</p>

<p>
Snappy里面大部分操作都是针对32/64位数据操作，然后假设不对齐的32/64位数据载入开销很少。
同时假设CPU字节序是little-endian.也有big-endian实现但是速度相对较慢。对于Intel处理器就非常适用。
</p>

<p>
Although Snappy should be fairly portable, it is primarily optimized
for 64-bit x86-compatible processors, and may run slower in other environments.
In particular:
</p>
<ul class="org-ul">
<li>Snappy uses 64-bit operations in several places to process more data at
once than would otherwise be possible.</li>
<li>Snappy assumes unaligned 32- and 64-bit loads and stores are cheap.
On some platforms, these must be emulated with single-byte loads
and stores, which is much slower.</li>
<li>Snappy assumes little-endian throughout, and needs to byte-swap data in
several places if running on a big-endian platform.</li>
</ul>
</div>
</div>

<div id="outline-container-org1e881e1" class="outline-2">
<h2 id="org1e881e1"><span class="section-number-2">2</span> Format</h2>
<div class="outline-text-2" id="text-2">
<p>
Snappy is a LZ77-type compressor with a fixed, byte-oriented encoding.
</p>

<p>
压缩的头部是一个原始串长度，然后使用变长整数方式来编码(google::protobuf也使用)
</p>

<p>
The stream starts with the uncompressed length (up to a maximum of 2<sup>32</sup> - 1),
stored as a little-endian varint. Varints consist of a series of bytes,
where the lower 7 bits are data and the upper bit is set iff there are
more bytes to be read. In other words, an uncompressed length of 64 would
be stored as 0x40, and an uncompressed length of 2097151 (0x1FFFFF)
would be stored as 0xFF 0xFF 0x7F.
</p>

<p>
对于LZ77类型的压缩算法说里面包含两个部分
</p>
<ul class="org-ul">
<li>literal(字表).这个表示原始内容</li>
<li>copy(拷贝).这个表示针对原始内容的copy.</li>
</ul>
<p>
对于LZ77类型压缩类型，所谓的copy无非就是(offset,length).然后通过精巧的编码方式将(offset,length)写入。
通常来说编码方式会比原始内容小，这样达到压缩目的。而literal和copy本身也通过编码方式来进行区分，第一个字节
低两位00表示literal,而01,10,11分别表示不同类型的copy.
</p>

<p>
Snappy实现上来说非常简单，首先针对字节流进行分块(比如32KB,现在实现就是这样的，当然可以小于32KB).针对每个32KB都压缩称为
(literal+ copy+)* literal+这样的模式。解压起来也非常简单，首先将Literal解压缩copy到output字节流里面去，然后根据后面的copy
配合之前输出的output解压出来。
</p>
</div>

<div id="outline-container-org60e15f7" class="outline-3">
<h3 id="org60e15f7"><span class="section-number-3">2.1</span> Literal</h3>
<div class="outline-text-3" id="text-2-1">
<p>
对于literal来说的话编码方式是这样的，假设literal的长度为len(len&gt;=1).
</p>
<ul class="org-ul">
<li>如果len&lt;=60.那么literal使用一个字节表示(len-1) &lt;&lt; 2 | 0x0 (1个字节)</li>
<li>如果len可以用1个字节表示的话，那么literal表示[60 &lt;&lt; 2 | 0x0, len](2个字节)</li>
<li>如果len可以用2个字节表示的话，那么literal表示[61 &lt;&lt; 2 | 0x0, len](3个字节).</li>
<li>如果len可以用3个字节表示的话，那么literal表示[62 &lt;&lt; 2 | 0x0, len](4个字节).</li>
<li>如果len可以用4个字节表示的话，那么literal表示[63 &lt;&lt; 2 | 0x0, len](5个字节).</li>
</ul>
<p>
注意这里len都是按照小端序写入的。
</p>
</div>
</div>

<div id="outline-container-org87835ce" class="outline-3">
<h3 id="org87835ce"><span class="section-number-3">2.2</span> Copy</h3>
<div class="outline-text-3" id="text-2-2">
<p>
对于copy来说的话我们假设内容是(offset,length).(offset&gt;=1,length&gt;=1).
</p>
<ul class="org-ul">
<li>如果length在[4,11],而offset在[0,2047].那么表示[(offset &gt;&gt; 8) &lt;&lt; 5 | (length-4) &lt;&lt;2 | 0x01 , offset &amp; 0xff](2个字节)</li>
<li>如果length在[1,64],而offset在[0,65535],那么表示[(length-1) &lt;&lt; 2 | 0x02 , offset](3个字节)</li>
<li>如果length在[1,64],而offset在[0,2<sup>32</sup>-1],那么表示[(length-1) &lt;&lt; 2 | 0x03, offset](5个字节)</li>
</ul>
<p>
我们这里注意到length都在[1,64]之间，如果length&gt;64的话。那么我们可以将copy切分。这个在代码里面可以看到。
</p>
</div>
</div>
</div>

<div id="outline-container-org1ec1e19" class="outline-2">
<h2 id="org1ec1e19"><span class="section-number-2">3</span> Source &amp; Sink</h2>
<div class="outline-text-2" id="text-3">
<p>
这里Source表示输入源，而Sink表示输出源。不过设计上比较遗憾的是在Compress上面使用了这两个结构，
而在Uncompress上面的话只是使用了Source这个结构，而输出源的话使用了另外一个内部类Writer.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">Compress</span>(<span style="font-weight: bold; text-decoration: underline;">Source</span>* <span style="font-weight: bold; font-style: italic;">source</span>, <span style="font-weight: bold; text-decoration: underline;">Sink</span>* <span style="font-weight: bold; font-style: italic;">sink</span>);
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">RawUncompress</span>(<span style="font-weight: bold; text-decoration: underline;">Source</span>* <span style="font-weight: bold; font-style: italic;">compressed</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">uncompressed</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20869;&#37096;&#26377;&#19968;&#20010;Writer&#23553;&#35013;&#20102;uncompressed&#25805;&#20316;</span>
</pre>
</div>

<p>
我们首先看看Sink定义的接口。能够理解这个接口全依赖这个清晰的注释。其中
</p>
<ul class="org-ul">
<li>Append接口的话是将bytes[0,n-1]这个字节流写入。</li>
<li>GetAppendBuffer的话是交出一块length的buffer。这块length的buffer的话必须一致有效直到Append被调用。当然我们也可以直接返回scratch(外围框架分配的内存).</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A Sink is an interface that consumes a sequence of bytes.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Sink</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">Sink</span>() { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">Sink</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Append "bytes[0,n-1]" to this.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Append</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">bytes</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns a writable buffer of the specified length for appending.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">May return a pointer to the caller-owned scratch buffer which</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">must have at least the indicated length.  The returned buffer is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">only valid until the next operation on this Sink.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">After writing at most "length" bytes, call Append() with the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pointer returned from this function and the number of bytes</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">written.  Many Append() implementations will avoid copying</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bytes if this function returned an internal buffer.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If a non-scratch buffer is returned, the caller may only pass a</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">prefix of it to Append().  That is, it is not correct to pass an</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">interior pointer of the returned array to Append().</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The default implementation always returns the scratch buffer.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">GetAppendBuffer</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">length</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>);

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No copying</span>
  <span style="font-weight: bold;">Sink</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Sink</span>&amp;);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Sink</span>&amp;);
};
</pre>
</div>

<p>
然后看看snappy默认实现Sink接口。这里GetAppendBuffer并没有使用scratch而是直接返回dest<sub>,这样的话可以减少1次copy.因为如果返回scratch的话</sub>，那么外部框架首先copy到scratch,然后从scratch在copy回dest<sub>.所以这里为什么Append需要判断</sub>(data!=dest_).
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A Sink implementation that writes to a flat array without any bound checks.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">UncheckedByteArraySink</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Sink</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">UncheckedByteArraySink</span>(<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">dest</span>) : dest_(dest) { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">UncheckedByteArraySink</span>();
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Append</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">data</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>);
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">GetAppendBuffer</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">len</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the current output pointer so that a caller can see how</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">many bytes were produced.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note: this is not a Sink method.</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">CurrentDestination</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> dest_; }
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">dest_</span>;
};

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">UncheckedByteArraySink</span>::<span style="font-weight: bold;">Append</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">data</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Do no copying if the caller filled in the result of GetAppendBuffer()</span>
  <span style="font-weight: bold;">if</span> (data != dest_) {
    memcpy(dest_, data, n);
  }
  dest_ += n;
}

<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; text-decoration: underline;">UncheckedByteArraySink</span>::<span style="font-weight: bold;">GetAppendBuffer</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">len</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>) {
  <span style="font-weight: bold;">return</span> dest_;
}
</pre>
</div>
<p>
其实这个Sink接口非常简单地重定向到其他部分比如文件，这个在Example里面会给出例子。
</p>

<p>
接着我们看看Source定义的接口。同样能够理解这个接口全依赖清晰的注释。其中
</p>
<ul class="org-ul">
<li>Available表示还有多少个字节剩余。</li>
<li>Peek是返回前面可以窥探到的字节流，并且返回长度。返回的buffer必须持续有效直到Skip.</li>
<li>Skip相当于告诉Source某个部分的字节流已经不需要被使用了。</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A Source is an interface that yields a sequence of bytes</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Source</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">Source</span>() { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">Source</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the number of bytes left to read from the source</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">Available</span>() <span style="font-weight: bold;">const</span> = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Peek at the next flat region of the source.  Does not reposition</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the source.  The returned region is empty iff Available()==0.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns a pointer to the beginning of the region and store its</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">length in *len.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The returned region is valid until the next call to Skip() or</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">until this object is destroyed, whichever occurs first.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The returned region may be larger than Available() (for example</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">if this ByteSource is a view on a substring of a larger source).</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The caller is responsible for ensuring that it only reads the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Available() bytes.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">Peek</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span>* <span style="font-weight: bold; font-style: italic;">len</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Skip the next n bytes.  Invalidates any buffer returned by</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a previous call to Peek().</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Available() &gt;= n</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Skip</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>) = 0;

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No copying</span>
  <span style="font-weight: bold;">Source</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Source</span>&amp;);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Source</span>&amp;);
};
</pre>
</div>
<p>
然后snappy的默认实现非常简单
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A Source implementation that yields the contents of a flat array</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">ByteArraySource</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Source</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">ByteArraySource</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">p</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>) : ptr_(p), left_(n) { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">ByteArraySource</span>();
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">Available</span>() <span style="font-weight: bold;">const</span>;
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">Peek</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span>* <span style="font-weight: bold; font-style: italic;">len</span>);
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Skip</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>);
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ptr_</span>;
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">left_</span>;
};

<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; text-decoration: underline;">ByteArraySource</span>::<span style="font-weight: bold;">Available</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> left_; }

<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; text-decoration: underline;">ByteArraySource</span>::<span style="font-weight: bold;">Peek</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span>* <span style="font-weight: bold; font-style: italic;">len</span>) {
  *len = left_;
  <span style="font-weight: bold;">return</span> ptr_;
}

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ByteArraySource</span>::<span style="font-weight: bold;">Skip</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  left_ -= n;
  ptr_ += n;
}
</pre>
</div>
<p>
从Source接口上来看到的话并不是非常好扩展。因为一开始必须知道串有多大并且从代码上看Snappy并不是一个可以增量压缩的东西。
所以个人感觉来说Source只能够做内存buffer的封装而不能够包装磁盘或者是网络流。
</p>
</div>
</div>

<div id="outline-container-orgdf9d9c7" class="outline-2">
<h2 id="orgdf9d9c7"><span class="section-number-2">4</span> Snippet</h2>
<div class="outline-text-2" id="text-4">
<p>
Snappy里面有相当多的代码片段非常精巧(一定程度上难懂)，所以有必要首先看看这些函数实现。
</p>
</div>

<div id="outline-container-org72e2e43" class="outline-3">
<h3 id="org72e2e43"><span class="section-number-3">4.1</span> Bits</h3>
<div class="outline-text-3" id="text-4-1">
<p>
定义了一些位操作，都使用了gcc内置函数
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Some bit-manipulation functions.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Bits</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return floor(log2(n)) for positive integer n.  Returns -1 iff n == 0.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">Log2Floor</span>(<span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">n</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the first set least / most significant bit, 0-indexed.  Returns an</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">undefined value if n == 0.  FindLSBSetNonZero() is similar to ffs() except</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">that it's 0-indexed.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">FindLSBSetNonZero</span>(<span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">n</span>);
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">FindLSBSetNonZero64</span>(<span style="font-weight: bold; text-decoration: underline;">uint64</span> <span style="font-weight: bold; font-style: italic;">n</span>);

 <span style="font-weight: bold;">private</span>:
  DISALLOW_COPY_AND_ASSIGN(<span style="font-weight: bold; text-decoration: underline;">Bits</span>);
};

<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">Bits</span>::<span style="font-weight: bold;">Log2Floor</span>(<span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  <span style="font-weight: bold;">return</span> n == 0 ? -1 : 31 ^ __builtin_clz(n); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21482;&#26159;&#21462;&#20302;5&#20301;&#21363;&#21487;</span>
}

<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">Bits</span>::<span style="font-weight: bold;">FindLSBSetNonZero</span>(<span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  <span style="font-weight: bold;">return</span> __builtin_ctz(n);
}

<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">Bits</span>::<span style="font-weight: bold;">FindLSBSetNonZero64</span>(<span style="font-weight: bold; text-decoration: underline;">uint64</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  <span style="font-weight: bold;">return</span> __builtin_ctzll(n);
}
</pre>
</div>

<p>
为了方便这里给出三个内置函数解释
</p>
<ul class="org-ul">
<li>int _<sub>builtin</sub><sub>clz</sub> (unsigned int x) // Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.</li>
<li>int _<sub>builtin</sub><sub>ctz</sub> (unsigned int x) // Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.</li>
<li>int _<sub>builtin</sub><sub>clzll</sub> (unsigned long long) // Similar to _<sub>builtin</sub><sub>clz</sub>, except the argument type is unsigned long long.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc7cf70b" class="outline-3">
<h3 id="orgc7cf70b"><span class="section-number-3">4.2</span> Varint</h3>
<div class="outline-text-3" id="text-4-2">
<p>
定义了如何将32位整数进行编码和解码。关于这种编码方式可以参考protobuf的链接
<a href="http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/encoding.html#varints">http://code.google.com/intl/zh-CN/apis/protocolbuffers/docs/encoding.html#varints</a>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Variable-length integer encoding.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Varint</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Maximum lengths of varint encoding of uint32.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kMax32</span> = 5;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Attempts to parse a varint32 from a prefix of the bytes in [ptr,limit-1].</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Never reads a character at or beyond limit.  If a valid/terminated varint32</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">was found in the range, stores it in *OUTPUT and returns a pointer just</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">past the last byte of the varint32. Else returns NULL.  On success,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"result &lt;= limit".</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">Parse32WithLimit</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">limit</span>,
                                      <span style="font-weight: bold; text-decoration: underline;">uint32</span>* <span style="font-weight: bold; font-style: italic;">OUTPUT</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES   "ptr" points to a buffer of length sufficient to hold "v".</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">EFFECTS    Encodes "v" into "ptr" and returns a pointer to the</span>
  <span style="font-weight: bold; font-style: italic;">//            </span><span style="font-weight: bold; font-style: italic;">byte just past the last encoded byte.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">Encode32</span>(<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>, <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">v</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">EFFECTS    Appends the varint representation of "value" to "*s".</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Append32</span>(<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">s</span>, <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">value</span>);
};

<span style="font-weight: bold;">inline</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; text-decoration: underline;">Varint</span>::<span style="font-weight: bold;">Parse32WithLimit</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">p</span>,
                                            <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">l</span>,
                                            <span style="font-weight: bold; text-decoration: underline;">uint32</span>* <span style="font-weight: bold; font-style: italic;">OUTPUT</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ptr</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(p);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">limit</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(l);
  <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; font-style: italic;">result</span>;
  <span style="font-weight: bold;">if</span> (ptr &gt;= limit) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  b = *(ptr++); result = b &amp; 127;          <span style="font-weight: bold;">if</span> (b &lt; 128) <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">done</span>;
  <span style="font-weight: bold;">if</span> (ptr &gt;= limit) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  b = *(ptr++); result |= (b &amp; 127) &lt;&lt;  7; <span style="font-weight: bold;">if</span> (b &lt; 128) <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">done</span>;
  <span style="font-weight: bold;">if</span> (ptr &gt;= limit) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  b = *(ptr++); result |= (b &amp; 127) &lt;&lt; 14; <span style="font-weight: bold;">if</span> (b &lt; 128) <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">done</span>;
  <span style="font-weight: bold;">if</span> (ptr &gt;= limit) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  b = *(ptr++); result |= (b &amp; 127) &lt;&lt; 21; <span style="font-weight: bold;">if</span> (b &lt; 128) <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">done</span>;
  <span style="font-weight: bold;">if</span> (ptr &gt;= limit) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  b = *(ptr++); result |= (b &amp; 127) &lt;&lt; 28; <span style="font-weight: bold;">if</span> (b &lt; 16) <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">done</span>;
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Value is too long to be a varint32</span>
 <span style="font-weight: bold; text-decoration: underline;">done</span>:
  *OUTPUT = result;
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(ptr);
}

<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; text-decoration: underline;">Varint</span>::<span style="font-weight: bold;">Encode32</span>(<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">sptr</span>, <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">v</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Operate on characters as unsigneds</span>
  <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ptr</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(sptr);
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">B</span> = 128;
  <span style="font-weight: bold;">if</span> (v &lt; (1&lt;&lt;7)) {
    *(ptr++) = v;
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (v &lt; (1&lt;&lt;14)) {
    *(ptr++) = v | B;
    *(ptr++) = v&gt;&gt;7;
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (v &lt; (1&lt;&lt;21)) {
    *(ptr++) = v | B;
    *(ptr++) = (v&gt;&gt;7) | B;
    *(ptr++) = v&gt;&gt;14;
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (v &lt; (1&lt;&lt;28)) {
    *(ptr++) = v | B;
    *(ptr++) = (v&gt;&gt;7) | B;
    *(ptr++) = (v&gt;&gt;14) | B;
    *(ptr++) = v&gt;&gt;21;
  } <span style="font-weight: bold;">else</span> {
    *(ptr++) = v | B;
    *(ptr++) = (v&gt;&gt;7) | B;
    *(ptr++) = (v&gt;&gt;14) | B;
    *(ptr++) = (v&gt;&gt;21) | B;
    *(ptr++) = v&gt;&gt;28;
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(ptr);
}

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Varint</span>::<span style="font-weight: bold;">Append32</span>(<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">s</span>, <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[<span style="font-weight: bold; text-decoration: underline;">Varint</span>::kMax32];
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">p</span> = <span style="font-weight: bold; text-decoration: underline;">Varint</span>::Encode32(buf, value);
  s-&gt;append(buf, p - buf);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgafc16f5" class="outline-3">
<h3 id="orgafc16f5"><span class="section-number-3">4.3</span> GetUint32AtOffset</h3>
<div class="outline-text-3" id="text-4-3">
<p>
能够从一个uint64里面取出任意偏移的uint32。通常我们一次载入一个uint64的话那么知道可以得到5个uint32,效率会很高。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For 0 &lt;= offset &lt;= 4, GetUint32AtOffset(UNALIGNED_LOAD64(p), offset) will</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">equal UNALIGNED_LOAD32(p + offset).  Motivation: On x86-64 hardware we have</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">empirically found that overlapping loads such as</span>
<span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">UNALIGNED_LOAD32(p) ... UNALIGNED_LOAD32(p+1) ... UNALIGNED_LOAD32(p+2)</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">are slower than UNALIGNED_LOAD64(p) followed by shifts and casts to uint32.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold;">GetUint32AtOffset</span>(<span style="font-weight: bold; text-decoration: underline;">uint64</span> <span style="font-weight: bold; font-style: italic;">v</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">offset</span>) {
  DCHECK(0 &lt;= offset &amp;&amp; offset &lt;= 4) &lt;&lt; offset;
  <span style="font-weight: bold;">return</span> v &gt;&gt; (<span style="font-weight: bold; text-decoration: underline;">LittleEndian</span>::IsLittleEndian() ? 8 * offset : 32 - 8 * offset);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org77352ea" class="outline-3">
<h3 id="org77352ea"><span class="section-number-3">4.4</span> GetHashTable</h3>
<div class="outline-text-3" id="text-4-4">
<p>
在Compress的时候需要得到HashTable来判断哪些地方可以得到copy.不过实话说GetHashTable其实没有太多可以值得学习的地方，但是我们还是看看吧。
至于hashtable每一个entry都是uint16表示什么东西，这个在Compress函数里面会讲到
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;Compress&#26159;&#25353;&#29031;1&#20010;&#20010;chunk&#26469;&#36827;&#34892;&#21387;&#32553;&#30340;&#65292;input_size&#34920;&#31034;&#36825;&#20010;chunk&#22823;&#23567;&#22810;&#23569;</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29616;&#22312;&#26469;&#30475;&#30340;&#35805;chunk&#26368;&#22823;32KB&#12290;&#28982;&#21518;table_size&#34920;&#31034;hashtable&#26742;&#22823;&#23567;&#12290;</span>

<span style="font-weight: bold; text-decoration: underline;">uint16</span>* <span style="font-weight: bold; text-decoration: underline;">WorkingMemory</span>::<span style="font-weight: bold;">GetHashTable</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">input_size</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>* <span style="font-weight: bold; font-style: italic;">table_size</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Use smaller hash table when input.size() is smaller, since we</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">fill the table, incurring O(hash table size) overhead for</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compression, and if the input is short, we won't need that</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">many hash table entries anyway.</span>
  assert(kMaxHashTableSize &gt;= 256);
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">htsize</span> = 256; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#20174;&#26742;&#22823;&#23567;256&#24320;&#22987;&#36827;&#34892;&#35843;&#33410;,*2&#30452;&#21040;&gt;=input_size&#25110;&#32773;&#26159;kMaxHashTableSize</span>
  <span style="font-weight: bold;">while</span> (htsize &lt; kMaxHashTableSize &amp;&amp; htsize &lt; input_size) {
    htsize &lt;&lt;= 1;
  }
  CHECK_EQ(0, htsize &amp; (htsize - 1)) &lt;&lt; <span style="font-style: italic;">": must be power of two"</span>;
  CHECK_LE(htsize, kMaxHashTableSize) &lt;&lt; <span style="font-style: italic;">": hash table too large"</span>;

  <span style="font-weight: bold; text-decoration: underline;">uint16</span>* <span style="font-weight: bold; font-style: italic;">table</span>;
  <span style="font-weight: bold;">if</span> (htsize &lt;= ARRAYSIZE(small_table_)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;WorkingMemory&#20869;&#37096;&#26377;&#19968;&#20010;small_table_[1&lt;&lt;10],&#36825;&#26679;&#21487;&#20197;&#20943;&#23569;&#20998;&#37197;&#20195;&#20215;</span>
    table = small_table_;
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">if</span> (large_table_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      large_table_ = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">uint16</span>[kMaxHashTableSize]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#22823;&#26742;&#30340;&#35805;&#37027;&#20040;&#25105;&#20204;&#38656;&#35201;new&#20986;&#26469;</span>
    }
    table = large_table_;
  }

  *table_size = htsize;
  memset(table, 0, <span style="font-weight: bold; text-decoration: underline;">htsize</span> * <span style="font-weight: bold;">sizeof</span>(*table)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">memset(0)&#26159;&#38656;&#35201;&#30340;&#65292;&#22312;Compress&#37096;&#20998;&#21487;&#20197;&#30475;&#21040;&#20026;&#20160;&#20040;&#38656;&#35201;&#28165;0.</span>
  <span style="font-weight: bold;">return</span> table;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2552514" class="outline-3">
<h3 id="org2552514"><span class="section-number-3">4.5</span> FindMatchLength</h3>
<div class="outline-text-3" id="text-4-5">
<p>
为了快速找到两个串(s1,s2)最大匹配长度多少，其中s2<sub>limit表示s2的结尾返回匹配长度</sub>。引用场景下面s1和s2是同一个串，不过(s1&lt;s2)因为我们不需要判断s1溢出。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the largest n such that</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">s1[0,n-1] == s2[0,n-1]</span>
<span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">and n &lt;= (s2_limit - s2).</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Does not read *s2_limit or beyond.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Does not read *(s1 + (s2_limit - s2)) or beyond.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Requires that s2_limit &gt;= s2.</span>

<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">FindMatchLength</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">s1</span>,
                                  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">s2</span>,
                                  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">s2_limit</span>) {
  DCHECK_GE(s2_limit, s2);
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">matched</span> = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Find out how long the match is. We loop over the data 64 bits at a</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">time until we find a 64-bit block that doesn't match; then we find</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the first non-matching bit and use that to calculate the total</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">length of the match.</span>
  <span style="font-weight: bold;">while</span> (PREDICT_TRUE(s2 &lt;= s2_limit - 8)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;s2&#36824;&#26377;8&#20010;&#20197;&#19978;&#23383;&#33410;&#30340;&#35805;</span>
    <span style="font-weight: bold;">if</span> (PREDICT_FALSE(UNALIGNED_LOAD64(s2) == UNALIGNED_LOAD64(s1 + matched))) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#25105;&#20204;&#39318;&#20808;8&#20010;&#23383;&#33410;&#36827;&#34892;&#27604;&#36739;&#65292;&#21305;&#37197;&#19978;&#30340;&#35805;+8</span>
      s2 += 8;
      matched += 8;
    } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19981;&#21305;&#37197;&#30340;&#35805;&#65292;&#37027;&#20040;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807;xor&#26469;&#21028;&#26029;&#12290;&#22914;&#26524;&#30456;&#21516;&#30340;&#35805;&#20026;0,&#28982;&#21518;&#20174;LSB&#21028;&#26029;&#26377;&#22810;&#23569;&#20010;0&#65292;&#28982;&#21518;count &gt;&gt; 3&#23601;&#34920;&#31034;&#21305;&#37197;&#23383;&#33410;&#12290;&#38750;&#24120;&#24039;&#22937;&#12290;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">On current (mid-2008) Opteron models there is a 3% more</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">efficient code sequence to find the first non-matching byte.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">However, what follows is ~10% better on Intel Core 2 and newer,</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and we expect AMD's bsf instruction to improve.</span>
      <span style="font-weight: bold; text-decoration: underline;">uint64</span> <span style="font-weight: bold; font-style: italic;">x</span> = UNALIGNED_LOAD64(s2) ^ UNALIGNED_LOAD64(s1 + matched);
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">matching_bits</span> = <span style="font-weight: bold; text-decoration: underline;">Bits</span>::FindLSBSetNonZero64(x);
      matched += matching_bits &gt;&gt; 3;
      <span style="font-weight: bold;">return</span> matched;
    }
  }
  <span style="font-weight: bold;">while</span> (PREDICT_TRUE(s2 &lt; s2_limit)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;8&#20010;&#23383;&#33410;&#30340;&#35805;&#37027;&#20040;&#20043;&#21518;&#33021;&#22815;1&#20010;&#23383;&#33410;&#36880;&#20010;&#21305;&#37197;&#12290;</span>
    <span style="font-weight: bold;">if</span> (PREDICT_TRUE(s1[matched] == *s2)) {
      ++s2;
      ++matched;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold;">return</span> matched;
    }
  }
  <span style="font-weight: bold;">return</span> matched;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8f7d7f3" class="outline-3">
<h3 id="org8f7d7f3"><span class="section-number-3">4.6</span> MaxCompressedLength</h3>
<div class="outline-text-3" id="text-4-6">
<p>
snappy接口简单很大程度上是因为对于一个input串的话，可以根据input串估计出compress之后的串长度上限。
然后进行压缩之前可以进行预分配，然后snappy内部的话在进行压缩时候就不进行字符越界检查了。
至于这个长度是如何计算出来的，可以接合此处注释以及后续对copy以及literal带来的膨胀代价分析。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">MaxCompressedLength</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">source_len</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Compressed data can be defined as:</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">compressed := item* literal*</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">item       := literal* copy</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The trailing literal sequence has a space blowup of at most 62/60</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">since a literal of length 60 needs one tag byte + one extra byte</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">for length information.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Item blowup is trickier to measure.  Suppose the "copy" op copies</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">4 bytes of data.  Because of a special check in the encoding code,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we produce a 4-byte copy only if the offset is &lt; 65536.  Therefore</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the copy op takes 3 bytes to encode, and this type of item leads</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to at most the 62/60 blowup for representing literals.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Suppose the "copy" op copies 5 bytes of data.  If the offset is big</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">enough, it will take 5 bytes to encode the copy op.  Therefore the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">worst case here is a one-byte literal followed by a five-byte copy.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">I.e., 6 bytes of input turn into 7 bytes of "compressed" data.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This last factor dominates the blowup, so the final estimate is:</span>
  <span style="font-weight: bold;">return</span> 32 + source_len + source_len/6;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org48bd2fb" class="outline-3">
<h3 id="org48bd2fb"><span class="section-number-3">4.7</span> IncrementalCopy</h3>
<div class="outline-text-3" id="text-4-7">
<p>
首先看看IncrementalCopy的原型和语义是什么
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Copy "len" bytes from "src" to "op", one byte at a time.  Used for</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">handling COPY operations where the input and output regions may</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">overlap.  For example, suppose:</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">src    == "ab"</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">op     == src + 2</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">len    == 20</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">After IncrementalCopy(src, op, len), the result will have</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">eleven copies of "ab"</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">ababababababababababab</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note that this does not match the semantics of either memcpy()</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">or memmove();</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">IncrementalCopy</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">src</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">len</span>) {
  DCHECK_GT(len, 0);
  <span style="font-weight: bold;">do</span> {
    *op++ = *src++;
  } <span style="font-weight: bold;">while</span> (--len &gt; 0);
}
</pre>
</div>
<p>
将src内容逐个copy到op上面去。但是注意这里必须是逐个copy到op上面去。因为src和op非常有可能重叠。
可能op后面的部分字节依赖于op前面部分的字节。这个语义必须清晰，和memcpy和memmove都是不同的。
简单的实现和上面一样逐个字节进行copy.这个在解压缩的时候非常有用，因为我们的literal已经解出来放在outputle，
而copy很可能和literal重叠，需要这种IncrementalCopy的实现。
</p>

<p>
但是是否有办法更快呢？下面就是一个更快的实现。首先我们是的op和src的差距拉到&gt;=8,一旦这样之后的话
就可以开始使用8个字节进行copy了。为了将差距拉到8，不断地做8个字节copy并且调整dest.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kMaxIncrementCopyOverflow</span> = 10;

<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">IncrementalCopyFastPath</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">src</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">len</span>) {
  <span style="font-weight: bold;">while</span> (op - src &lt; 8) {
    UNALIGNED_STORE64(op, UNALIGNED_LOAD64(src));
    len -= op - src;
    op += op - src;
  }
  <span style="font-weight: bold;">while</span> (len &gt; 0) {
    UNALIGNED_STORE64(op, UNALIGNED_LOAD64(src));
    src += 8;
    op += 8;
    len -= 8;
  }
}
</pre>
</div>
<p>
可能阅读这个代码比较难理解，作者良好的注释又有帮助了。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Equivalent to IncrementalCopy except that it can write up to ten extra</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bytes after the end of the copy, and that it is faster.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The main part of this loop is a simple copy of eight bytes at a time until</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we've copied (at least) the requested amount of bytes.  However, if op and</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">src are less than eight bytes apart (indicating a repeating pattern of</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">length &lt; 8), we first need to expand the pattern in order to get the correct</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">results. For instance, if the buffer looks like this, with the eight-byte</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&lt;src&gt; and &lt;op&gt; patterns marked as intervals:</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">abxxxxxxxxxxxx</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">[------]           src</span>
<span style="font-weight: bold; font-style: italic;">//      </span><span style="font-weight: bold; font-style: italic;">[------]         op</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a single eight-byte copy from &lt;src&gt; to &lt;op&gt; will repeat the pattern once,</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">after which we can move &lt;op&gt; two bytes without moving &lt;src&gt;:</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">ababxxxxxxxxxx</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">[------]           src</span>
<span style="font-weight: bold; font-style: italic;">//        </span><span style="font-weight: bold; font-style: italic;">[------]       op</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and repeat the exercise until the two no longer overlap.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This allows us to do very well in the special case of one single byte</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">repeated many times, without taking a big hit for more general cases.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The worst case of extra writing past the end of the match occurs when</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">op - src == 1 and len == 1; the last copy will read from byte positions</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">[0..7] and write to [4..11], whereas it was only supposed to write to</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">position 1. Thus, ten excess bytes.</span>
</pre>
</div>
<p>
不看上面注释我们也可以知道，使用这种方式是可能存在内存重叠copy的，并且很可能会多访问最后那么几个字节。
上面注释的分析就是，如果op+length之后后面还有10个空余字节的话那么就是安全的，所以kMaxIncrementCopyOverflow==10.
在使用上的话只有发现后面空余字节超过10字节之后的话，上面的算法才是安全的。
</p>
</div>
</div>

<div id="outline-container-org78111c9" class="outline-3">
<h3 id="org78111c9"><span class="section-number-3">4.8</span> EmitLiteral</h3>
<div class="outline-text-3" id="text-4-8">
<p>
EmitLiteral就是输出literal.虽然从Format很直观地看出literal应该怎么输出，但是还是有技巧的。最技巧的方便就是allow<sub>fast</sub><sub>path</sub>.
allow<sub>fast</sub><sub>path场景是如果op后面有15个空余字节的话</sub>，那么就可以使用2个8字节copy完成。这个在CompressFragment代码里面可以看到，
应用层面上只有在确保了op后面15个空余字节才会让allow<sub>fast</sub><sub>path</sub>==true.而其他逻辑的话因为就是正常的copy都走了memcpy这个分支。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">EmitLiteral</span>(<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op</span>,
                                <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">literal</span>,
                                <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">len</span>,
                                <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">allow_fast_path</span>) {
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span> = len - 1;      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Zero-length literals are disallowed</span>
  <span style="font-weight: bold;">if</span> (n &lt; 60) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fits in tag byte</span>
    *op++ = LITERAL | (n &lt;&lt; 2);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The vast majority of copies are below 16 bytes, for which a</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">call to memcpy is overkill. This fast path can sometimes</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">copy up to 15 bytes too much, but that is okay in the</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">main loop, since we have a bit to go on for both sides:</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">- The input will always have kInputMarginBytes = 15 extra</span>
    <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">available bytes, as long as we're in the main loop, and</span>
    <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">if not, allow_fast_path = false.</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">- The output will always have 32 spare bytes (see</span>
    <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">MaxCompressedLength).</span>
    <span style="font-weight: bold;">if</span> (allow_fast_path &amp;&amp; len &lt;= 16) {
      UNALIGNED_STORE64(op, UNALIGNED_LOAD64(literal));
      UNALIGNED_STORE64(op + 8, UNALIGNED_LOAD64(literal + 8));
      <span style="font-weight: bold;">return</span> op + len;
    }
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Encode in upcoming bytes</span>
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">base</span> = op;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">count</span> = 0;
    op++;
    <span style="font-weight: bold;">while</span> (n &gt; 0) {
      *op++ = n &amp; 0xff;
      n &gt;&gt;= 8;
      count++;
    }
    assert(count &gt;= 1);
    assert(count &lt;= 4);
    *base = LITERAL | ((59+count) &lt;&lt; 2);
  }
  memcpy(op, literal, len);
  <span style="font-weight: bold;">return</span> op + len;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org92a71c3" class="outline-3">
<h3 id="org92a71c3"><span class="section-number-3">4.9</span> EmitCopy</h3>
<div class="outline-text-3" id="text-4-9">
<p>
EmitCopy非常简单也不牵扯到数据的memcpy,只是写入(offset,length)这两个分量。但是之前说了如果length&gt;=64的话，那么是需要进行copy的切分的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">EmitCopyLessThan64</span>(<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">offset</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">len</span>) {
  DCHECK_LE(len, 64);
  DCHECK_GE(len, 4);
  DCHECK_LT(offset, 65536);

  <span style="font-weight: bold;">if</span> ((len &lt; 12) &amp;&amp; (offset &lt; 2048)) {
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">len_minus_4</span> = len - 4;
    assert(len_minus_4 &lt; 8);            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Must fit in 3 bits</span>
    *op++ = COPY_1_BYTE_OFFSET | ((len_minus_4) &lt;&lt; 2) | ((offset &gt;&gt; 8) &lt;&lt; 5);
    *op++ = offset &amp; 0xff;
  } <span style="font-weight: bold;">else</span> {
    *op++ = COPY_2_BYTE_OFFSET | ((len-1) &lt;&lt; 2);
    <span style="font-weight: bold; text-decoration: underline;">LittleEndian</span>::Store16(op, offset);
    op += 2;
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#27809;&#26377;&#22788;&#29702;offset&gt;=65536&#30340;&#26684;&#24335;&#65292;&#22240;&#20026;&#23601;&#29616;&#22312;&#23454;&#29616;&#26469;&#35828;chunk&#30340;&#22823;&#23567;&#26159;32K&#19981;&#20250;&#36896;&#25104;offset&gt;=64K&#30340;&#24773;&#20917;&#12290;</span>
  <span style="font-weight: bold;">return</span> op;
}

<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">EmitCopy</span>(<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">offset</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">len</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Emit 64 byte copies but make sure to keep at least four bytes reserved</span>
  <span style="font-weight: bold;">while</span> (len &gt;= 68) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#24517;&#39035;&#21028;&#26029;68&#65292;&#19981;&#28982;&#22914;&#26524;len&lt;4&#32780;offset&lt;208&#30340;&#35805;&#37027;&#20040;&#27809;&#26377;&#23545;&#24212;&#30340;copy&#32534;&#30721;&#24418;&#24335;</span>
    op = EmitCopyLessThan64(op, offset, 64);
    len -= 64;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Emit an extra 60 byte copy if have too much data to fit in one copy</span>
  <span style="font-weight: bold;">if</span> (len &gt; 64) {
    op = EmitCopyLessThan64(op, offset, 60);
    len -= 60;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Emit remainder</span>
  op = EmitCopyLessThan64(op, offset, len);
  <span style="font-weight: bold;">return</span> op;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd5385ab" class="outline-2">
<h2 id="orgd5385ab"><span class="section-number-2">5</span> Compress</h2>
<div class="outline-text-2" id="text-5">
<p>
终于进行Compress正题了，看看大体框架吧。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">Compress</span>(<span style="font-weight: bold; text-decoration: underline;">Source</span>* <span style="font-weight: bold; font-style: italic;">reader</span>, <span style="font-weight: bold; text-decoration: underline;">Sink</span>* <span style="font-weight: bold; font-style: italic;">writer</span>) {

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#21462;&#24471;reader&#30340;&#38271;&#24230;&#36827;&#34892;&#32534;&#30721;&#25918;&#22312;&#26368;&#24320;&#22836;</span>

    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">written</span> = 0;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">N</span> = reader-&gt;Available();
    <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">ulength</span>[<span style="font-weight: bold; text-decoration: underline;">Varint</span>::kMax32];
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">dest</span>= writer-&gt;GetAppendBuffer(<span style="font-weight: bold; text-decoration: underline;">Varint</span>::kMax32,ulength);
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">p</span> = <span style="font-weight: bold; text-decoration: underline;">Varint</span>::Encode32(dest,N);
    writer-&gt;Append(dest,p-dest);
    written += (p - dest);

    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">size_t written = 0;</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">int N = reader-&gt;Available();</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">char ulength[Varint::kMax32];</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">char* p = Varint::Encode32(ulength, N);</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">writer-&gt;Append(ulength, p-ulength);</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">written += (p - ulength);</span>

  <span style="font-weight: bold; text-decoration: underline;">internal</span>::<span style="font-weight: bold; text-decoration: underline;">WorkingMemory</span> <span style="font-weight: bold; font-style: italic;">wmem</span>;
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch_output</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

  <span style="font-weight: bold;">while</span> (N &gt; 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;num_to_read&#34920;&#31034;&#26412;&#27425;&#21387;&#32553;chunk&#30340;&#22823;&#23567;</span>

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Get next block to compress (without copying if possible)</span>
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">fragment_size</span>;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">fragment</span> = reader-&gt;Peek(&amp;fragment_size);
    DCHECK_NE(fragment_size, 0) &lt;&lt; <span style="font-style: italic;">": premature end of input"</span>;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">num_to_read</span> = min(N, kBlockSize);
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes_read</span> = fragment_size;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#22320;&#26041;&#20250;&#23581;&#35797;&#21457;&#36215;&#22810;&#27425;&#35835;&#65292;&#20294;&#26159;&#23601;&#29616;&#22312;Snappy&#40664;&#35748;&#23454;&#29616;&#26469;&#35828;&#65292;&#20854;&#23454;&#23601;&#26159;&#19968;&#27493;&#21040;&#20301;&#65292;&#19981;&#20250;&#36827;&#20837;else&#36923;&#36753;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#26159;&#21363;&#20351;&#36827;&#20837;&#19979;&#38754;&#36923;&#36753;&#20063;&#38750;&#24120;&#31616;&#21333;&#65292;&#26080;&#38750;&#23601;&#26159;&#22810;&#27425;&#21457;&#36215;&#35835;&#28982;&#21518;&#25918;&#22312;scratch&#20869;&#23384;&#37324;&#38754;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20986;&#36825;&#20010;&#21028;&#26029;&#20043;&#21518;&#65292;&#22320;&#22336;&#21644;&#22823;&#23567;&#25918;&#22312;&#20102;fragment,fragment_size&#37324;&#38754;&#12290;</span>

    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">pending_advance</span> = 0;
    <span style="font-weight: bold;">if</span> (bytes_read &gt;= num_to_read) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Buffer returned by reader is large enough</span>
      pending_advance = num_to_read;
      fragment_size = num_to_read;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read into scratch buffer</span>
      <span style="font-weight: bold;">if</span> (scratch == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If this is the last iteration, we want to allocate N bytes</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of space, otherwise the max possible kBlockSize space.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">num_to_read contains exactly the correct value</span>
        scratch = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[num_to_read];
      }
      memcpy(scratch, fragment, bytes_read);
      reader-&gt;Skip(bytes_read);

      <span style="font-weight: bold;">while</span> (bytes_read &lt; num_to_read) {
        fragment = reader-&gt;Peek(&amp;fragment_size);
        <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span> = min&lt;<span style="font-weight: bold; text-decoration: underline;">size_t</span>&gt;(fragment_size, num_to_read - bytes_read);
        memcpy(scratch + bytes_read, fragment, n);
        bytes_read += n;
        reader-&gt;Skip(n);
      }
      DCHECK_EQ(bytes_read, num_to_read);
      fragment = scratch;
      fragment_size = num_to_read;
    }
    DCHECK_EQ(fragment_size, num_to_read);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20934;&#22791;&#38024;&#23545;fragment&#26469;&#36827;&#34892;&#21387;&#32553;&#65292;&#39318;&#20808;&#25105;&#20204;&#21019;&#24314;&#19968;&#20010;hashtable</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Get encoding table for compression</span>
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">table_size</span>;
    <span style="font-weight: bold; text-decoration: underline;">uint16</span>* <span style="font-weight: bold; font-style: italic;">table</span> = wmem.GetHashTable(num_to_read, &amp;table_size);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38024;&#23545;&#36825;&#27425;&#21387;&#32553;&#30340;&#35805;&#65292;&#20020;&#26102;&#31354;&#38388;&#21040;&#24213;&#24212;&#35813;&#24320;&#36767;&#22810;&#22823;&#12290;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Compress input_fragment and append to dest</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">max_output</span> = MaxCompressedLength(num_to_read);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Need a scratch buffer for the output, in case the byte sink doesn't</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">have room for us directly.</span>
    <span style="font-weight: bold;">if</span> (scratch_output == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      scratch_output = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[max_output];
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Since we encode kBlockSize regions followed by a region</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">which is &lt;= kBlockSize in length, a previously allocated</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">scratch_output[] region is big enough for this iteration.</span>
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992;CompressFragment&#26469;&#21387;&#32553;&#36825;&#20010;fragment</span>
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">dest</span> = writer-&gt;GetAppendBuffer(max_output, scratch_output);
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">end</span> = <span style="font-weight: bold; text-decoration: underline;">internal</span>::CompressFragment(fragment, fragment_size,
                                           dest, table, table_size);
    writer-&gt;Append(dest, end - dest);
    written += (end - dest);

    N -= num_to_read;
    reader-&gt;Skip(pending_advance);
  }

  <span style="font-weight: bold;">delete</span>[] scratch;
  <span style="font-weight: bold;">delete</span>[] scratch_output;

  <span style="font-weight: bold;">return</span> written;
}
</pre>
</div>

<p>
整个过程并不是很麻烦，无非就是切出chunk出来并且初始化hashtable然后交给CompressFragment来处理。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">CompressFragment</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">input</span>,
                       <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">input_size</span>,
                       <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op</span>,
                       <span style="font-weight: bold; text-decoration: underline;">uint16</span>* <span style="font-weight: bold; font-style: italic;">table</span>,
                       <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">table_size</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"ip" is the input pointer, and "op" is the output pointer.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ip</span> = input;
  CHECK_LE(input_size, kBlockSize);
  CHECK_EQ(table_size &amp; (table_size - 1), 0) &lt;&lt; <span style="font-style: italic;">": table must be power of two"</span>;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">shift</span> = 32 - <span style="font-weight: bold; text-decoration: underline;">Bits</span>::Log2Floor(table_size);
  DCHECK_EQ(kuint32max &gt;&gt; shift, table_size - 1);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ip_end</span> = input + input_size;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">base_ip</span> = ip;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Bytes in [next_emit, ip) will be emitted as literal bytes.  Or</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">[next_emit, ip_end) after the main loop.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">next_emit</span> = ip;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22238;&#24819;&#19968;&#19979;&#25105;&#20204;&#20043;&#21069;EmitLiteral&#24517;&#39035;&#30830;&#20445;15&#20010;&#23383;&#33410;&#25165;&#26377;allow_fast_path</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#25105;&#20204;&#30830;&#20445;&#26368;&#21518;15&#20010;&#23383;&#33410;&#36827;&#34892;literal&#30340;&#35805;&#65292;&#37027;&#20040;op&#21518;&#38754;&#24517;&#39035;&#23384;&#22312;&gt;=15&#23383;&#33410;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#26679;&#21069;&#38754;&#36827;&#34892;EmitLiteral&#37117;&#21487;&#20197;&#36827;&#34892;allow_fast_path&#20102;&#12290;</span>

  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kInputMarginBytes</span> = 15;
  <span style="font-weight: bold;">if</span> (PREDICT_TRUE(input_size &gt;= kInputMarginBytes)) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ip_limit</span> = input + input_size - kInputMarginBytes;

    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">next_hash</span> = Hash(++ip, shift); ; ) {
      DCHECK_LT(next_emit, ip);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The body of this loop calls EmitLiteral once and then EmitCopy one or</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">more times.  (The exception is that when we're close to exhausting</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the input we goto emit_remainder.)</span>
      <span style="font-weight: bold; font-style: italic;">//</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">In the first iteration of this loop we're just starting, so</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">there's nothing to copy, so calling EmitLiteral once is</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">necessary.  And we only start a new iteration when the</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">current iteration has determined that a call to EmitLiteral will</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">precede the next call to EmitCopy (if any).</span>
      <span style="font-weight: bold; font-style: italic;">//</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Step 1: Scan forward in the input looking for a 4-byte-long match.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we get close to exhausting the input then goto emit_remainder.</span>
      <span style="font-weight: bold; font-style: italic;">//</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Heuristic match skipping: If 32 bytes are scanned with no matches</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">found, start looking only at every other byte. If 32 more bytes are</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">scanned, look at every third byte, etc.. When a match is found,</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">immediately go back to looking at every byte. This is a small loss</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(~5% performance, ~0.1% density) for compressible data due to more</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bookkeeping, but for non-compressible data (such as JPEG) it's a huge</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">win since the compressor quickly "realizes" the data is incompressible</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and doesn't bother looking for matches everywhere.</span>
      <span style="font-weight: bold; font-style: italic;">//</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The "skip" variable keeps track of how many bytes there are since the</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">last match; dividing it by 32 (ie. right-shifting by five) gives the</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">number of bytes to move ahead for each iteration.</span>
      <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">skip</span> = 32;

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25105;&#20204;&#39318;&#20808;&#26597;&#25214;4bytes&#30340;match</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;hash==Hash(Load32(ip)),&#28982;&#21518;table[hash]=ip-base_ip.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#26742;&#37324;&#38754;&#30340;&#20869;&#23481;&#23601;&#26159;&#30456;&#23545;&#20110;base_ip&#20063;&#23601;&#26159;&#36215;&#22987;&#36755;&#20837;&#30340;&#20559;&#31227;</span>

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#38656;&#35201;&#29992;&#34920;&#36798;&#26159;&#34920;&#26126;&#30340;&#35805;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">table[Hash(Load32(ip))]=ip-base_ip</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#26679;&#25105;&#20204;&#21487;&#20197;&#36890;&#36807;&#39318;&#20808;&#21305;&#37197;hash&#65292;&#19968;&#26086;hash&#21305;&#37197;&#19978;&#28982;&#21518;&#26816;&#26597;&#20869;&#23481;&#26159;&#21542;&#30456;&#21516;&#26469;&#21457;&#29616;match</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#22914;&#26524;&#20986;&#29616;hash&#20914;&#31361;&#30340;&#35805;&#37027;&#20040;table&#26159;&#19981;&#26029;update&#30340;</span>

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21478;&#22806;&#19968;&#20010;&#26377;&#36259;&#30340;&#20107;&#24773;&#23601;&#26159;&#36825;&#20010;skip</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21487;&#20197;&#30475;&#21040;&#21069;&#38754;32&#27425;&#37117;&#26159;&#25353;&#29031;1&#20010;&#23383;&#33410;&#36339;&#36291;&#65292;&#30452;&#21040;skip==64</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#25353;&#29031;2&#20010;&#23383;&#33410;&#36339;&#36291;&#65292;&#30452;&#21040;skip==128</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#26159;&#19968;&#31181;&#21551;&#21457;&#26159;&#30340;&#21305;&#37197;&#31639;&#27861;</span>
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">next_ip</span> = ip;
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">candidate</span>;
      <span style="font-weight: bold;">do</span> {
        ip = next_ip;
        <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">hash</span> = next_hash;
        DCHECK_EQ(hash, Hash(ip, shift));
        <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">bytes_between_hash_lookups</span> = skip++ &gt;&gt; 5;
        next_ip = ip + bytes_between_hash_lookups;
        <span style="font-weight: bold;">if</span> (PREDICT_FALSE(next_ip &gt; ip_limit)) {
          <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">emit_remainder</span>;
        }
        next_hash = Hash(next_ip, shift);

        candidate = base_ip + table[hash];
        DCHECK_GE(candidate, base_ip);
        DCHECK_LT(candidate, ip);

        table[hash] = ip - base_ip;
      } <span style="font-weight: bold;">while</span> (PREDICT_TRUE(UNALIGNED_LOAD32(ip) !=
                            UNALIGNED_LOAD32(candidate)));


      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21040;&#36825;&#20010;&#27493;&#39588;&#20043;&#21518;&#30340;&#35805;&#65292;&#37027;&#20040;ip&#21644;candidate&#23601;&#23436;&#20840;&#21305;&#37197;&#19978;&#20102;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25105;&#20204;&#21487;&#20197;&#23558;[next_emit,ip-1]&#20316;&#20026;literal&#36755;&#20986;</span>

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Step 2: A 4-byte match has been found.  We'll later see if more</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">than 4 bytes match.  But, prior to the match, input</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bytes [next_emit, ip) are unmatched.  Emit them as "literal bytes."</span>
      DCHECK_LE(next_emit + 16, ip_end); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">including margin bytes.</span>
      op = EmitLiteral(op, next_emit, ip - next_emit, <span style="font-weight: bold; text-decoration: underline;">true</span>);

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#25105;&#20204;&#36827;&#34892;copy&#36755;&#20986;</span>

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Step 3: Call EmitCopy, and then see if another EmitCopy could</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">be our next move.  Repeat until we find no match for the</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">input immediately after what was consumed by the last EmitCopy call.</span>
      <span style="font-weight: bold; font-style: italic;">//</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we exit this loop normally then we need to call EmitLiteral next,</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">though we don't yet know how big the literal will be.  We handle that</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">by proceeding to the next iteration of the main loop.  We also can exit</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">this loop via goto if we get close to exhausting the input.</span>
      <span style="font-weight: bold; text-decoration: underline;">uint64</span> <span style="font-weight: bold; font-style: italic;">input_bytes</span> = 0;
      <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">candidate_bytes</span> = 0;

      <span style="font-weight: bold;">do</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We have a 4-byte match at ip, and no need to emit any</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"literal bytes" prior to ip.</span>
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">base</span> = ip;

        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;ip&#21644;candidate&#21305;&#37197;&#30340;&#35805;&#65292;&#37027;&#20040;&#23581;&#35797;&#21462;&#21457;&#29616;&#26356;&#38271;&#30340;copy</span>

        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">matched</span> = 4 + FindMatchLength(candidate + 4, ip + 4, ip_end);
        ip += matched;
        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">offset</span> = base - candidate;
        DCHECK_EQ(0, memcmp(base, candidate, matched));
        op = EmitCopy(op, offset, matched);

        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#38754;&#26159;&#31639;&#27861;&#30340;&#20248;&#21270;&#65292;&#26356;&#26032;&#19968;&#19979;Hash(ip-1),&#28982;&#21518;&#30475;&#30475;&#21518;&#38754;ip&#26159;&#21542;&#31435;&#21051;&#26377;candidate&#21305;&#37197;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We could immediately start working at ip now, but to improve</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compression we first update table[Hash(ip - 1, ...)].</span>
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">insert_tail</span> = ip - 1;
        next_emit = ip;
        <span style="font-weight: bold;">if</span> (PREDICT_FALSE(ip &gt;= ip_limit)) {
          <span style="font-weight: bold;">goto</span> <span style="font-weight: bold; text-decoration: underline;">emit_remainder</span>;
        }
        input_bytes = UNALIGNED_LOAD64(insert_tail);
        <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">prev_hash</span> = HashBytes(GetUint32AtOffset(input_bytes, 0), shift);
        table[prev_hash] = ip - base_ip - 1;
        <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">cur_hash</span> = HashBytes(GetUint32AtOffset(input_bytes, 1), shift);
        candidate = base_ip + table[cur_hash];
        candidate_bytes = UNALIGNED_LOAD32(candidate);
        table[cur_hash] = ip - base_ip;
      } <span style="font-weight: bold;">while</span> (GetUint32AtOffset(input_bytes, 1) == candidate_bytes);

      next_hash = HashBytes(GetUint32AtOffset(input_bytes, 2), shift);
      ++ip;
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26368;&#21518;&#37096;&#20998;&#27809;&#26377;&gt;=15&#20010;&#23383;&#33410;&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#30452;&#25509;&#20316;&#20026;literal&#36755;&#20986;&#65292;&#20294;&#26159;&#32943;&#23450;&#19981;&#33021;&#22815;allow_fast_path</span>
 <span style="font-weight: bold; text-decoration: underline;">emit_remainder</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Emit the remaining bytes as a literal</span>
  <span style="font-weight: bold;">if</span> (next_emit &lt; ip_end) {
    op = EmitLiteral(op, next_emit, ip_end - next_emit, <span style="font-weight: bold; text-decoration: underline;">false</span>);
  }

  <span style="font-weight: bold;">return</span> op;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org13d1901" class="outline-2">
<h2 id="org13d1901"><span class="section-number-2">6</span> Uncompress</h2>
<div class="outline-text-2" id="text-6">
<p>
Uncompress最终走到的逻辑是下面这个代码。比较重要的就是SnappyDecompressor以及Write这个接口。不过从代码逻辑上看非常简单，
首先ReadUncompressedLength，然后writer设置最终解码之后应该多大。然后decompressor开始分析各个tag了。最后decompressor判断是否读完以及
writer判断自己解码之后长度和uncompressed<sub>len是否相同</sub>。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span> &lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Writer</span>&gt;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">InternalUncompress</span>(<span style="font-weight: bold; text-decoration: underline;">Source</span>* <span style="font-weight: bold; font-style: italic;">r</span>,
                               <span style="font-weight: bold; text-decoration: underline;">Writer</span>* <span style="font-weight: bold; font-style: italic;">writer</span>,
                               <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">max_len</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read the uncompressed length from the front of the compressed input</span>
  <span style="font-weight: bold; text-decoration: underline;">SnappyDecompressor</span> <span style="font-weight: bold; font-style: italic;">decompressor</span>(r);
  <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">uncompressed_len</span> = 0;
  <span style="font-weight: bold;">if</span> (!decompressor.ReadUncompressedLength(&amp;uncompressed_len)) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Protect against possible DoS attack</span>
  <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">static_cast</span>&lt;uint64&gt;(uncompressed_len) &gt; max_len) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }

  writer-&gt;SetExpectedLength(uncompressed_len);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Process the entire input</span>
  decompressor.DecompressAllTags(writer);
  <span style="font-weight: bold;">return</span> (decompressor.eof() &amp;&amp; writer-&gt;CheckLength());
}
</pre>
</div>
</div>

<div id="outline-container-orgf2828eb" class="outline-3">
<h3 id="orgf2828eb"><span class="section-number-3">6.1</span> Writer</h3>
<div class="outline-text-3" id="text-6-1">
<p>
我们首先看看一个实现SnappyArrayWriter.最关键的两个函数就是Append(copy literal)以及AppendFromSelf(copy copy).
然后对于SnappyDecompressor分析出literal以及copy之后就可以调用这两个函数来进行解压缩了。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">SnappyArrayWriter</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">base_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36215;&#22987;&#22320;&#22336;</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#25805;&#20316;&#22320;&#22336;</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op_limit_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#25805;&#20316;&#38408;&#20540;</span>

 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">SnappyArrayWriter</span>(<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">dst</span>)
      : base_(dst),
        op_(dst) {
  }

  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SetExpectedLength</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">len</span>) {
    op_limit_ = op_ + len; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;&#38408;&#20540;</span>
  }

  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">CheckLength</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> op_ == op_limit_; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;&#38271;&#24230;&#26159;&#21542;&#21305;&#37197;</span>
  }

  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Append</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ip</span>, <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">len</span>, <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">allow_fast_path</span>) {
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op</span> = op_;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">space_left</span> = op_limit_ - op;
    <span style="font-weight: bold;">if</span> (allow_fast_path &amp;&amp; len &lt;= 16 &amp;&amp; space_left &gt;= 16) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fast path, used for the majority (about 90%) of dynamic invocations.</span>
      UNALIGNED_STORE64(op, <span style="font-weight: bold; text-decoration: underline;">UNALIGNED_LOAD64</span>(<span style="font-weight: bold; font-style: italic;">ip</span>));
      UNALIGNED_STORE64(op + 8, UNALIGNED_LOAD64(ip + 8));
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold;">if</span> (space_left &lt; len) {
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
      }
      memcpy(op, ip, len);
    }
    op_ = op + len;
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }

  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">AppendFromSelf</span>(<span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">offset</span>, <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">len</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;&#33258;&#36523;&#22797;&#21046;&#65292;&#21521;&#21069;&#36208;offset&#28982;&#21518;copy len&#20010;&#23383;&#33410;&#25968;&#25454;</span>
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">op</span> = op_;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">space_left</span> = op_limit_ - op;

    <span style="font-weight: bold;">if</span> (op - base_ &lt;= offset - 1u) {  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">-1u catches offset==0</span>
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
    }
    <span style="font-weight: bold;">if</span> (len &lt;= 16 &amp;&amp; offset &gt;= 8 &amp;&amp; space_left &gt;= 16) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21482;&#26377;offset&gt;=8&#25165;&#21487;&#20197;&#30452;&#25509;&#25805;&#20316;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fast path, used for the majority (70-80%) of dynamic invocations.</span>
      UNALIGNED_STORE64(op, UNALIGNED_LOAD64(op - offset));
      UNALIGNED_STORE64(op + 8, UNALIGNED_LOAD64(op - offset + 8));
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold;">if</span> (space_left &gt;= len + kMaxIncrementCopyOverflow) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#20801;&#35768;FastPath&#30340;&#35805;</span>
        IncrementalCopyFastPath(op - offset, op, len);
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold;">if</span> (space_left &lt; len) {
          <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
        }
        IncrementalCopy(op - offset, op, len);
      }
    }

    op_ = op + len;
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }
};
</pre>
</div>

<p>
不难想到如果修改一下这个实现的话那么可以做检查器，我们只是验证压缩包是否正确。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A Writer that drops everything on the floor and just does validation</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">SnappyDecompressionValidator</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">expected_</span>;
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">produced_</span>;

 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold;">SnappyDecompressionValidator</span>() : produced_(0) { }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SetExpectedLength</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">len</span>) {
    expected_ = len;
  }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">CheckLength</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> expected_ == produced_;
  }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Append</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ip</span>, <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">len</span>, <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">allow_fast_path</span>) {
    produced_ += len;
    <span style="font-weight: bold;">return</span> produced_ &lt;= expected_;
  }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">AppendFromSelf</span>(<span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">offset</span>, <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">len</span>) {
    <span style="font-weight: bold;">if</span> (produced_ &lt;= offset - 1u) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">-1u catches offset==0</span>
    produced_ += len;
    <span style="font-weight: bold;">return</span> produced_ &lt;= expected_;
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org945a651" class="outline-3">
<h3 id="org945a651"><span class="section-number-3">6.2</span> SnappyDecompressor</h3>
<div class="outline-text-3" id="text-6-2">
<p>
SnappyDecompressor有几个比较重要的方法：
</p>
<ul class="org-ul">
<li>ReadUncompressedLength.这个就是解压缩开头的Varint.这个没有太大的问题。</li>
<li>DecompressAllTags.这个是解压缩所有的tag，源是RefillTag填充的scratch[].</li>
<li>RefillTag.填充tag所需要的字节到scratch[]内部。这个也没有太大问题。</li>
</ul>
<p>
在看这个代码之前，我们想想如果我们得到scratch之后应该如何从中提取tag信息呢？最好的方式就是打表。
因为tag的头一个字节反应了这个tag所有信息，所以在snappy里面有char<sub>table这个表以头一个字节内容作为索引</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Data stored per entry in lookup table:</span>
<span style="font-weight: bold; font-style: italic;">//      </span><span style="font-weight: bold; font-style: italic;">Range   Bits-used       Description</span>
<span style="font-weight: bold; font-style: italic;">//      </span><span style="font-weight: bold; font-style: italic;">------------------------------------</span>
<span style="font-weight: bold; font-style: italic;">//      </span><span style="font-weight: bold; font-style: italic;">1..64   0..7            Literal/copy length encoded in opcode byte</span>
<span style="font-weight: bold; font-style: italic;">//      </span><span style="font-weight: bold; font-style: italic;">0..7    8..10           Copy offset encoded in opcode byte / 256</span>
<span style="font-weight: bold; font-style: italic;">//      </span><span style="font-weight: bold; font-style: italic;">0..4    11..13          Extra bytes after opcode</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We use eight bits for the length even though 7 would have sufficed</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">because of efficiency reasons:</span>
<span style="font-weight: bold; font-style: italic;">//      </span><span style="font-weight: bold; font-style: italic;">(1) Extracting a byte is faster than a bit-field</span>
<span style="font-weight: bold; font-style: italic;">//      </span><span style="font-weight: bold; font-style: italic;">(2) It properly aligns copy offset so we do not need a &lt;&lt;8</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint16</span> <span style="font-weight: bold; font-style: italic;">char_table</span>[256] = {
  0x0001, 0x0804, 0x1001, 0x2001, 0x0002, 0x0805, 0x1002, 0x2002,
  0x0003, 0x0806, 0x1003, 0x2003, 0x0004, 0x0807, 0x1004, 0x2004,
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">...</span>
};
</pre>
</div>
<p>
这个表是可以计算出来的
</p>
<ul class="org-ul">
<li>[0..7]表示literal/copy长度,因为不管是literal/copy长度。对于copy是足够的，但是对于literal来说的话能够根据高extra byte判断后面剩余长度字节。</li>
<li>[8..10]表示copy的offset / 256,对于offset剩余内容通过extra表示</li>
<li>[11..13]表示后面剩余多少个字节。通过wordmask来提取。</li>
</ul>
<p>
这里workmask
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">wordmask</span>[] = {
  0u, 0xffu, 0xffffu, 0xffffffu, 0xffffffffu
};
</pre>
</div>
<p>
这样如果extra bytes==1的话，通过&amp; 0xffu可以取到1个字节。这个在代码里面就会有体现。非常精巧。
</p>

<p>
我们看看DecompressAllTags这个函数实现
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Process the next item found in the input.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns true if successful, false on error or end of input.</span>
<span style="font-weight: bold;">template</span> &lt;<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Writer</span>&gt;
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">DecompressAllTags</span>(<span style="font-weight: bold; text-decoration: underline;">Writer</span>* <span style="font-weight: bold; font-style: italic;">writer</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ip</span> = ip_;
  <span style="font-weight: bold;">for</span> ( ;; ) {
    <span style="font-weight: bold;">if</span> (ip_limit_ - ip &lt; 5) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19981;&#22815;5&#20010;&#23383;&#33410;&#30340;&#35805;&#37027;&#20040;&#23601;&#22635;&#20805;&#65292;&#20294;&#26159;&#22635;&#20805;&#32467;&#26524;&#19981;&#19968;&#23450;&#36798;&#21040;5&#20010;&#23383;&#33410;&#12290;</span>
      ip_ = ip;
      <span style="font-weight: bold;">if</span> (!RefillTag()) <span style="font-weight: bold;">return</span>;
      ip = ip_;
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462;tag&#31532;&#19968;&#20010;&#23383;&#33410;&#21040;c,&#24471;&#21040;entry</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">c</span> = *(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(ip++));
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">entry</span> = char_table[c];
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25105;&#20204;&#23558;extra bytes&#25353;&#29031;uint32&#36733;&#20837;&#65292;&#28982;&#21518;&#26681;&#25454;wordmask&#30693;&#36947;&#65292;&#38500;&#20102;&#30041;&#22312;c&#37324;&#38754;&#30340;&#38271;&#24230;&#20449;&#24687;&#20043;&#22806;&#65292;&#23384;&#25918;&#22312;extra bytes&#37324;&#38754;&#30340;&#38271;&#24230;&#20449;&#24687;&#65292;&#21483;&#20570;trailer.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">trailer</span> = <span style="font-weight: bold; text-decoration: underline;">LittleEndian</span>::Load32(ip) &amp; wordmask[entry &gt;&gt; 11];
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ip&#21518;&#38754;extra bytes&#36339;&#36807;</span>
    ip += entry &gt;&gt; 11;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24471;&#21040;&#25918;&#22312;c&#37324;&#38754;&#30340;&#38271;&#24230;&#20449;&#24687;</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">length</span> = entry &amp; 0xff;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36825;&#20010;tag&#26159;LITERAL&#30340;&#35805;</span>
    <span style="font-weight: bold;">if</span> ((<span style="font-weight: bold; text-decoration: underline;">c</span> &amp; 0x3) == LITERAL) {
      <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">literal_length</span> = length + trailer; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;trailer&#34920;&#31034;literal_length&#37096;&#20998;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#38754;&#25805;&#20316;&#23601;&#26159;&#20889;&#20837;LITERAL</span>
      <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">avail</span> = ip_limit_ - ip;
      <span style="font-weight: bold;">while</span> (avail &lt; literal_length) {
        <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">allow_fast_path</span> = (avail &gt;= 16);
        <span style="font-weight: bold;">if</span> (!writer-&gt;Append(ip, avail, allow_fast_path)) <span style="font-weight: bold;">return</span>;
        literal_length -= avail;
        reader_-&gt;Skip(peeked_);
        <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>;
        ip = reader_-&gt;Peek(&amp;n);
        avail = n;
        peeked_ = avail;
        <span style="font-weight: bold;">if</span> (avail == 0) <span style="font-weight: bold;">return</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Premature end of input</span>
        ip_limit_ = ip + avail;
      }
      <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">allow_fast_path</span> = (avail &gt;= 16);
      <span style="font-weight: bold;">if</span> (!writer-&gt;Append(ip, literal_length, allow_fast_path)) {
        <span style="font-weight: bold;">return</span>;
      }
      ip += literal_length;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;COPY&#30340;&#35805;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">copy_offset/256 is encoded in bits 8..10.  By just fetching</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">those bits, we get copy_offset (since the bit-field starts at</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bit 8).</span>
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32</span> <span style="font-weight: bold; font-style: italic;">copy_offset</span> = (entry &amp; 0x700) ; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#20010;&#22320;&#26041;&#24050;&#32463; * 256&#20102;&#65292;&#25105;&#20204;&#19981;&#38656;&#35201;&#36827;&#34892;&#20219;&#20309;&#25805;&#20316;</span>
       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22238;&#24518;COPY(01)&#30340;(offset &gt;&gt; 8) &lt;&lt; 5.&#25152;&#20197;&#36825;&#20010;&#22320;&#26041;&#30452;&#25509;&#23601;&#26159;&#36825;&#20010;&#32467;&#26524;</span>
       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;copy&#30340;&#35805;&#65292;&#37027;&#20040;trailer&#20449;&#24687;&#26159;offset&#32780;&#19981;&#26159;length</span>
       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23558;COPY&#20889;&#20837;.</span>
      <span style="font-weight: bold;">if</span> (!writer-&gt;AppendFromSelf(copy_offset + trailer, length)) {
        <span style="font-weight: bold;">return</span>;
      }
    }
  }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9d97d08" class="outline-2">
<h2 id="org9d97d08"><span class="section-number-2">7</span> Example</h2>
<div class="outline-text-2" id="text-7">
<p>
工作很简单，首先从main.cc里面读取内容然后压缩到main.cc.compress文件里面，然后读取出来解压缩对比是否正确。这里我们演示了Sink如何封装。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;sys/stat.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;unistd.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;fcntl.h&gt;</span>

<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;snappy.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;snappy-sinksource.h&gt;</span>

<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">IN_NAME</span>=<span style="font-style: italic;">"./main.cc"</span>;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">OUT_NAME</span>=<span style="font-style: italic;">"./main.cc.compress"</span>;

<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">FileSink</span>:<span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">snappy</span>::<span style="font-weight: bold; text-decoration: underline;">Sink</span>{
  <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold;">FileSink</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>):<span style="font-weight: bold;">fd_</span>(fd){
    }
    <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">FileSink</span>(){}
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">GetAppendBuffer</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">length</span>,<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>){
        <span style="font-weight: bold;">return</span> scratch;
    }
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Append</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">bytes</span>,<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>){
        write(fd_,bytes,n);
    }
  <span style="font-weight: bold;">private</span>:
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd_</span>;
};

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(){
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">stat</span> <span style="font-weight: bold; font-style: italic;">stbuf</span>;
    <span style="font-weight: bold; font-style: italic;">stat</span>(IN_NAME,&amp;stbuf);
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">in_fsize</span>=stbuf.st_size;
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">compress_fsize</span>=0;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">do comress</span>
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">in_buf</span>=<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[in_fsize];
    {
        <span style="font-weight: bold; text-decoration: underline;">FILE</span>* <span style="font-weight: bold; font-style: italic;">fin</span>=fopen(IN_NAME,<span style="font-style: italic;">"rb"</span>);
        fread(in_buf,1,in_fsize,fin);
        fclose(fin);
        <span style="font-weight: bold; text-decoration: underline;">snappy</span>::<span style="font-weight: bold; text-decoration: underline;">ByteArraySource</span> <span style="font-weight: bold; font-style: italic;">source</span>(in_buf,in_fsize);

        <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>=open(OUT_NAME,O_CREAT | O_WRONLY,0666);
        <span style="font-weight: bold; text-decoration: underline;">FileSink</span> <span style="font-weight: bold; font-style: italic;">sink</span>(fd);
        compress_fsize=<span style="font-weight: bold; text-decoration: underline;">snappy</span>::Compress(&amp;source,&amp;sink);
        close(fd);
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">do decompress</span>
    <span style="font-weight: bold; font-style: italic;">stat</span>(OUT_NAME,&amp;stbuf);
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">out_fsize</span>=stbuf.st_size;
    assert(out_fsize==compress_fsize);
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">out_buf</span>=<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[out_fsize];
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">out</span>;
    {
        <span style="font-weight: bold; text-decoration: underline;">FILE</span>* <span style="font-weight: bold; font-style: italic;">fin</span>=fopen(OUT_NAME,<span style="font-style: italic;">"rb"</span>);
        fread(out_buf,1,out_fsize,fin);
        fclose(fin);
        assert(<span style="font-weight: bold; text-decoration: underline;">snappy</span>::Uncompress(out_buf,out_fsize,&amp;out)==<span style="font-weight: bold; text-decoration: underline;">true</span>);
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">do validate</span>
    assert(out.size()==in_fsize);
    assert(memcmp(out.data(),in_buf,in_fsize)==0);
    <span style="font-weight: bold;">delete</span> [] in_buf;
    <span style="font-weight: bold;">delete</span> [] out_buf;
    <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: work</p>
<p class="date">Created: 2019-04-03 Wed 04:29</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://maypeppa.github.io/html/snappy.html';this.page.identifier = 'snappy.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
