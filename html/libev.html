<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-31377772-3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-31377772-3');</script>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>libev</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="work" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/htmlize.css"/><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/readtheorg.css"/><script src="https://ajax.loli.net/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script><script type="text/javascript" src="/themes/styles/lib/js/jquery.stickytableheaders.min.js"></script><script type="text/javascript" src="/themes/styles/readtheorg/js/readtheorg.js"></script></head>
<body>
<div id="content">
<h1 class="title">libev</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga8a0253">1. Overview</a></li>
<li><a href="#orgc470207">2. EventLoop</a></li>
<li><a href="#orgc96e59c">3. Watcher</a></li>
<li><a href="#orgba76327">4. How it works</a>
<ul>
<li><a href="#orgd92c621">4.1. ev<sub>run</sub></a></li>
<li><a href="#orge4c5e17">4.2. fd<sub>reify</sub></a></li>
<li><a href="#org02dc1fc">4.3. backend<sub>poll</sub></a></li>
<li><a href="#org09d49ca">4.4. timers<sub>reify</sub></a></li>
<li><a href="#org4835140">4.5. EV<sub>INVOKE</sub><sub>PENDING</sub></a></li>
</ul>
</li>
<li><a href="#orgcb7ab42">5. Example</a>
<ul>
<li><a href="#org58e5d7f">5.1. common.h</a></li>
<li><a href="#org9304df9">5.2. echo-client.cc</a></li>
<li><a href="#org20be3a9">5.3. echo-server.cc</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="http://software.schmorp.de/pkg/libev.html">http://software.schmorp.de/pkg/libev.html</a>
</p>

<div id="outline-container-orga8a0253" class="outline-2">
<h2 id="orga8a0253"><span class="section-number-2">1</span> Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
libev所实现的功能就是一个强大的reactor, 可以notify的事件主要包括下面这些：
</p>
<ul class="org-ul">
<li>ev<sub>io</sub> // IO可读可写</li>
<li>ev<sub>stat</sub> // 文件属性变化</li>
<li>ev<sub>async</sub> // 激活线程</li>
<li>ev<sub>signal</sub> // 信号处理</li>
<li>ev<sub>timer</sub> // 定时器</li>
<li>ev<sub>periodic</sub> // 周期任务</li>
<li>ev<sub>child</sub> // 子进程状态变化</li>
<li>ev<sub>fork</sub> // 开辟进程</li>
<li>ev<sub>cleanup</sub> // event loop退出触发事件</li>
<li>ev<sub>idle</sub> // 每次event loop空闲触发事件</li>
<li>ev<sub>embed</sub> // ???</li>
<li>ev<sub>prepare</sub> // 每次event loop之前事件</li>
<li>ev<sub>check</sub> // 每次event loop之后事件</li>
</ul>

<p>
代码风格相当严谨而且排版也非常工整，并且从域名看出作者是德国人。但是内部使用了大量的宏造成阅读代码并不是非常方便。
并且从代码角度分析，应该是一开始支持有一个默认的event<sub>loop,但是随着多核产生实际应用中可能会使用到多个event</sub><sub>loop</sub>,
猜想作者应该是为了方便的话使用了很多宏进行替换。允许使用多个event<sub>loop的宏是EV</sub><sub>MULTIPLICITY.比如下面这段代码</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">noinline</span>
ev_io_start (EV_P_ <span style="font-weight: bold; text-decoration: underline;">ev_io</span> *<span style="font-weight: bold; font-style: italic;">w</span>)
{
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = w-&gt;fd;

  <span style="font-weight: bold;">if</span> (expect_false (ev_is_active (w)))
    <span style="font-weight: bold;">return</span>;

  assert ((<span style="font-style: italic;">"libev: ev_io_start called with negative fd"</span>, fd &gt;= 0));
  assert ((<span style="font-style: italic;">"libev: ev_io_start called with illegal event mask"</span>, !(w-&gt;events &amp; ~(EV__IOFDSET | EV_READ | EV_WRITE))));

  EV_FREQUENT_CHECK;

  ev_start (EV_A_ (W)w, 1);
  array_needsize (ANFD, anfds, anfdmax, fd + 1, array_init_zero);
  wlist_add (&amp;anfds[fd].head, (<span style="font-weight: bold; text-decoration: underline;">WL</span>)w);

  fd_change (<span style="font-weight: bold; text-decoration: underline;">EV_A_</span> <span style="font-weight: bold; font-style: italic;">fd</span>, w-&gt;events &amp; EV__IOFDSET | EV_ANFD_REIFY);
  w-&gt;events &amp;= ~EV__IOFDSET;

  EV_FREQUENT_CHECK;
}
</pre>
</div>
<p>
初次阅读这个代码会觉得非常难懂。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">宏</th>
<th scope="col" class="org-left">说明</th>
<th scope="col" class="org-left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">EV<sub>P</sub></td>
<td class="org-left">event parameter</td>
<td class="org-left">struct ev<sub>loop</sub> *loop</td>
</tr>

<tr>
<td class="org-left">EV<sub>P</sub>_</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">EV<sub>P</sub>,</td>
</tr>

<tr>
<td class="org-left">EV<sub>A</sub></td>
<td class="org-left">event argument</td>
<td class="org-left">loop</td>
</tr>

<tr>
<td class="org-left">EV<sub>A</sub>_</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">EV<sub>A</sub>,</td>
</tr>
</tbody>
</table>
<p>
然后很多变量只要是ev<sub>loop成员的话都被封装成为了宏</sub>。比如代码里面的anfds,实际上的宏定义是
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">anfds</span> ((loop)-&gt;anfds)
</pre>
</div>
<p>
事实上一个ev<sub>loop里面的字段是相当多的</sub>，不过也很正常本身就是一个强大的reactor.但是这造成一个直接后果，
就是对于想要了解ev<sub>loop的全貌比较困难</sub>，所以想要彻底地了解libev也比较麻烦，所以我们只能够从应用层面来尝试了解它。
</p>
</div>
</div>

<div id="outline-container-orgc470207" class="outline-2">
<h2 id="orgc470207"><span class="section-number-2">2</span> EventLoop</h2>
<div class="outline-text-2" id="text-2">
<p>
首先我们关注一下reactor本身。在libev下面reactor对象称为event<sub>loop.event</sub><sub>loop允许动态创建和销毁</sub>，并且允许绑定自定义数据
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ev_loop</span> * <span style="font-weight: bold;">ev_loop_new</span> (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">flags</span>);
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ev_loop_destroy</span> (EV_P);
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ev_set_userdata</span> (EV_P_ <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">data</span>);
<span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold;">ev_userdata</span> (EV_P);
</pre>
</div>
<p>
我们这里主要关注一下flags.这里面主要是选择使用什么backend来进行poll操作，可以选择的有：
</p>
<ul class="org-ul">
<li>EVBACKEND<sub>SELECT</sub></li>
<li>EVBACKEND<sub>POLL</sub></li>
<li>EVBACKEND<sub>EPOLL</sub> // 通常我们选择这个</li>
<li>EVBACKEND<sub>KQUEUE</sub></li>
<li>EVBACKEND<sub>DEVPOLL</sub></li>
<li>EVBACKEND<sub>PORT</sub></li>
</ul>
<p>
但是还有三个比较重要选项：
</p>
<ul class="org-ul">
<li>EVFLAG<sub>NOINOTIFY</sub> // 不适用inofity调用来使用ev<sub>stat.这样可以减少fd使用</sub>。</li>
<li>EVFLAG<sub>SIGNALFD</sub> // 使用signalfd来检测信号是否发生，同样这样可以减少fd使用。</li>
</ul>
<p>
大部分时候我们使用EVFLAG<sub>AUTO</sub>(0)一般就足够满足需求了，从代码角度来看如果支持epoll的话那么首先会选择epoll.
因为在watcher的回调函数里面是可以知道当前event<sub>loop的</sub>，这样就可以获得自定义数据。然后我们看看这个event<sub>loop如何运行和停止的</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ev_run</span> (EV_P_ <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">flags</span>);
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ev_break</span> (EV_P_ <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">how</span>);
</pre>
</div>
<p>
同样我们这里比较关注flags和how这两个参数。flags有下面这几个：
</p>
<ul class="org-ul">
<li>0.默认值。一直循环进行处理，直到外部引用计数==0或者是显示退出。</li>
<li>EVRUN<sub>NOWAIT.运行一次</sub>，poll时候不会等待。如果有pending事件进行处理，否则立即返回。</li>
<li>EVRUN<sub>ONCE.运行一次</sub>，poll时候会等待至少一个event发生，处理完成之后返回。</li>
</ul>
<p>
而how有下面这几个：
</p>
<ul class="org-ul">
<li>EVBREAK<sub>ONE.只是退出一次ev</sub><sub>run这个调用</sub>。通常来说使用这个就可以了。</li>
<li>EVBREAK<sub>ALL.退出所有的ev</sub><sub>run调用</sub>。这种情况存在于ev<sub>run在pengding处理时候会递归调用</sub>。</li>
</ul>
<p>
在backend/epoll底层每次epoll<sub>wait时候</sub>，libev提供了接口回调可以在epoll<sub>wait前后调用</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ev_set_loop_release_cb</span> (loop, <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">release</span>)(EV_P), <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">acquire</span>)(EV_P))
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span>
<span style="font-weight: bold;">epoll_poll</span> (EV_P_ <span style="font-weight: bold; text-decoration: underline;">ev_tstamp</span> <span style="font-weight: bold; font-style: italic;">timeout</span>)
{
  <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">epoll wait times cannot be larger than (LONG_MAX - 999UL) / HZ msecs, which is below */</span>
  <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">the default libev max wait time, however. */</span>
  EV_RELEASE_CB;
  eventcnt = epoll_wait (backend_fd, epoll_events, epoll_eventmax,
                         epoll_epermcnt ? 0 : ev_timeout_to_ms (timeout));
  EV_ACQUIRE_CB;
}
</pre>
</div>
<p>
在event<sub>loop里面我们还关心一件事情</sub>，就是每次event<sub>loop轮询的时间长短</sub>。通常来说这个不会是太大问题，但是在高性能情况下面我们需要设置
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ev_set_io_collect_interval</span> (EV_P_ <span style="font-weight: bold; text-decoration: underline;">ev_tstamp</span> <span style="font-weight: bold; font-style: italic;">interval</span>);
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ev_set_timeout_collect_interval</span> (EV_P_ <span style="font-weight: bold; text-decoration: underline;">ev_tstamp</span> <span style="font-weight: bold; font-style: italic;">interval</span>);
</pre>
</div>
<p>
在ev<sub>run里面有使用这些参数的代码比较麻烦</sub>。但是大意是这样，如果我们这是了timeout<sub>interval的话</sub>，那么我们每次检查timeout时间的话必须
在timeout<sub>interval</sub>，使用这段时间ev<sub>sleep.但是这个又会影响到io</sub><sub>interval,所以内部做了一些换算</sub>，换算的结果作为epoll<sub>wait超时时间</sub>。
不过同样在大部分时候我们不需要关心它，默认时候是0.0,系统会使用最快的响应方式来处理。
</p>
</div>
</div>

<div id="outline-container-orgc96e59c" class="outline-2">
<h2 id="orgc96e59c"><span class="section-number-2">3</span> Watcher</h2>
<div class="outline-text-2" id="text-3">
<p>
然后我们关心一下EventHandler.在libev下面watcher相当于EventHandler这么一个概念，通常里面会绑定fd回调函数以及我们需要关注的事件。
然后一旦触发事件之后会触发我们使用的回调函数，回调函数参数通常有reactor,watcher以及触发的事件。这里不打算重复文档里面的watcher
相关的内容和对应的API,但是对于某些内容的话可能会提到并且附带一些注释。之前我们还是看看通用过程，这里使用TYPE区分不同类型watcher.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">void</span> (*)(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ev_loop</span> *<span style="font-weight: bold; font-style: italic;">loop</span>, <span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">revents</span>) callback; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">callback&#37117;&#26159;&#36825;&#31181;&#31867;&#22411;</span>
ev_init (<span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>, callback); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#21270;watcher</span>
ev_TYPE_set (<span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>, [<span style="font-weight: bold; text-decoration: underline;">args</span>]); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;watcher</span>
ev_TYPE_init (<span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>, callback, [<span style="font-weight: bold; text-decoration: underline;">args</span>]); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36890;&#24120;&#20351;&#29992;&#36825;&#20010;&#20989;&#25968;&#26368;&#26041;&#20415;&#65292;&#21021;&#22987;&#21270;&#21644;&#35774;&#32622;&#37117;&#22312;&#36825;&#37324;</span>
ev_TYPE_start (loop, <span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#20876;watcher</span>
ev_TYPE_stop (loop, <span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#38144;watcher</span>
ev_set_priority (<span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">priority</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;&#20248;&#20808;&#32423;</span>
ev_feed_event (loop, <span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">revents</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#20570;&#36328;&#32447;&#31243;&#36890;&#30693;&#38750;&#24120;&#26377;&#29992;&#65292;&#30456;&#24403;&#20110;&#35302;&#21457;&#20102;&#26576;&#20010;&#20107;&#20214;&#12290;</span>
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">ev_is_active</span> (<span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">watcher&#26159;&#21542;active.</span>
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">ev_is_pending</span> (<span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">watcher&#26159;&#21542;pending.</span>
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">ev_clear_pending</span> (loop, <span style="font-weight: bold; text-decoration: underline;">ev_TYPE</span> *<span style="font-weight: bold; font-style: italic;">watcher</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28165;&#38500;watcher pending&#29366;&#24577;&#24182;&#19988;&#36820;&#22238;&#20107;&#20214;</span>
</pre>
</div>
<p>
wacther的状态有下面这么几种：
</p>
<ul class="org-ul">
<li>initialiased.调用init函数初始化</li>
<li>active.调用start进行注册</li>
<li>pending.已经触发事件但是没有处理</li>
<li>inactive.调用stop注销。这个状态等同于initialised这个状态。</li>
</ul>
<p>
其实关于每个watcher具体是怎么实现的没有太多意思，因为大部分现有代码都差不多。会在下一节说说内部数据结构是怎么安排的，
了解内部数据结构以及过程之后很多问题就可以避免了，比如"The special problem of disappearing file descriptors"这类问题。
</p>
</div>
</div>

<div id="outline-container-orgba76327" class="outline-2">
<h2 id="orgba76327"><span class="section-number-2">4</span> How it works</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgd92c621" class="outline-3">
<h3 id="orgd92c621"><span class="section-number-3">4.1</span> ev<sub>run</sub></h3>
<div class="outline-text-3" id="text-4-1">
<p>
最主要的还是看看ev<sub>run这个部分代码</sub>。我们不打算仔细阅读只是看看梗概然后大体分析一下数据结构应该怎么样的
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span>
<span style="font-weight: bold;">ev_run</span> (EV_P_ <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">flags</span>)
{
  assert ((<span style="font-style: italic;">"libev: ev_loop recursion during release detected"</span>, loop_done != EVBREAK_RECURSE));

  loop_done = EVBREAK_CANCEL;

  EV_INVOKE_PENDING; <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">in case we recurse, ensure ordering stays nice and clean */</span>

  <span style="font-weight: bold;">do</span>
    {
      <span style="font-weight: bold;">if</span> (expect_false (loop_done))
        <span style="font-weight: bold;">break</span>;

      <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">update fd-related kernel structures */</span>
      fd_reify (EV_A);

      <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">calculate blocking time */</span>
      {
        <span style="font-weight: bold; text-decoration: underline;">ev_tstamp</span> <span style="font-weight: bold; font-style: italic;">waittime</span>  = 0.;
        <span style="font-weight: bold; text-decoration: underline;">ev_tstamp</span> <span style="font-weight: bold; font-style: italic;">sleeptime</span> = 0.;

        <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">remember old timestamp for io_blocktime calculation */</span>
        <span style="font-weight: bold; text-decoration: underline;">ev_tstamp</span> <span style="font-weight: bold; font-style: italic;">prev_mn_now</span> = mn_now;

        <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">update time to cancel out callback processing overhead */</span>
        time_update (EV_A_ 1e100);

        <span style="font-weight: bold;">if</span> (expect_true (!(flags &amp; EVRUN_NOWAIT || idleall || !activecnt)))
          {
            waittime = MAX_BLOCKTIME;

            <span style="font-weight: bold;">if</span> (timercnt)
              {
                <span style="font-weight: bold; text-decoration: underline;">ev_tstamp</span> <span style="font-weight: bold; font-style: italic;">to</span> = ANHE_at (timers [HEAP0]) - mn_now + backend_fudge;
                <span style="font-weight: bold;">if</span> (waittime &gt; to) waittime = to;
              }

            <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">don't let timeouts decrease the waittime below timeout_blocktime */</span>
            <span style="font-weight: bold;">if</span> (expect_false (waittime &lt; timeout_blocktime))
              waittime = timeout_blocktime;

            <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">extra check because io_blocktime is commonly 0 */</span>
            <span style="font-weight: bold;">if</span> (expect_false (io_blocktime))
              {
                sleeptime = io_blocktime - (mn_now - prev_mn_now);

                <span style="font-weight: bold;">if</span> (sleeptime &gt; waittime - backend_fudge)
                  sleeptime = waittime - backend_fudge;

                <span style="font-weight: bold;">if</span> (expect_true (sleeptime &gt; 0.))
                  {
                    ev_sleep (sleeptime);
                    waittime -= sleeptime;
                  }
              }
          }

        assert ((loop_done = EVBREAK_RECURSE, 1)); <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">assert for side effect */</span>
        backend_poll (<span style="font-weight: bold; text-decoration: underline;">EV_A_</span> <span style="font-weight: bold; font-style: italic;">waittime</span>);
        assert ((loop_done = EVBREAK_CANCEL, 1)); <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">assert for side effect */</span>

        <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">update ev_rt_now, do magic */</span>
        time_update (<span style="font-weight: bold; text-decoration: underline;">EV_A_</span> <span style="font-weight: bold; font-style: italic;">waittime</span> + sleeptime);
      }

      <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">queue pending timers and reschedule them */</span>
      timers_reify (EV_A); <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">relative timers called last */</span>

      EV_INVOKE_PENDING;
    }
  <span style="font-weight: bold;">while</span> (expect_true (
    <span style="font-weight: bold; text-decoration: underline;">activecnt</span>
    &amp;&amp; !loop_done
    &amp;&amp; !(flags &amp; (EVRUN_ONCE | EVRUN_NOWAIT))
  ));

  <span style="font-weight: bold;">if</span> (loop_done == EVBREAK_ONE)
    loop_done = EVBREAK_CANCEL;
}
</pre>
</div>
<p>
我们可以总结一下大致步骤，其实和大部分的event loop写出来差不多。
</p>
<ul class="org-ul">
<li>首先触发那些已经pending的watchers.</li>
<li>判断是否loop<sub>done</sub></li>
<li>fd<sub>reify.这个后面会单独说</sub>。</li>
<li>计算出waittime并且进行必要的sleep.</li>
<li>backend<sub>poll开始轮询,并且整理好pending事件</sub></li>
<li>timers<sub>reify.这个和fd</sub><sub>reify不同</sub></li>
<li>调用EV<sub>INVOKE</sub><sub>PENDING来触发pending的io事件</sub></li>
</ul>
<p>
非常简单。接下来我们看看fd<sub>reify,backend</sub><sub>poll,timers</sub><sub>reify以及EV</sub><sub>INVOKE</sub><sub>PENDING</sub>.
</p>
</div>
</div>

<div id="outline-container-orge4c5e17" class="outline-3">
<h3 id="orge4c5e17"><span class="section-number-3">4.2</span> fd<sub>reify</sub></h3>
<div class="outline-text-3" id="text-4-2">
<p>
下面是fd<sub>reify代码片段.可以看出</sub>，这个部分就是在修改fd关注的events。
</p>
<div class="org-src-container">
<pre class="src src-C++">inline_size <span style="font-weight: bold; text-decoration: underline;">void</span>
<span style="font-weight: bold;">fd_reify</span> (EV_P)
{
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span>;
  <span style="font-weight: bold;">for</span> (i = 0; i &lt; fdchangecnt; ++i)
    {
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = fdchanges [i];
      <span style="font-weight: bold; text-decoration: underline;">ANFD</span> *<span style="font-weight: bold; font-style: italic;">anfd</span> = anfds + fd;
      <span style="font-weight: bold; text-decoration: underline;">ev_io</span> *<span style="font-weight: bold; font-style: italic;">w</span>;

      <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">o_events</span> = anfd-&gt;events;
      <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">o_reify</span>  = anfd-&gt;reify;

      anfd-&gt;reify  = 0;

      <span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">if (expect_true (o_reify &amp; EV_ANFD_REIFY)) probably a deoptimisation */</span>
        {
          anfd-&gt;events = 0;

          <span style="font-weight: bold;">for</span> (w = (<span style="font-weight: bold; text-decoration: underline;">ev_io</span> *)anfd-&gt;head; w; w = (<span style="font-weight: bold; text-decoration: underline;">ev_io</span> *)((<span style="font-weight: bold; text-decoration: underline;">WL</span>)w)-&gt;next)
            anfd-&gt;events |= (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>)w-&gt;events;

          <span style="font-weight: bold;">if</span> (o_events != anfd-&gt;events)
            o_reify = EV__IOFDSET; <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">actually |= */</span>
        }

      <span style="font-weight: bold;">if</span> (o_reify &amp; EV__IOFDSET)
        backend_modify (<span style="font-weight: bold; text-decoration: underline;">EV_A_</span> <span style="font-weight: bold; font-style: italic;">fd</span>, o_events, anfd-&gt;events);
    }

  fdchangecnt = 0;
}
</pre>
</div>
<p>
而这个fdchanges这个是在哪里调用的呢。我们可以看到就是在ev<sub>io</sub><sub>start这个部分</sub>。也就是说如果我们想要修改
fd关注事件的话，我们必须显示地ev<sub>io</sub><sub>stop掉然后修正之后重新ev</sub><sub>io</sub><sub>start.底层调用fd</sub><sub>change的话底层维护</sub>
数组fdchanges来保存发生events变动的fd.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">noinline</span>
ev_io_start (EV_P_ <span style="font-weight: bold; text-decoration: underline;">ev_io</span> *<span style="font-weight: bold; font-style: italic;">w</span>)
{
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = w-&gt;fd;

  <span style="font-weight: bold;">if</span> (expect_false (ev_is_active (w)))
    <span style="font-weight: bold;">return</span>;

  assert ((<span style="font-style: italic;">"libev: ev_io_start called with negative fd"</span>, fd &gt;= 0));
  assert ((<span style="font-style: italic;">"libev: ev_io_start called with illegal event mask"</span>, !(w-&gt;events &amp; ~(EV__IOFDSET | EV_READ | EV_WRITE))));

  EV_FREQUENT_CHECK;

  ev_start (EV_A_ (W)w, 1);
  array_needsize (ANFD, anfds, anfdmax, fd + 1, array_init_zero);
  wlist_add (&amp;anfds[fd].head, (<span style="font-weight: bold; text-decoration: underline;">WL</span>)w);

  fd_change (<span style="font-weight: bold; text-decoration: underline;">EV_A_</span> <span style="font-weight: bold; font-style: italic;">fd</span>, w-&gt;events &amp; EV__IOFDSET | EV_ANFD_REIFY);
  w-&gt;events &amp;= ~EV__IOFDSET;

  EV_FREQUENT_CHECK;
}

inline_size <span style="font-weight: bold; text-decoration: underline;">void</span>
<span style="font-weight: bold;">fd_change</span> (EV_P_ <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">flags</span>)
{
  <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">reify</span> = anfds [fd].reify;
  anfds [fd].reify |= flags;

  <span style="font-weight: bold;">if</span> (expect_true (!reify))
    {
      ++fdchangecnt;
      array_needsize (<span style="font-weight: bold; text-decoration: underline;">int</span>, fdchanges, fdchangemax, fdchangecnt, EMPTY2);
      fdchanges [fdchangecnt - 1] = fd;
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org02dc1fc" class="outline-3">
<h3 id="org02dc1fc"><span class="section-number-3">4.3</span> backend<sub>poll</sub></h3>
<div class="outline-text-3" id="text-4-3">
<p>
backend<sub>poll底层支持很多poll实现</sub>，我们这里仅仅看ev<sub>epoll.c就可以.代码在这里面我们不列举了</sub>，
如果某个fd触发事件的话那么最终会调用fd<sub>event</sub>(EV<sub>A</sub><sub>,fd,event</sub>)来进行通知。所以我们看看fd<sub>event</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++">inline_speed <span style="font-weight: bold; text-decoration: underline;">void</span>
<span style="font-weight: bold;">fd_event_nocheck</span> (EV_P_ <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">revents</span>)
{
  <span style="font-weight: bold; text-decoration: underline;">ANFD</span> *<span style="font-weight: bold; font-style: italic;">anfd</span> = anfds + fd;
  <span style="font-weight: bold; text-decoration: underline;">ev_io</span> *<span style="font-weight: bold; font-style: italic;">w</span>;

  <span style="font-weight: bold;">for</span> (w = (<span style="font-weight: bold; text-decoration: underline;">ev_io</span> *)anfd-&gt;head; w; w = (<span style="font-weight: bold; text-decoration: underline;">ev_io</span> *)((<span style="font-weight: bold; text-decoration: underline;">WL</span>)w)-&gt;next)
    {
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">ev</span> = w-&gt;events &amp; revents;

      <span style="font-weight: bold;">if</span> (ev)
        ev_feed_event (EV_A_ (W)w, ev);
    }
}
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">noinline</span>
ev_feed_event (EV_P_ <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">w</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">revents</span>)
{
  <span style="font-weight: bold; text-decoration: underline;">W</span> <span style="font-weight: bold; font-style: italic;">w_</span> = (<span style="font-weight: bold; text-decoration: underline;">W</span>)w;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">pri</span> = ABSPRI (w_);

  <span style="font-weight: bold;">if</span> (expect_false (w_-&gt;pending))
    pendings [pri][w_-&gt;pending - 1].events |= revents;
  <span style="font-weight: bold;">else</span>
    {
      w_-&gt;pending = ++pendingcnt [pri];
      array_needsize (ANPENDING, pendings [pri], pendingmax [pri], w_-&gt;pending, EMPTY2);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">set the watcher and revents.</span>
      pendings [pri][w_-&gt;pending - 1].w      = w_;
      pendings [pri][w_-&gt;pending - 1].events = revents;
    }
}
</pre>
</div>
<p>
可以看到底层是一个ANFD的数组，根据fd进行偏移。如果fd过大的话似乎会影响性能没有hpserver里面的demuxtable实现方式好。
然后得到这个fd下面所有的watcher,然后在loop-&gt;pendings里面记录所有这些触发的watcher.
</p>
</div>
</div>

<div id="outline-container-org09d49ca" class="outline-3">
<h3 id="org09d49ca"><span class="section-number-3">4.4</span> timers<sub>reify</sub></h3>
<div class="outline-text-3" id="text-4-4">
<p>
其中HEAP0就是最小堆下标。如果repeat的话说明需要重复发生，那么就会重新调整时间戳，如果不是repeat的话，
那么内部会调用ev<sub>timer</sub><sub>stop这个方法将这个计时器移除</sub>。所有的定时任务都通过feed<sub>reverse添加</sub>。feed<sub>reverse</sub>
内部是维护一个动态数组来保存所有的定时器任务，然后在feed<sub>reverse</sub><sub>done里面遍历这些任务来触发这些定时器任务</sub>。
</p>
<div class="org-src-container">
<pre class="src src-C++">inline_size <span style="font-weight: bold; text-decoration: underline;">void</span>
<span style="font-weight: bold;">timers_reify</span> (EV_P)
{
  EV_FREQUENT_CHECK;

  <span style="font-weight: bold;">if</span> (timercnt &amp;&amp; ANHE_at (timers [HEAP0]) &lt; mn_now)
    {
      <span style="font-weight: bold;">do</span>
        {
          <span style="font-weight: bold; text-decoration: underline;">ev_timer</span> *<span style="font-weight: bold; font-style: italic;">w</span> = (<span style="font-weight: bold; text-decoration: underline;">ev_timer</span> *)ANHE_w (timers [HEAP0]);

          <span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">assert (("libev: inactive timer on timer heap detected", ev_is_active (w)));*/</span>

          <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">first reschedule or stop timer */</span>
          <span style="font-weight: bold;">if</span> (w-&gt;repeat)
            {
              ev_at (w) += w-&gt;repeat;
              <span style="font-weight: bold;">if</span> (ev_at (w) &lt; mn_now)
                ev_at (w) = mn_now;

              assert ((<span style="font-style: italic;">"libev: negative ev_timer repeat value found while processing timers"</span>, w-&gt;repeat &gt; 0.));

              ANHE_at_cache (timers [HEAP0]);
              downheap (timers, timercnt, HEAP0);
            }
          <span style="font-weight: bold;">else</span>
            ev_timer_stop (<span style="font-weight: bold; text-decoration: underline;">EV_A_</span> <span style="font-weight: bold; font-style: italic;">w</span>); <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">nonrepeating: stop timer */</span>

          EV_FREQUENT_CHECK;
          feed_reverse (EV_A_ (W)w);
        }
      <span style="font-weight: bold;">while</span> (timercnt &amp;&amp; ANHE_at (timers [HEAP0]) &lt; mn_now);

      feed_reverse_done (<span style="font-weight: bold; text-decoration: underline;">EV_A_</span> <span style="font-weight: bold; font-style: italic;">EV_TIMER</span>);
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4835140" class="outline-3">
<h3 id="org4835140"><span class="section-number-3">4.5</span> EV<sub>INVOKE</sub><sub>PENDING</sub></h3>
<div class="outline-text-3" id="text-4-5">
<p>
这个宏最终调用的函数就是下面这个，遍历所有的pendings事件并且逐一触发。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">noinline</span>
ev_invoke_pending (EV_P)
{
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">pri</span>;

  <span style="font-weight: bold;">for</span> (pri = NUMPRI; pri--; )
    <span style="font-weight: bold;">while</span> (pendingcnt [pri])
      {
        <span style="font-weight: bold; text-decoration: underline;">ANPENDING</span> *<span style="font-weight: bold; font-style: italic;">p</span> = pendings [pri] + --pendingcnt [pri];

        p-&gt;w-&gt;pending = 0;
        EV_CB_INVOKE (p-&gt;w, p-&gt;events);
        EV_FREQUENT_CHECK;
      }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcb7ab42" class="outline-2">
<h2 id="orgcb7ab42"><span class="section-number-2">5</span> Example</h2>
<div class="outline-text-2" id="text-5">
<p>
尝试编写一个简单的带有超时的echo-server和echo-client就发现其实还有非常多的其他的工作量，比如buffer的管理状态机实现等。
所以我没有写出一个完整的example,只是简单地写了假设echo-client连接上server的话就简单地打印链接信息并且关闭。
</p>
</div>
<div id="outline-container-org58e5d7f" class="outline-3">
<h3 id="org58e5d7f"><span class="section-number-3">5.1</span> common.h</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#if</span><span style="font-weight: bold;">n</span><span style="font-weight: bold;">def</span> _COMMON_H_
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">_COMMON_H_</span>

<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;unistd.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;fcntl.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;sys/types.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;sys/socket.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;arpa/inet.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;strings.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;cstdlib&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;cstdio&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;cstddef&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;string&gt;</span>

<span style="font-weight: bold;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">common</span>{

<span style="font-weight: bold;">#define</span> <span style="font-weight: bold;">D</span>(<span style="font-weight: bold; font-style: italic;">exp</span>,<span style="font-weight: bold; font-style: italic;">fmt</span>,...) <span style="font-weight: bold;">do</span> {                     \
        <span style="font-weight: bold;">if</span>(!(exp)){                             \
            fprintf(stderr,fmt,##__VA_ARGS__);  \
            abort();                            \
        }                                       \
    }<span style="font-weight: bold;">while</span>(0)

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">setnonblock</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>){
    fcntl(fd,F_SETFL,fcntl(fd,F_GETFL) | O_NONBLOCK);
}
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">setreuseaddr</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>){
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">ok</span>=1;
    setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,&amp;ok,<span style="font-weight: bold;">sizeof</span>(ok));
}

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">setaddress</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ip</span>,<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">port</span>,<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">sockaddr_in</span>* <span style="font-weight: bold; font-style: italic;">addr</span>){
    bzero(addr,<span style="font-weight: bold;">sizeof</span>(*addr));
    addr-&gt;sin_family=AF_INET;
    inet_pton(AF_INET,ip,&amp;(addr-&gt;sin_addr));
    addr-&gt;sin_port=htons(port);
}

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold;">address_to_string</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">sockaddr_in</span>* <span style="font-weight: bold; font-style: italic;">addr</span>){
    <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">ip</span>[128];
    inet_ntop(AF_INET,&amp;(addr-&gt;sin_addr),ip,<span style="font-weight: bold;">sizeof</span>(ip));
    <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">port</span>[32];
    snprintf(port,<span style="font-weight: bold;">sizeof</span>(port),<span style="font-style: italic;">"%d"</span>,ntohs(addr-&gt;sin_port));
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">r</span>;
    r=r+<span style="font-style: italic;">"("</span>+ip+<span style="font-style: italic;">":"</span>+port+<span style="font-style: italic;">")"</span>;
    <span style="font-weight: bold;">return</span> r;
}

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">new_tcp_server</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">port</span>){
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
    D(fd&gt;0,<span style="font-style: italic;">"socket failed(%m)\n"</span>);
    setnonblock(fd);
    setreuseaddr(fd);
    <span style="font-weight: bold; text-decoration: underline;">sockaddr_in</span> <span style="font-weight: bold; font-style: italic;">addr</span>;
    setaddress(<span style="font-style: italic;">"0.0.0.0"</span>,port,&amp;addr);
    bind(fd,(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">sockaddr</span>*)&amp;addr,<span style="font-weight: bold;">sizeof</span>(addr));
    listen(fd,64); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">backlog = 64</span>
    <span style="font-weight: bold;">return</span> fd;
}

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">new_tcp_client</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ip</span>,<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">port</span>){
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
    setnonblock(fd);
    <span style="font-weight: bold; text-decoration: underline;">sockaddr_in</span> <span style="font-weight: bold; font-style: italic;">addr</span>;
    setaddress(ip,port,&amp;addr);
    connect(fd,(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">sockaddr</span>*)(&amp;addr),<span style="font-weight: bold;">sizeof</span>(addr));
    <span style="font-weight: bold;">return</span> fd;
}

}; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">namespace common</span>

<span style="font-weight: bold;">#endif</span> <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">_COMMON_H_</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9304df9" class="outline-3">
<h3 id="org9304df9"><span class="section-number-3">5.2</span> echo-client.cc</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">
<pre class="src src-C++">
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"ev.h"</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"common.h"</span>

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">do_connected</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ev_loop</span>* <span style="font-weight: bold; font-style: italic;">reactor</span>,<span style="font-weight: bold; text-decoration: underline;">ev_io</span>* <span style="font-weight: bold; font-style: italic;">w</span>,<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">events</span>){
    close(w-&gt;fd);
    ev_break(reactor,EVBREAK_ALL);
}

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(){
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ev_loop</span>* <span style="font-weight: bold; font-style: italic;">reactor</span>=ev_loop_new(EVFLAG_AUTO);
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>=<span style="font-weight: bold; text-decoration: underline;">common</span>::new_tcp_client(<span style="font-style: italic;">"127.0.0.1"</span>,34567);
    <span style="font-weight: bold; text-decoration: underline;">ev_io</span> <span style="font-weight: bold; font-style: italic;">io</span>;
    ev_io_init(&amp;io,&amp;do_connected,fd,EV_WRITE);
    ev_io_start(reactor,&amp;io);
    ev_run(reactor,0);
    close(fd);
    ev_loop_destroy(reactor);
    <span style="font-weight: bold;">return</span> 0;
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org20be3a9" class="outline-3">
<h3 id="org20be3a9"><span class="section-number-3">5.3</span> echo-server.cc</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<pre class="src src-C++">
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"ev.h"</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">"common.h"</span>

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">do_accept</span>(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ev_loop</span>* <span style="font-weight: bold; font-style: italic;">reactor</span>,<span style="font-weight: bold; text-decoration: underline;">ev_io</span>* <span style="font-weight: bold; font-style: italic;">w</span>,<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">events</span>){
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">sockaddr_in</span> <span style="font-weight: bold; font-style: italic;">addr</span>;
    <span style="font-weight: bold; text-decoration: underline;">socklen_t</span> <span style="font-weight: bold; font-style: italic;">addr_size</span>=<span style="font-weight: bold;">sizeof</span>(addr);
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">conn</span>=accept(w-&gt;fd,(<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">sockaddr</span>*)&amp;addr,&amp;addr_size);
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">r</span>=<span style="font-weight: bold; text-decoration: underline;">common</span>::address_to_string(&amp;addr);
    fprintf(stderr,<span style="font-style: italic;">"accept %s\n"</span>,r.c_str());
    close(conn);
}

<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>(){
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ev_loop</span>* <span style="font-weight: bold; font-style: italic;">reactor</span>=ev_loop_new(EVFLAG_AUTO);
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>=<span style="font-weight: bold; text-decoration: underline;">common</span>::new_tcp_server(34567);
    <span style="font-weight: bold; text-decoration: underline;">ev_io</span> <span style="font-weight: bold; font-style: italic;">w</span>;
    ev_io_init(&amp;w,do_accept,fd,EV_READ);
    ev_io_start(reactor,&amp;w);
    ev_run(reactor,0);
    close(fd);
    ev_loop_destroy(reactor);
}

</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: work</p>
<p class="date">Created: 2019-04-03 Wed 04:57</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://maypeppa.github.io/html/libev.html';this.page.identifier = 'libev.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://cdnjs.cloudflare.com/ajax/libs/embed-js/4.2.1/embed.min.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
