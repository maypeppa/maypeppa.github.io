<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-31377772-3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-31377772-3');</script>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>leveldb</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="work" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/htmlize.css"/><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/readtheorg.css"/><script src="https://ajax.loli.net/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://cdn.bootcss.com/bootstrap/3.3.4/js/bootstrap.min.js"></script><script type="text/javascript" src="/themes/styles/lib/js/jquery.stickytableheaders.min.js"></script><script type="text/javascript" src="/themes/styles/readtheorg/js/readtheorg.js"></script></head>
<body>
<div id="content">
<h1 class="title">leveldb</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9492f99">1. Introduction</a></li>
<li><a href="#orge0e3642">2. WriteBatch</a></li>
<li><a href="#org0a8652d">3. BloomFilter</a>
<ul>
<li><a href="#org1bd700b">3.1. Format</a></li>
<li><a href="#org467b2d7">3.2. FilterBlockBuilder</a></li>
<li><a href="#org3d7ea33">3.3. FilterBlockReader</a></li>
</ul>
</li>
<li><a href="#org7138e3a">4. Storage</a>
<ul>
<li><a href="#orga8d659e">4.1. MemTable</a></li>
<li><a href="#orgdc9d1d9">4.2. RedoLog</a></li>
<li><a href="#org8527e0d">4.3. DiskTable</a></li>
</ul>
</li>
<li><a href="#orgafa40cd">5. Compaction</a></li>
<li><a href="#orgfe89b34">6. Recovery</a></li>
<li><a href="#org5baaa8c">7. Snapshot</a></li>
<li><a href="#org9bdbe37">8. Cache</a></li>
<li><a href="#org0b6d4f6">9. Option</a></li>
<li><a href="#orge85319e">10. ReadingCode</a>
<ul>
<li><a href="#orgcc08411">10.1. Interface</a>
<ul>
<li><a href="#org3fc8cab">10.1.1. cache.h</a></li>
<li><a href="#orgc547209">10.1.2. comparator.h</a></li>
<li><a href="#org54886eb">10.1.3. db.h</a></li>
<li><a href="#org014ca3b">10.1.4. env.h</a></li>
<li><a href="#org451ecfe">10.1.5. filter<sub>policy.h</sub></a></li>
<li><a href="#orgb0f2806">10.1.6. iterator.h</a></li>
<li><a href="#org2d86b14">10.1.7. options.h</a></li>
<li><a href="#org93a7e60">10.1.8. slice.h</a></li>
<li><a href="#orga37f1a5">10.1.9. status.h</a></li>
<li><a href="#org80dc918">10.1.10. table<sub>builder.h</sub></a></li>
<li><a href="#org5658088">10.1.11. table.h</a></li>
<li><a href="#org77bd8b5">10.1.12. write<sub>batch.h</sub></a></li>
</ul>
</li>
<li><a href="#org3469978">10.2. Implementation</a></li>
<li><a href="#orgea91e76">10.3. DB</a>
<ul>
<li><a href="#orgd90d397">10.3.1. FileName</a></li>
<li><a href="#orgdcef09e">10.3.2. Config</a></li>
<li><a href="#org0d56679">10.3.3. DBImpl</a></li>
<li><a href="#org43456bc">10.3.4. DBIter</a></li>
<li><a href="#orgfa858ad">10.3.5. LookupKey</a></li>
<li><a href="#org340d037">10.3.6. ValueType</a></li>
<li><a href="#org8df6043">10.3.7. SequenceNumber</a></li>
<li><a href="#orgf9dcd9d">10.3.8. InternalKey</a></li>
<li><a href="#org9925010">10.3.9. InternalKeyComparator</a></li>
<li><a href="#org36e14db">10.3.10. FileMetaData</a></li>
<li><a href="#orga188df5">10.3.11. Version</a></li>
<li><a href="#org394f8a1">10.3.12. VersionSet</a></li>
<li><a href="#org35cb214">10.3.13. VersionSetBuilder</a></li>
<li><a href="#orgcd100b2">10.3.14. Compaction</a></li>
<li><a href="#org4b69d84">10.3.15. CompactionState</a></li>
<li><a href="#org7f99d7e">10.3.16. VersionEdit</a></li>
<li><a href="#orgca70630">10.3.17. ByteWiseComparatorImpl</a></li>
<li><a href="#org2b79be4">10.3.18. SnapshotImpl</a></li>
</ul>
</li>
<li><a href="#orgcecbafd">10.4. Posix</a>
<ul>
<li><a href="#org3795cc2">10.4.1. PosixEnv</a></li>
<li><a href="#orgffaaa64">10.4.2. PosixFileLock</a></li>
<li><a href="#orged86c78">10.4.3. PosixLogger</a></li>
<li><a href="#org1b52769">10.4.4. PosixRandomAccessFile</a></li>
<li><a href="#org1469338">10.4.5. PosixSequentialFile</a></li>
<li><a href="#orgf9a808c">10.4.6. PosixMmapFile</a></li>
</ul>
</li>
<li><a href="#org792448f">10.5. Cache</a>
<ul>
<li><a href="#orga1266be">10.5.1. ShardedLRUCache</a></li>
<li><a href="#orgf531f9d">10.5.2. LRUCache</a></li>
<li><a href="#org6968e56">10.5.3. LRUHandle</a></li>
<li><a href="#org039f443">10.5.4. HandleTable</a></li>
</ul>
</li>
<li><a href="#orgf5a1157">10.6. Batch</a>
<ul>
<li><a href="#org9ddf9ec">10.6.1. WriteBatch</a></li>
<li><a href="#org2ff2f8f">10.6.2. MemTable</a></li>
<li><a href="#org2a52f7b">10.6.3. MemTableInserter</a></li>
<li><a href="#org24cd068">10.6.4. MemtableIterator</a></li>
</ul>
</li>
<li><a href="#org793814e">10.7. Log</a>
<ul>
<li><a href="#org822af64">10.7.1. LogFormat</a></li>
<li><a href="#org914ad08">10.7.2. LogWriter</a></li>
<li><a href="#org06a49f4">10.7.3. LogReader</a></li>
</ul>
</li>
<li><a href="#org2c95e77">10.8. Table</a>
<ul>
<li><a href="#org4e49a78">10.8.1. TableFormat</a></li>
<li><a href="#orgfb5cfdb">10.8.2. BuildTable</a></li>
<li><a href="#orgd0e2d95">10.8.3. TableCache</a></li>
<li><a href="#org1bfe238">10.8.4. Table</a></li>
<li><a href="#org72ae76b">10.8.5. TableBuilder</a></li>
<li><a href="#org9ac07d9">10.8.6. BlockBuilder</a></li>
<li><a href="#orgb05a4a3">10.8.7. Block</a></li>
<li><a href="#org57805aa">10.8.8. BlockIterator</a></li>
<li><a href="#org652ba3a">10.8.9. BlockHandle</a></li>
<li><a href="#org075757a">10.8.10. Footer</a></li>
<li><a href="#orgf8918cf">10.8.11. ReadBlock</a></li>
<li><a href="#orgfeeea7a">10.8.12. IteratorWrapper</a></li>
<li><a href="#orge382ed4">10.8.13. EmptyIterator</a></li>
<li><a href="#org8101eed">10.8.14. TwoLevelIterator</a></li>
<li><a href="#org8cf7a1f">10.8.15. MergingIterator</a></li>
</ul>
</li>
<li><a href="#orgabeacab">10.9. Util</a>
<ul>
<li><a href="#org5bfde69">10.9.1. Arena</a></li>
<li><a href="#orgb5bd0ee">10.9.2. Coding</a></li>
<li><a href="#orgfc69fbf">10.9.3. Histogram</a></li>
<li><a href="#orgeeca770">10.9.4. SkipList</a></li>
<li><a href="#org66976a8">10.9.5. AtomicPointer</a></li>
<li><a href="#org2579f5a">10.9.6. CRC32C</a></li>
<li><a href="#org537fb65">10.9.7. Hash</a></li>
<li><a href="#orgda45575">10.9.8. BloomFilterPolicy</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge36dd1c">11. Discussion</a>
<ul>
<li><a href="#orgbbe4d71">11.1. leveldb通过iterator遍历，对于相同的key如何保证获取到最新的值（hpplinux)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="http://code.google.com/p/leveldb/">http://code.google.com/p/leveldb/</a>
</p>

<div id="outline-container-org9492f99" class="outline-2">
<h2 id="org9492f99"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
相关资源：
</p>
<ul class="org-ul">
<li>使用文档. <a href="http://leveldb.googlecode.com/svn/trunk/doc/index.html">http://leveldb.googlecode.com/svn/trunk/doc/index.html</a></li>
<li>设计说明. <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a></li>
<li>leveldb和baidu内部kv系统对比. <a href="http://hi.baidu.com/little_fxxker/blog/item/1915f300f7548a046b60fb08.html">http://hi.baidu.com/little_fxxker/blog/item/1915f300f7548a046b60fb08.html</a></li>
<li><a href="http://blog.csdn.net/anderscloud/article/details/7182165">http://blog.csdn.net/anderscloud/article/details/7182165</a></li>
</ul>

<p>
leveldb是一个kv存储系统，其中kv都是二进制。用户接口非常简单就是Put(k,v),Get(k),Delete(k).但是还有以下特性
</p>
<ul class="org-ul">
<li>k有序存储.因为k是二进制没有解释的所以用户需要提供比较函数</li>
<li>支持遍历包括前向和反向</li>
<li>支持atomic write</li>
<li>支持filter policy(bloomfilter)</li>
<li>数据支持自动压缩(使用snappy压缩算法.关于snappy分析可以看<a href="snappy.html">这里</a>)</li>
<li>底层提供了抽象接口，允许用户定制</li>
</ul>
<p>
当然也存在一定的限制
</p>
<ul class="org-ul">
<li>不是SQL数据库，没有数据关系模型</li>
<li>一个table只允许一个process访问</li>
<li>单机系统没有client-server.</li>
</ul>

<p>
目录层次划分是这样的(意图是我猜想的)
</p>
<ul class="org-ul">
<li>db // 和db逻辑相关的内容</li>
<li>helpers // 里面有一个内存db接口</li>
<li>include // Interface</li>
<li>port // 操作系统相关的移植接口</li>
<li>table // 表存储结构</li>
<li>util // 公用部分.</li>
</ul>

<p>
leveldb还是比较麻烦的.开始阅读的时候(像我)很多策略细节就可以直接忽略.比如什么时候触发compaction的,以及挑选什么层次进行compaction的输出,
选择那些文件进行compaction等.阅读的时候需要了解每个类到底是用来做什么的.个人觉得里面最迷惑的东西就是Version/VersionEdit/VersionSet是用来做什么的.
所谓Version就是做一个compaction时候产生的一个对象.VersionSet是当前DB里面所有的Version.VersionEdit是针对Version的修改.包括添加和删除哪些文件等.
每次compaction时候会产生version表示这个哪些文件是需要的.在回收文件的时候会查看每一个version持有的文件,这样就可以确定哪些文件是不需要的了.
每次进行compaction都会产生这么一个version对象.将对version进行的操作称为version<sub>edit.同时会将这个version</sub><sub>edit写入manifest文件里面去</sub>.
这样在恢复DB的时候，首先可以从manifest里面读取到挂掉之前的version是怎么样的.然后通过读取剩余的version<sub>edit得到挂掉之前的version</sub>.
同时会读取log文件将挂掉之前操作的kv恢复.
</p>

<p>
#note: 最近看到一篇文章比较leveldb和mysql存储引擎性能(可能是innodb).里面提到了连续插入性能的抖动很大.这可能
和底层为了达到读取高效率不断地进行compaction有关的.关于compaction挑选以及触发这个策略的话以后可以好好研究一下.
</p>

<p>
#note: compaction策略没有仔细分析，但是这个部分是精髓。如何控制compaction策略来针对应用达到最好的读写平衡。另外对于Recovery部分没有仔细看代码，
但是我觉得这个部分倒不是很大的问题，可能学到的东西不多但是需要非常仔细地阅读才行。
</p>
</div>
</div>

<div id="outline-container-orge0e3642" class="outline-2">
<h2 id="orge0e3642"><span class="section-number-2">2</span> WriteBatch</h2>
<div class="outline-text-2" id="text-2">
<p>
leveldb使用WriteBatch来达到atomic write操作.WriteBatch过程非常简单，就是将atomic write的内容全部写到一个内存buffer上，然后提交这个WriteBatch.
至于具体的分析可以查看"Code Analysis/Batch/WriteBatch"这节的分析。使用WriteBatch一方面可以做到原子操作，另外一方面可以提高吞吐。
</p>
</div>
</div>

<div id="outline-container-org0a8652d" class="outline-2">
<h2 id="org0a8652d"><span class="section-number-2">3</span> BloomFilter</h2>
<div class="outline-text-2" id="text-3">
<p>
相关资源：
</p>
<ul class="org-ul">
<li>Bloom Filter. <a href="http://en.wikipedia.org/wiki/Bloom_filter">http://en.wikipedia.org/wiki/Bloom_filter</a></li>
<li>LevelDB Bloom Filter实现. <a href="http://duanple.blog.163.com/blog/static/7097176720123227403134/">http://duanple.blog.163.com/blog/static/7097176720123227403134/</a></li>
</ul>

<p>
bloom filter原理非常简单，似乎没有必要详细分析。关于代码部分的话可以看Code Analysis/Util/BloomFilter.
至于filter在磁盘上面是如何存储的可以参看下面一节Storage/DiskTable分析。
</p>

<p>
meta block存放了bloom filter信息，这样可以减少磁盘读取。关于Table内部支持bloom filter在table/filter<sub>block.h有实现</sub>。
分别是FilterBlockBuilder和FilterBlockReader.
</p>
</div>

<div id="outline-container-org1bd700b" class="outline-3">
<h3 id="org1bd700b"><span class="section-number-3">3.1</span> Format</h3>
<div class="outline-text-3" id="text-3-1">
<p>
leveldb是这么分配filter block的.以base(2KB)计算.如果block offset在[base*i,base*(i+1)-1]之间的话，那么就在filter i上面。存储格式是这样的。
</p>
<pre class="example">
[filter 0]
[filter 1]
[filter 2]
...
[filter N-1]
[offset of filter 0]                  : 4 bytes
[offset of filter 1]                  : 4 bytes
[offset of filter 2]                  : 4 bytes
...
[offset of filter N-1]                : 4 bytes
[offset of beginning of offset array] : 4 bytes
lg(base)                              : 1 byte
</pre>
<p>
那么这个就是一个filter block的格式。filter block存放在meta block里面。在meta index block内部会记录key,filter block handle.其中key就是这个filter的名字,handle就是这个filter block offset.看看下面代码会更容易理解。
</p>
</div>
</div>

<div id="outline-container-org467b2d7" class="outline-3">
<h3 id="org467b2d7"><span class="section-number-3">3.2</span> FilterBlockBuilder</h3>
<div class="outline-text-3" id="text-3-2">
<p>
对于Table在初始化之前会调用StartBlock.并且在每次进行Flush Data Block时候也会根据Data Block offset调用。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">FilterBlockBuilder</span>::<span style="font-weight: bold;">StartBlock</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">block_offset</span>) {
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">filter_index</span> = (block_offset / kFilterBase);
  assert(filter_index &gt;= filter_offsets_.size());
  <span style="font-weight: bold;">while</span> (filter_index &gt; filter_offsets_.size()) {
    GenerateFilter();
  }
}
</pre>
</div>
<p>
可以看到两个data block offset跨越超过base的话那么会产生几个empty filter.但是默认实现的话empty filter不占用太多空间。
</p>

<p>
然后每次Table在AddKey时候也会调用FilterBlock::AddKey
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">FilterBlockBuilder</span>::<span style="font-weight: bold;">AddKey</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">k</span> = key;
  start_.push_back(keys_.size());
  keys_.append(k.data(), k.size());
}
</pre>
</div>
<p>
注意这里keys<sub>是一个string.start</sub><sub>记录每个新增key的偏移</sub>。AddKey是将这段时间内添加的Key全部缓存下来。
</p>

<p>
然后每次Flush的时候都会产生filter.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">FilterBlockBuilder</span>::<span style="font-weight: bold;">GenerateFilter</span>() {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">num_keys</span> = start_.size();
  <span style="font-weight: bold;">if</span> (num_keys == 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fast path if there are no keys for this filter</span>
    filter_offsets_.push_back(result_.size());
    <span style="font-weight: bold;">return</span>;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Make list of keys from flattened key structure</span>
  start_.push_back(keys_.size());  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Simplify length computation</span>
  tmp_keys_.resize(num_keys);
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; num_keys; i++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">base</span> = keys_.data() + start_[i];
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">length</span> = start_[i+1] - start_[i];
    tmp_keys_[i] = Slice(base, length);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Generate filter for current set of keys and append to result_.</span>
  filter_offsets_.push_back(result_.size()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35760;&#24405;&#27599;&#20010;filter&#30340;&#20559;&#31227;.</span>
  policy_-&gt;CreateFilter(&amp;tmp_keys_[0], num_keys, &amp;result_);

  tmp_keys_.clear();
  keys_.clear();
  start_.clear();
}
</pre>
</div>

<p>
最后filter block需要刷新出去调用Flush方法。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; text-decoration: underline;">FilterBlockBuilder</span>::<span style="font-weight: bold;">Finish</span>() {
  <span style="font-weight: bold;">if</span> (!start_.empty()) {
    GenerateFilter();
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Append array of per-filter offsets</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">array_offset</span> = result_.size();
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; filter_offsets_.size(); i++) {
    PutFixed32(&amp;result_, filter_offsets_[i]); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#20351;&#29992;Fixed32&#34920;&#31034;&#20063;&#38750;&#24120;&#22909;&#29702;&#35299;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#26679;&#25165;&#33021;&#24555;&#36895;&#22320;&#26144;&#23556;&#21040;&#23545;&#24212;&#30340;filter&#19978;&#38754;&#12290;</span>
  }

  PutFixed32(&amp;result_, array_offset); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;array offset&#34920;&#31034;filter offset&#30340;&#36215;&#22987;&#22320;&#22336;</span>
  result_.push_back(kFilterBaseLg);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Save encoding parameter in result</span>
  <span style="font-weight: bold;">return</span> Slice(result_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;slice&#23601;&#26159;&#26368;&#32456;&#38656;&#35201;write&#30340;&#25968;&#25454;.</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d7ea33" class="outline-3">
<h3 id="org3d7ea33"><span class="section-number-3">3.3</span> FilterBlockReader</h3>
<div class="outline-text-3" id="text-3-3">
<p>
了解上面的filter block的存储格式之后Reader就非常简单。构造函数首先计算出各个参数。simple huh?
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">FilterBlockReader</span>::<span style="font-weight: bold;">FilterBlockReader</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FilterPolicy</span>* <span style="font-weight: bold; font-style: italic;">policy</span>,
                                     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">contents</span>)
    : policy_(policy),
      data_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      offset_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      num_(0),
      base_lg_(0) {
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span> = contents.size();
  <span style="font-weight: bold;">if</span> (n &lt; 5) <span style="font-weight: bold;">return</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1 byte for base_lg_ and 4 for start of offset array</span>
  base_lg_ = contents[n-1];
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">last_word</span> = DecodeFixed32(contents.data() + n - 5);
  <span style="font-weight: bold;">if</span> (last_word &gt; n - 5) <span style="font-weight: bold;">return</span>;
  data_ = contents.data();
  offset_ = data_ + last_word;
  num_ = (n - 5 - last_word) / 4;
}
</pre>
</div>

<p>
阅读完成后面的Storage一节之后就会发现query key的话首先是在data index block找到这个key所在的data block offset的。
所以这里filter就是判断某个offset的data block是否含所有key.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">FilterBlockReader</span>::<span style="font-weight: bold;">KeyMayMatch</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">block_offset</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">index</span> = block_offset &gt;&gt; base_lg_;
  <span style="font-weight: bold;">if</span> (index &lt; num_) {
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">start</span> = DecodeFixed32(offset_ + index*4); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">filter&#36215;&#22987;&#22320;&#22336;</span>
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">limit</span> = DecodeFixed32(offset_ + index*4 + 4); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">filter&#32456;&#27490;&#22320;&#22336;</span>
    <span style="font-weight: bold;">if</span> (start &lt;= limit &amp;&amp; limit &lt;= (offset_ - data_)) {
      <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">filter</span> = Slice(data_ + start, limit - start);
      <span style="font-weight: bold;">return</span> policy_-&gt;KeyMayMatch(key, filter); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">filter&#21028;&#26029;&#26159;&#21542;&#23384;&#22312;key.</span>
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (start == limit) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Empty filters do not match any keys</span>
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
    }
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Errors are treated as potential matches</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7138e3a" class="outline-2">
<h2 id="org7138e3a"><span class="section-number-2">4</span> Storage</h2>
<div class="outline-text-2" id="text-4">
<p>
相关资源：
</p>
<ul class="org-ul">
<li>Table Format. <a href="http://leveldb.googlecode.com/svn/trunk/doc/table_format.txt">http://leveldb.googlecode.com/svn/trunk/doc/table_format.txt</a> sst table存储格式。</li>
<li>Log Format. <a href="http://leveldb.googlecode.com/svn/trunk/doc/log_format.txt">http://leveldb.googlecode.com/svn/trunk/doc/log_format.txt</a> block存储格式。</li>
<li>LevelDB SSTable格式详解. <a href="http://wenku.baidu.com/view/19f83f51be23482fb4da4c29.html">http://wenku.baidu.com/view/19f83f51be23482fb4da4c29.html</a></li>
</ul>
</div>

<div id="outline-container-orga8d659e" class="outline-3">
<h3 id="orga8d659e"><span class="section-number-3">4.1</span> MemTable</h3>
<div class="outline-text-3" id="text-4-1">
<p>
memtable在leveldb内部实现就是一个skiplist.所有的update都不是in-place的，对于memtable里面的修改来说的话使用的也是使用添加的方式完成的。
对于每个操作都会分配一个sequence number.所以底层也没有办法直接覆盖。对于sequence number很明显就是需要实现snapshot.底层的话leveldb
持有两个memtable,一个memtable用于接收当前的操作是mutable的，一个memtable是immutable专门用于dump to disk的，内部实现类似于双buffer机制。
</p>
</div>
</div>

<div id="outline-container-orgdc9d1d9" class="outline-3">
<h3 id="orgdc9d1d9"><span class="section-number-3">4.2</span> RedoLog</h3>
<div class="outline-text-3" id="text-4-2">
<p>
我们首先阅读Log Format文档看看log存储格式(leveldb采用redo-log来记日志)。每个block都划分成为32KB，里面可能会存在很多条记录，
对于跨块的记录来说的里面存在type字段用来标记这个块是否已经结束。另外值得注意的就是每个记录之前带上了32bit的checksum.对于每条记录多4字节还是很大开销的，
但是其实这也反应了leveldb的定位，就是针对fault-tolerant的分布式系统设计。这些分布式系统架在commodity PC上面，磁盘可能很容易出现问题。
在文档最后作者也给给出了这种block存储方式(recordio)的利弊。
</p>
<pre class="example">
Some benefits over the recordio format:

(1) We do not need any heuristics for resyncing - just go to next
block boundary and scan.  If there is a corruption, skip to the next
block.  As a side-benefit, we do not get confused when part of the
contents of one log file are embedded as a record inside another log
file.

(2) Splitting at approximate boundaries (e.g., for mapreduce) is
simple: find the next block boundary and skip records until we
hit a FULL or FIRST record.

(3) We do not need extra buffering for large records.

Some downsides compared to recordio format:

(1) No packing of tiny records.  This could be fixed by adding a new
record type, so it is a shortcoming of the current implementation,
not necessarily the format.

(2) No compression.  Again, this could be fixed by adding new record types.
</pre>
<p>
pros有：
</p>
<ul class="org-ul">
<li>如果磁盘数据发生损坏的话，那么对于数据定位的话非常简单。如果这个block出现问题的话那么直接跳过这个block即可。</li>
<li>程序处理方面可以很容易地找到边界。</li>
<li>对于单条大数据处理的话我们不需要分配很大的内存来做buffer.</li>
</ul>
<p>
cons有：
</p>
<ul class="org-ul">
<li>没有针对小record进行优化，比如如果record足够小的话完全可以在length部分使用1个字节。</li>
<li>没有进行压缩。对于压缩率完全取决于实现。对于小数据来说的话压缩比可能不高，对于大数据来说比如超过32KB的话，</li>
</ul>
<p>
取决于是按照32KB单个block压缩呢(压缩率可能不高),还是先针对整体压缩(压缩率可能比较耗，但是却需要很大的buffer).
</p>
</div>
</div>

<div id="outline-container-org8527e0d" class="outline-3">
<h3 id="org8527e0d"><span class="section-number-3">4.3</span> DiskTable</h3>
<div class="outline-text-3" id="text-4-3">
<p>
然后可以看看Table Format文档关于table存储格式。table存储格式里面主要包括几个部分：
</p>
<ul class="org-ul">
<li>data block</li>
<li>meta block</li>
<li>meta index block</li>
<li>data index block</li>
<li>footer</li>
</ul>
<p>
footer部分是放在最末尾的，里面包含了data index block以及meta index block的偏移信息，读取table时候从末尾读取。
</p>

<p>
首先我们看看data block是如何组织的。对于DiskTable(TableBuilder)就是不断地Add(Key,Value).当缓存的数据达到一定大小之后，
就会调用Flush这样就形成了一个Block.对于一个Block内部而言的话，有个很重要的概念就是restart point.所谓restart point就是为了解决
前缀压缩的问题的，所谓的restart point就是基准key。假设我们顺序加入abcd,abce,abcf.我们以abcd为restart point的话，那么abce可以存储为
(3,e),abcf存储为(3,f).对于restart point采用全量存储，而对于之后的部分采用增量存储。一个restart block可能存在多个restart point,
将这些restart point在整个table offset记录下来，然后放在data block最后面。每个data block尾部还有一个type和CRC32.其中type可以选择是否
需要针对这个data block进行snappy压缩，而CRC32是针对这个data block的校验。
</p>

<p>
data index block组织形式和data block非常类似，只不过有两个不同。1)data index block从不刷新直到Table构造完成之后才会刷新，所以
对于一个table而言的话只有一个data index block.2)data index block添加的key/value是在data block形成的时候添加的，添加key非常取巧
，是上一个data block和这个data block的一个key seperator.比如上一个data block的max key是abcd,而这个data block的min key是ad.那么这个
seperator可以设置成为ac.seperator的生成可以参考Comparator.使用尽量短的seperator可以减小磁盘开销并且提高效率。而对于添加的value就是
这个data block的offset.同样在data index block也会存在restart point.
</p>

<p>
然后看看进行一个key的query是如何进行的。首先读取出data index block(这个部分可以常驻内存)，得到里面的restart point部分。针对restart point
进行二分。因为restart point指向的key都是全量的key.如果确定在某两个restart point之间之后，就可以遍历这个restart point之间范围分析seperator.
得到想要查找的seperator之后对应的value就是某个data block offset.读取这个data block和之前的方法一样就可以查找key了。对于遍历来说，过程是一样的。
</p>

<p>
这里我们稍微分析一下这样的工作方式的优缺点。对于写或者是merge来说的话，效率相当的高，所有写都是顺序写并且还可以进行压缩。影响写效率的话一个重要参数就是flush block的参数。
但是对于读来说的话，个人觉得过程有点麻烦，但是可以实现得高效率。对于flush block调节会影响到data index block和data block占用内存大小。如果flush block过大的话，
那么会造成data index block耗费内存小，但是每次读取出一个data block内存很大。如果flush block过小的话，那么data index block耗费内存很大，但是每次读取data block内存很小。
而restart point数量会影响过多的话，那么可能会占用稍微大一些的内存空间，但是会使得查找过程更快(遍历数更少).
</p>
</div>
</div>
</div>

<div id="outline-container-orgafa40cd" class="outline-2">
<h2 id="orgafa40cd"><span class="section-number-2">5</span> Compaction</h2>
<div class="outline-text-2" id="text-5">
<p>
对于Compaction触发的策略牵扯到了算法问题，自己表示没有仔细看这个策略(其实当时看了但是完全没有理解).这里谈谈compaction如何删除文件的问题。
在leveldb里面每次做一个compaction都会产生一个version对象添加到versionset里面，version里面包含了这个version管理了哪些文件。
每次进行读取都会从某个version读取，然后针对这个version做一个引用计数。然后每次需要删除一些不必要的文件时候就会遍历versionset了解哪些文件
还需要，然后对比文件系统目录下面的文件就知道哪些文件不再需要，即可删除。
</p>

<p>
#note: 这里稍微总结一下 <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> 提到的compaction策略。可能阅读完了这些策略之后反过头来看看
代码可能会更好，只是记得当时阅读compaction策略太痛苦了所以直接忽略了。
</p>

<p>
每个level都有一定的大小限制，并且每个level里面的文件的key都是不会overlap的(L0除外).触发条件很多，文档上描述是某个level超过一定限制。
但是之前阅读代码发现其实并不是这样的，可以参看函数VersionSet::PickCompaction.可以看到有两个触发条件size<sub>compaction和seek</sub><sub>compaction</sub>.
所谓的size<sub>compaction就是说某个level超过一定大小</sub>，而seek<sub>compaction指某个文件被seek次数超过一定次数之后会触发</sub>(关于这个值的更新可以查看VersionSet::Builder::Apply,
在一个文件初始创建的时候就已经设置好了allowed<sub>seeks次数</sub>).
</p>

<p>
前面是触发条件，后面来说说compaction策略.文档上描述非常简单但是事实不是这样。如果需要compact某个level的话，如果level&gt;0的话那么对于这个level
只会选出一个file来和level+1中存在overlap的文件进行合并然后生成一个新的文件。如果level==0的话那么对于这个level可能选择多个文件出来和level+1中overlap
文件合并。对于选取level中文件来说的话是采用rotate keyspace的方式来挑选的。在生成新文件的时候，通常会有两个情况拆分出一个新文件。1)
文件过大 2)文件和level+2中超过10个存在overlap. 2)情况非常好理解，因为如果产生一个大文件和level+2 overlap文件数量过多的话，那么进行level+1的compaction
时间就会非常长并且随机读非常严重。
</p>

<p>
<a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> 文档Timing这节个人感觉非常有价值。作者估算了一下compaction对于整个系统带宽带来的影响。
按照2MB一个sst文件在level(&gt;0)上面的compaction来计算的话，一次compaction需要read 26MB和write 26MB~=50MB.假设磁盘带宽100MB/s我们通过后台线程限制速度的话，
那么做compaction需要耗费5s时间。假设用户写速度也在10MS/s的话，那么会生成50MB数据相当于25个sst level0文件。这样对读来说会造成很大影响。
作者给出的建议包括：
</p>
<pre class="example">
Solution 1: To reduce this problem, we might want to increase the log switching threshold when the number of level-0 files is large.
Though the downside is that the larger this threshold, the more memory we will need to hold the corresponding memtable.

Solution 2: We might want to decrease write rate artificially when the number of level-0 files goes up.

Solution 3: We work on reducing the cost of very wide merges. Perhaps most of the level-0 files will have their blocks sitting uncompressed
in the cache and we will only need to worry about the O(N) complexity in the merging iterator.
</pre>
<p>
其中第二点感觉非常好就是认为控制写入速度当level0文件过多的时候。在db<sub>impl.cc</sub> DBImpl::MakeRoomForWrite这个应该是在memtable缺少空间的时候的函数.
</p>
<div class="org-src-container">
<pre class="src src-C++">  allow_delay &amp;&amp;
  versions_-&gt;NumLevelFiles(0) &gt;= <span style="font-weight: bold; text-decoration: underline;">config</span>::kL0_SlowdownWritesTrigger) {
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We are getting close to hitting a hard limit on the number of</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">L0 files.  Rather than delaying a single write by several</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">seconds when we hit the hard limit, start delaying each</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">individual write by 1ms to reduce latency variance.  Also,</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">this delay hands over some CPU to the compaction thread in</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">case it is sharing the same core as the writer.</span>
mutex_.Unlock();
env_-&gt;SleepForMicroseconds(1000);
allow_delay = <span style="font-weight: bold; text-decoration: underline;">false</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Do not delay a single write more than once</span>
mutex_.Lock();
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfe89b34" class="outline-2">
<h2 id="orgfe89b34"><span class="section-number-2">6</span> Recovery</h2>
<div class="outline-text-2" id="text-6">
<p>
#note: 这里稍微总结一下 <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> 提到的关于recovery的部分。幸运的是在阅读这个文档的时候
也让我重新仔细地思考了一下这个recovery过程可能会如何进行的。
</p>

<p>
我们主要关注三个数据的恢复：
</p>
<ul class="org-ul">
<li>用户的data(log)</li>
<li>leveldb所管理的文件(MANIFEST)</li>
<li>内部生成的sequence number(MANIFEST)</li>
</ul>

<p>
对于用户的data而言可以通过记录log来完成。注意这个log里面都是db的insert/delete等操作。值得注意的是，每次生成新的memtable也会生成新的log文件。
这点是非常必要的，因为这样才可以将需要恢复哪些log对应起来。并且log里面每条日志都带上了sequence number,所以log里面的sequence number也有助于
sequence number恢复。
</p>

<p>
记录leveldb所管理的文件非常简单。我们观察管理文件变化只会发生在compaction的时候，在当前version下面删除一部分文件生成一部分文件。我们将
这些变化称为VersionEdit.每次compaction完成之后的话我们将这个version edit记录在MANIFEST内部，同时生成一个Version。version edit是增量,version是全量。
(至于如何记录这个没有仔细看.但是看代码里面似乎有全量也有增量的记录).如果创建一个新的MANIFEST文件的话，会将MANIFEST文件名称记录在CURRENT内部。
这样启动之后就知道读取哪个MANIFEST文件了。当然记录在MANIFEST内部的不仅仅是文件的变化，还有生成这个Version时候对应的log以及sequence number.
</p>

<p>
这样我们的recovery过程就非常简单了。读取CURRENT文件知道读取哪个MANIFEST文件。从MANIFEST文件里面构造Version并且回放VersionEdit.
根据当前的状态知道需要读取哪些log.然后回放log更新sequence number等状态。
</p>
</div>
</div>

<div id="outline-container-org5baaa8c" class="outline-2">
<h2 id="org5baaa8c"><span class="section-number-2">7</span> Snapshot</h2>
<div class="outline-text-2" id="text-7">
<p>
Snapshot集合在leveldb里面组织成为一个链表，oldest的节点必然最小的snapshot。对于每一个snapshot配备一个sequence number,
所以很明显oldest的节点的sequence number应该是最小的。每次进行compaction的时候会判断当前最小的sequence number
是多少然后将一些不必要的节点删除。另外在查询key的时候也会结合这个snapshot sequence number结合成为一个复合key进行查询。
</p>
</div>
</div>

<div id="outline-container-org9bdbe37" class="outline-2">
<h2 id="org9bdbe37"><span class="section-number-2">8</span> Cache</h2>
<div class="outline-text-2" id="text-8">
<p>
对于leveldb来说的话存在两个cache系统，一个是TableCache，一个是BlockCache.其中TableCache是用来缓存文件描述符的，
而BlockCache是用来做data block的缓存的(Table::BlockeReader).对于leveldb只有一个cache实现在Code Analysis/Cache里面做了详细分析。
</p>

<p>
我们这里最感兴趣的东西，应该就是每个cache的kv分别是什么。对于TableCahce的k是file<sub>number,v是Table的Iterator</sub>
(Table::NewIterator).对于leveldb来说的话文件的file<sub>number都是自增的所以使用file</sub><sub>number没有任何问题</sub>。对于BlockCache
来说的话k是(cache<sub>id,offset</sub>),v是Block的内存。(#todo: 对于这个cache<sub>id现在还不是非常理解</sub>，但是个人觉得
这个cache<sub>id可以</sub>==file<sub>number.使用cache</sub><sub>id就是每次Open的时候这个cache</sub><sub>id都会改变</sub>)
</p>

<p>
和BlockCache是针对disk block来进行cache的，另外一种cache方案就是Record Cache.相对Block Cache,Record Cache无疑更能够
提高使用效率包括内存大小以及Cache命中率。但是大家拒绝在内部使用RecordCache的原因非常简答，就是这个在应用层完成似乎更好，
应用层可以更好地进行Cache。在应用层完成同时会引入一个问题就是Cache一致性，但是其实维持这个一致性并不是一件很复杂的事情，
Cache主要用来解决读取问题，做写穿透并且让Cache失效即可。leveldb维护BlockCache一致性并不麻烦，因为leveldb的update并不是in-place的。
</p>

<p>
#note: 不过后来仔细想了一下觉得Record Cache还是在应用层做比较好，可以控制缓存策略比如大小失效时间。对于底层库还是在做BlockCache会比较好一些.
</p>
</div>
</div>

<div id="outline-container-org0b6d4f6" class="outline-2">
<h2 id="org0b6d4f6"><span class="section-number-2">9</span> Option</h2>
<div class="outline-text-2" id="text-9">
<p>
在options.h里面有一些leveldb可选的选项。
</p>
<ul class="org-ul">
<li>comparator.用户可以指定比较器</li>
<li>create<sub>if</sub><sub>missing.如果数据库不存在就创建</sub></li>
<li>error<sub>if</sub><sub>exists.如果数据库存在就报错</sub></li>
<li>paranoid<sub>checks.尽可能多地进行错误检查</sub></li>
<li>env.用户可以模拟db环境</li>
<li>info<sub>log.leveldb本身logger</sub>.</li>
<li>write<sub>buffer</sub><sub>size.memtable大小</sub></li>
<li>max<sub>open</sub><sub>files.最大打开fd数量</sub></li>
<li>block<sub>cache.Table读取data</sub> block的cache.</li>
<li>block<sub>size.Table里面Block大小</sub></li>
<li>block<sub>restart</sub><sub>interval.在一个Block里面每隔多少个key创建一个restart</sub> point.</li>
<li>compression.DataBlock是否需要压缩</li>
<li>filter<sub>policy.过滤策略默认就是bloom</sub> filter.</li>
<li>verify<sub>checksums.读取block时候是否校验checksum</sub></li>
<li>fill<sub>cache.读取block是否会Cache.通常scan时候不要做cache</sub></li>
<li>sync.leveldb内部发起write的话是否会调用fsync.</li>
</ul>
</div>
</div>

<div id="outline-container-orge85319e" class="outline-2">
<h2 id="orge85319e"><span class="section-number-2">10</span> ReadingCode</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-orgcc08411" class="outline-3">
<h3 id="orgcc08411"><span class="section-number-3">10.1</span> Interface</h3>
<div class="outline-text-3" id="text-10-1">
<p>
我们首先看看leveldb给我们暴露的头文件有哪些.稍微简单地看看接口提供了哪些功能.头文件目录是include/leveldb
</p>
<ul class="org-ul">
<li>cache.h // kv内存cache接口</li>
<li>c.h // leveldb C接口</li>
<li>comparator.h // Slice的比较接口</li>
<li>db.h // db对象接口</li>
<li>env.h // 和环境相关的接口</li>
<li>filter<sub>policy.h</sub> // 过滤策略相关的接口</li>
<li>iterator.h // 遍历接口</li>
<li>options.h // db操作的选项对象</li>
<li>slice.h // db操作的key对象(Slice)</li>
<li>status.h // db操作返回状态的对象</li>
<li>table<sub>builder.h</sub> // 构建table</li>
<li>table.h // immutable persistent sortedtable.</li>
<li>write<sub>batch.h</sub> // 批量(原子)写入对象</li>
</ul>
<p>
leveldb里面对象的实现方式，很多都是采用抽象类然后提供工厂模式来创建的，这样的话允许用户更换具体实现。
</p>
</div>

<div id="outline-container-org3fc8cab" class="outline-4">
<h4 id="org3fc8cab"><span class="section-number-4">10.1.1</span> cache.h</h4>
<div class="outline-text-4" id="text-10-1-1">
<p>
Cache主要是用来作为kv查询cache部分.Cache接口非常简单，其中Handle是了为了管理cache item.注释写得非常好
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Cache</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">Cache</span>() { }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Destroys all existing entries by calling the "deleter"</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">function that was passed to the constructor.</span>
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">Cache</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Opaque handle to an entry stored in the cache.</span>
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Handle</span> { };

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Insert a mapping from key-&gt;value into the cache and assign it</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the specified charge against the total cache capacity.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns a handle that corresponds to the mapping.  The caller</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">must call this-&gt;Release(handle) when the returned mapping is no</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">longer needed.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">When the inserted entry is no longer needed, the key and</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">value will be passed to "deleter".</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold;">Insert</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">charge</span>,
                         <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">deleter</span>)(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>)) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If the cache has no mapping for "key", returns NULL.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Else return a handle that corresponds to the mapping.  The caller</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">must call this-&gt;Release(handle) when the returned mapping is no</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">longer needed.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold;">Lookup</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Release a mapping returned by a previous Lookup().</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: handle must not have been released yet.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: handle must have been returned by a method on *this.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Release</span>(<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">handle</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the value encapsulated in a handle returned by a</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">successful Lookup().</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: handle must not have been released yet.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: handle must have been returned by a method on *this.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">Value</span>(<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">handle</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If the cache contains entry for key, erase it.  Note that the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">underlying entry will be kept around until all existing handles</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to it have been released.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Erase</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a new numeric id.  May be used by multiple clients who are</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sharing the same cache to partition the key space.  Typically the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">client will allocate a new id at startup and prepend the id to</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">its cache keys.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">NewId</span>() = 0;

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">LRU_Remove</span>(<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">e</span>);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">LRU_Append</span>(<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">e</span>);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Unref</span>(<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">e</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21487;&#20197;&#30475;&#21040;Handle&#21487;&#33021;&#23454;&#38469;&#19978;&#24213;&#23618;&#26377;&#24341;&#29992;&#35745;&#25968;&#23384;&#22312;.</span>

  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Rep</span>;
  <span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">rep_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">opaque&#23454;&#29616;&#25351;&#38024;&#30340;&#23384;&#22312;.</span>
};
</pre>
</div>
<p>
一般底层Handle有引用计数，然后调用Release的话会atomic dec.如果==0的话那么会调用Insert时候的deleter接口进行释放。
这里稍微总结一下Cache提供的接口
</p>
<ul class="org-ul">
<li>Insert // 插入kv返回Handle</li>
<li>Lookup // 查询k返回Handle</li>
<li>Value // 传入handle得到对应的value</li>
<li>Erase // 删除kv</li>
<li>NewId // 产生一个新id.</li>
</ul>

<p>
实现是ShardedLRUCache.这个后面会具体分析.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">extern</span> <span style="font-weight: bold; text-decoration: underline;">Cache</span>* <span style="font-weight: bold;">NewLRUCache</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">capacity</span>);
<span style="font-weight: bold; text-decoration: underline;">Cache</span>* <span style="font-weight: bold;">NewLRUCache</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">capacity</span>) {
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">ShardedLRUCache</span>(capacity);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc547209" class="outline-4">
<h4 id="orgc547209"><span class="section-number-4">10.1.2</span> comparator.h</h4>
<div class="outline-text-4" id="text-10-1-2">
<p>
comparator提供了slice对象的比较方法接口.但是还有两个接口值得提一下
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Advanced functions: these are used to reduce the space requirements</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">for internal data structures like index blocks.</span>

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If *start &lt; limit, changes *start to a short string in [start,limit).</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Simple comparator implementations may return with *start unchanged,</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">i.e., an implementation of this method that does nothing is correct.</span>
<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">FindShortestSeparator</span>(
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">start</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">limit</span>) <span style="font-weight: bold;">const</span> = 0;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Changes *key to a short string &gt;= *key.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Simple comparator implementations may return with *key unchanged,</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">i.e., an implementation of this method that does nothing is correct.</span>
<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">FindShortSuccessor</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span> = 0;
</pre>
</div>
<p>
关于这两个接口注释都解释得十分清楚了。
</p>

<p>
实现是ByteWiseComparatorImpl.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Intentionally not destroyed to prevent destructor racing</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">with background threads.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">bytewise</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">BytewiseComparatorImpl</span>;

<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold;">BytewiseComparator</span>() {
  <span style="font-weight: bold;">return</span> bytewise;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org54886eb" class="outline-4">
<h4 id="org54886eb"><span class="section-number-4">10.1.3</span> db.h</h4>
<div class="outline-text-4" id="text-10-1-3">
<p>
db.h下面有几个对象
</p>
<ul class="org-ul">
<li>Snapshot(接口)</li>
<li>Range</li>
<li>DB(接口)</li>
</ul>

<p>
Snapshot结构非常简单，只是提供了一些虚析构函数接口。实现是SnapshotImpl.
</p>

<p>
Range的话就是两个Slice表示范围，表示[start,limit)
#+BEGGIN<sub>SRC</sub> C++
// A range of keys
struct Range {
  Slice start;          <i>/ Included in the range
  Slice limit;          /</i> Not included in the range
</p>

<p>
  Range() { }
  Range(const Slice&amp; s, const Slice&amp; l) : start(s), limit(l) { }
};
#+END<sub>SRC</sub>
</p>

<p>
DB是我们发起操作的对象。然后我们看看最关键的DB提供了哪些接口.注释写得清晰真的没有必要解释了:).
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A DB is a persistent ordered map from keys to values.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A DB is safe for concurrent access from multiple threads without</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">any external synchronization.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">DB</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Open the database with the specified "name".</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Stores a pointer to a heap-allocated database in *dbptr and returns</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">OK on success.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Stores NULL in *dbptr and returns a non-OK status on error.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Caller should delete *dbptr when it is no longer needed.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Open</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">name</span>,
                     <span style="font-weight: bold; text-decoration: underline;">DB</span>** <span style="font-weight: bold; font-style: italic;">dbptr</span>);

  <span style="font-weight: bold;">DB</span>() { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">DB</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Set the database entry for "key" to "value".  Returns OK on success,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and a non-OK status on error.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note: consider setting options.sync = true.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Put</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>,
                     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Remove the database entry (if any) for "key".  Returns OK on</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">success, and a non-OK status on error.  It is not an error if "key"</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">did not exist in the database.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note: consider setting options.sync = true.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Delete</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Apply the specified updates to the database.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns OK on success, non-OK on failure.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note: consider setting options.sync = true.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Write</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>, <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>* <span style="font-weight: bold; font-style: italic;">updates</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If the database contains an entry for "key" store the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">corresponding value in *value and return OK.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If there is no entry for "key" leave *value unchanged and return</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a status for which Status::IsNotFound() returns true.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">May return some other Status on an error.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Get</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">value</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a heap-allocated iterator over the contents of the database.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The result of NewIterator() is initially invalid (caller must</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">call one of the Seek methods on the iterator before using it).</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Caller should delete the iterator when it is no longer needed.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The returned iterator should be deleted before this db is deleted.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a handle to the current DB state.  Iterators created with</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">this handle will all observe a stable snapshot of the current DB</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">state.  The caller must call ReleaseSnapshot(result) when the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">snapshot is no longer needed.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Snapshot</span>* <span style="font-weight: bold;">GetSnapshot</span>() = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Release a previously acquired snapshot.  The caller must not</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">use "snapshot" after this call.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ReleaseSnapshot</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Snapshot</span>* <span style="font-weight: bold; font-style: italic;">snapshot</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">DB implementations can export properties about their state</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">via this method.  If "property" is a valid property understood by this</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">DB implementation, fills "*value" with its current value and returns</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">true.  Otherwise returns false.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Valid property names include:</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">"leveldb.num-files-at-level&lt;N&gt;" - return the number of files at level &lt;N&gt;,</span>
  <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">where &lt;N&gt; is an ASCII representation of a level number (e.g. "0").</span>
  <span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">"leveldb.stats" - returns a multi-line string that describes statistics</span>
  <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">about the internal operation of the DB.</span>
  <span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">"leveldb.sstables" - returns a multi-line string that describes all</span>
  <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">of the sstables that make up the db contents.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">GetProperty</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">property</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">value</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For each i in [0,n-1], store in "sizes[i]", the approximate</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file system space used by keys in "[range[i].start .. range[i].limit)".</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note that the returned sizes measure file system space usage, so</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">if the user data compresses by a factor of ten, the returned</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sizes will be one-tenth the size of the corresponding user data size.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The results may not include the sizes of recently written data.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">GetApproximateSizes</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Range</span>* <span style="font-weight: bold; font-style: italic;">range</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>,
                                   <span style="font-weight: bold; text-decoration: underline;">uint64_t</span>* <span style="font-weight: bold; font-style: italic;">sizes</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Compact the underlying storage for the key range [*begin,*end].</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">In particular, deleted and overwritten versions are discarded,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and the data is rearranged to reduce the cost of operations</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">needed to access the data.  This operation should typically only</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">be invoked by users who understand the underlying implementation.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">begin==NULL is treated as a key before all keys in the database.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">end==NULL is treated as a key after all keys in the database.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Therefore the following call will compact the entire database:</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">db-&gt;CompactRange(NULL, NULL);</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">CompactRange</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">begin</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">end</span>) = 0;
};
</pre>
</div>
<p>
实现是DBImpl.这里稍微总结一下DB提供的接口
</p>
<ul class="org-ul">
<li>Open // 创建DB</li>
<li>Put //</li>
<li>Delete //</li>
<li>Write // batch(atomic)写入.</li>
<li>Get //</li>
<li>NewInterator // 创建迭代器</li>
<li>GetSnapshot // 创建snapshot</li>
<li>ReleaseSnapShot // 销毁snapshot</li>
<li>GetProperty // 获取属性</li>
<li>GetApproximateSizes // 根据range这个部分内容占用磁盘大小</li>
<li>CompactRange // 压缩range这个部分内容</li>
</ul>

<p>
此外还提供了两个函数用于删除DB以及修复DB.这个会单独讨论.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Destroy the contents of the specified database.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Be very careful using this method.</span>
<span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">DestroyDB</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">name</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>);

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If a DB cannot be opened, you may attempt to call this method to</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">resurrect as much of the contents of the database as possible.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Some data may be lost, so be careful when calling this function</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">on a database that contains important information.</span>
<span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">RepairDB</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org014ca3b" class="outline-4">
<h4 id="org014ca3b"><span class="section-number-4">10.1.4</span> env.h</h4>
<div class="outline-text-4" id="text-10-1-4">
<p>
env.h里面抽象了环境，这样用户可以很方便低进行定制.可以看到leveldb大量的设计依赖于虚函数。
对于这种存储系统用虚函数带来的开销应该是可以接受的。但是对于压缩或者是传输协议的话那么虚函数开销就不可以忽略了。
提供提供了默认环境实现在util/env<sub>posix.cc里面</sub>。这个会在后面详细分析。所谓环境包括下面几个对象.
</p>
</div>

<ol class="org-ol">
<li><a id="org3e9f192"></a>Env<br />
<div class="outline-text-5" id="text-10-1-4-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Env</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">Env</span>() { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">Env</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a default environment suitable for the current operating</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">system.  Sophisticated users may wish to provide their own Env</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">implementation instead of relying on this default environment.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The result of Default() belongs to leveldb and must never be deleted.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold;">Default</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create a brand new sequentially-readable file with the specified name.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">On success, stores a pointer to the new file in *result and returns OK.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">On failure stores NULL in *result and returns non-OK.  If the file does</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">not exist, returns a non-OK status.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The returned file will only be accessed by one thread at a time.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NewSequentialFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>,
                                   <span style="font-weight: bold; text-decoration: underline;">SequentialFile</span>** <span style="font-weight: bold; font-style: italic;">result</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create a brand new random access read-only file with the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">specified name.  On success, stores a pointer to the new file in</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">*result and returns OK.  On failure stores NULL in *result and</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">returns non-OK.  If the file does not exist, returns a non-OK</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">status.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The returned file may be concurrently accessed by multiple threads.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NewRandomAccessFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>,
                                     <span style="font-weight: bold; text-decoration: underline;">RandomAccessFile</span>** <span style="font-weight: bold; font-style: italic;">result</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create an object that writes to a new file with the specified</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">name.  Deletes any existing file with the same name and creates a</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">new file.  On success, stores a pointer to the new file in</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">*result and returns OK.  On failure stores NULL in *result and</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">returns non-OK.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The returned file will only be accessed by one thread at a time.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NewWritableFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>,
                                 <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>** <span style="font-weight: bold; font-style: italic;">result</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns true iff the named file exists.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">FileExists</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Store in *result the names of the children of the specified directory.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The names are relative to "dir".</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Original contents of *results are dropped.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">GetChildren</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dir</span>,
                             <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&gt;* <span style="font-weight: bold; font-style: italic;">result</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Delete the named file.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">DeleteFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create the specified directory.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">CreateDir</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dirname</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Delete the specified directory.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">DeleteDir</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dirname</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Store the size of fname in *file_size.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">GetFileSize</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>, <span style="font-weight: bold; text-decoration: underline;">uint64_t</span>* <span style="font-weight: bold; font-style: italic;">file_size</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Rename file src to target.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">RenameFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">src</span>,
                            <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Lock the specified file.  Used to prevent concurrent access to</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the same db by multiple processes.  On failure, stores NULL in</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">*lock and returns non-OK.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">On success, stores a pointer to the object that represents the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">acquired lock in *lock and returns OK.  The caller should call</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">UnlockFile(*lock) to release the lock.  If the process exits,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the lock will be automatically released.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If somebody else already holds the lock, finishes immediately</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">with a failure.  I.e., this call does not wait for existing locks</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to go away.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">May create the named file if it does not already exist.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">LockFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>, <span style="font-weight: bold; text-decoration: underline;">FileLock</span>** <span style="font-weight: bold; font-style: italic;">lock</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Release the lock acquired by a previous successful call to LockFile.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: lock was returned by a successful LockFile() call</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: lock has not already been unlocked.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">UnlockFile</span>(<span style="font-weight: bold; text-decoration: underline;">FileLock</span>* <span style="font-weight: bold; font-style: italic;">lock</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Arrange to run "(*function)(arg)" once in a background thread.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"function" may run in an unspecified thread.  Multiple functions</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">added to the same Env may run concurrently in different threads.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">I.e., the caller may not assume that background work items are</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">serialized.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Schedule</span>(
      <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">function</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>),
      <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Start a new thread, invoking "function(arg)" within the new thread.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">When "function(arg)" returns, the thread will be destroyed.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">StartThread</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">function</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>), <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">*path is set to a temporary directory that can be used for testing. It may</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">or many not have just been created. The directory may or may not differ</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">between runs of the same process, but subsequent calls will return the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">same directory.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">GetTestDirectory</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">path</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create and return a log file for storing informational messages.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NewLogger</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>, <span style="font-weight: bold; text-decoration: underline;">Logger</span>** <span style="font-weight: bold; font-style: italic;">result</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns the number of micro-seconds since some fixed point in time. Only</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">useful for computing deltas of time.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">NowMicros</span>() = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Sleep/delay the thread for the perscribed number of micro-seconds.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SleepForMicroseconds</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">micros</span>) = 0;
};
</pre>
</div>
<p>
稍微总结一下这些接口.对于这些接口创建的抽象对象，在后面也会详细解释。实现是PosixEnv.
</p>
<ul class="org-ul">
<li>Default // 获得默认的环境</li>
<li>NewSequentialFile // 创建顺序文件</li>
<li>NewRandomAccessFile // 创建随机文件</li>
<li>NewWritableFile // 创建可写文件</li>
<li>FileExists // 文件是否存在</li>
<li>GetChildren // 目录下面的文件</li>
<li>DeleteFile // 删除文件</li>
<li>CreateDir // 创建目录</li>
<li>DeleteDir // 删除目录</li>
<li>GetFileSize // filesize.</li>
<li>RenameFile // rename.</li>
<li>LockFile // 锁住文件</li>
<li>UnlockFile // 解锁文件</li>
<li>StartThread // 创建线程</li>
<li>GetTestDirectory // 测试目录</li>
<li>NewLogger // 创建logger打印到对应文件</li>
<li>NowMicros // 当前us.</li>
<li>SleepForMicroseconds // sleep us</li>
</ul>
<p>
环境还提供了一个EnvWrapper.这个类就是得到一个Env*对象然后重新转发出去。
</p>
</div>
</li>

<li><a id="orga929932"></a>FileLock<br />
<div class="outline-text-5" id="text-10-1-4-2">
<p>
FileLock接口非常简单，可以说就没有接口.唯一要做的事情就是和Env里面的LockFile与UnlockFile配合。实现是PosixFileLock.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Identifies a locked file.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">FileLock</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">FileLock</span>() { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">FileLock</span>();
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No copying allowed</span>
  <span style="font-weight: bold;">FileLock</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FileLock</span>&amp;);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FileLock</span>&amp;);
};
</pre>
</div>
</div>
</li>

<li><a id="orgab1e126"></a>Logger<br />
<div class="outline-text-5" id="text-10-1-4-3">
<p>
Logger接口也非常简单，就是Logv.允许打印变长参数.实现是PosixLogger.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">An interface for writing log messages.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Logger</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">Logger</span>() { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">Logger</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Write an entry to the log file with the specified format.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Logv</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">format</span>, <span style="font-weight: bold; text-decoration: underline;">va_list</span> <span style="font-weight: bold; font-style: italic;">ap</span>) = 0;

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No copying allowed</span>
  <span style="font-weight: bold;">Logger</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Logger</span>&amp;);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Logger</span>&amp;);
};
</pre>
</div>

<p>
为了编写方便提供了这么一个宏
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Log the specified data to *info_log if info_log is non-NULL.</span>
<span style="font-weight: bold;">extern</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Log</span>(<span style="font-weight: bold; text-decoration: underline;">Logger</span>* <span style="font-weight: bold; font-style: italic;">info_log</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">format</span>, ...)
<span style="font-weight: bold;">#   if</span> <span style="font-weight: bold;">defined</span>(__GNUC__) || <span style="font-weight: bold;">defined</span>(__clang__)
    <span style="font-weight: bold;">__attribute__</span>((__format__ (__printf__, 2, 3)))
<span style="font-weight: bold;">#   endif</span>
    ;
</pre>
</div>
</div>
</li>

<li><a id="orgbcf6774"></a>RandomAccessFile<br />
<div class="outline-text-5" id="text-10-1-4-4">
<p>
RandomAccessFile所提供的语义就是能够随机从offset读取n个字节，存放在scratch里面。
然后将result里面的内容指向scratch.随机读取并且要求能够多线程安全。实现是PosixRandomAccessFile.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A file abstraction for randomly reading the contents of a file.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">RandomAccessFile</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">RandomAccessFile</span>() { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">RandomAccessFile</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read up to "n" bytes from the file starting at "offset".</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"scratch[0..n-1]" may be written by this routine.  Sets "*result"</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to the data that was read (including if fewer than "n" bytes were</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">successfully read).  May set "*result" to point at data in</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"scratch[0..n-1]", so "scratch[0..n-1]" must be live when</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"*result" is used.  If an error was encountered, returns a non-OK</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">status.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Safe for concurrent use by multiple threads.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Read</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">offset</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">result</span>,
                      <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>) <span style="font-weight: bold;">const</span> = 0;
};
</pre>
</div>
</div>
</li>

<li><a id="org9a40f4b"></a>SequentialFile<br />
<div class="outline-text-5" id="text-10-1-4-5">
<p>
SequentialFile提供的语义包括顺序读取以及Skip字节。这些都是外部来保证同步的。实现是PosixSequentialFile.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A file abstraction for reading sequentially through a file</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">SequentialFile</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">SequentialFile</span>() { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">SequentialFile</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read up to "n" bytes from the file.  "scratch[0..n-1]" may be</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">written by this routine.  Sets "*result" to the data that was</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">read (including if fewer than "n" bytes were successfully read).</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">May set "*result" to point at data in "scratch[0..n-1]", so</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"scratch[0..n-1]" must be live when "*result" is used.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If an error was encountered, returns a non-OK status.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: External synchronization</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Read</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">result</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Skip "n" bytes from the file. This is guaranteed to be no</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slower that reading the same data, but may be faster.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If end of file is reached, skipping will stop at the end of the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file, and Skip will return OK.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: External synchronization</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Skip</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">n</span>) = 0;
};
</pre>
</div>
</div>
</li>

<li><a id="org50b9a27"></a>WritableFile<br />
<div class="outline-text-5" id="text-10-1-4-6">
<p>
WritableFile语义就是允许Append,Close,Flush,Sync.这里Flush的语义应该是将内部缓存数据完全写入，
而Sync表示让磁盘进行同步。因为可能外部会调用小对象的写入，所以这里需要进行缓存。实现是PosixMmapFile.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A file abstraction for sequential writing.  The implementation</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">must provide buffering since callers may append small fragments</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">at a time to the file.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">WritableFile</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">WritableFile</span>() { }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">WritableFile</span>();

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Append</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">data</span>) = 0;
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Close</span>() = 0;
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Flush</span>() = 0;
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Sync</span>() = 0;

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No copying allowed</span>
  <span style="font-weight: bold;">WritableFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>&amp;);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>&amp;);
};
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org451ecfe" class="outline-4">
<h4 id="org451ecfe"><span class="section-number-4">10.1.5</span> filter<sub>policy.h</sub></h4>
<div class="outline-text-4" id="text-10-1-5">
<p>
通过阅读注释还是可以很容易地了解到filter<sub>policy提供的语义的</sub>。另外还可以看到leveldb本身提供了bloomfilter的实现。#todo: 这里对于bits<sub>per</sub><sub>key含义不是很了解</sub>。
</p>

<p>
#note: 所谓的bits<sub>per</sub><sub>key就是希望为每个key分配多少个bits来进行检测</sub>。但是这个并不等于检测bits.在leveldb这个bloomfilter里面的话这个数值叫做probe.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">FilterPolicy</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">FilterPolicy</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29992;&#26469;&#20570;&#20860;&#23481;&#21028;&#26029;&#12290;&#22914;&#26524;&#26032;&#30340;filter policy&#21457;&#29983;&#25913;&#21464;&#30340;&#35805;&#65292;&#37027;&#20040;&#36825;&#20010;&#21517;&#23383;&#20063;&#24517;&#39035;&#21464;&#21270;&#12290;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the name of this policy.  Note that if the filter encoding</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">changes in an incompatible way, the name returned by this method</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">must be changed.  Otherwise, old incompatible filters may be</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">passed to methods of this type.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">Name</span>() <span style="font-weight: bold;">const</span> = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">keys&#37117;&#26159;&#25490;&#22909;&#24207;&#30340;&#65292;&#23558;&#36825;&#20123;keys&#21152;&#20837;filter.&#30456;&#24403;&#20110;&#21578;&#30693;&#36825;&#20123;keys&#24050;&#32463;&#23384;&#22312;&#12290;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">keys[0,n-1] contains a list of keys (potentially with duplicates)</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">that are ordered according to the user supplied comparator.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Append a filter that summarizes keys[0,n-1] to *dst.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Warning: do not change the initial contents of *dst.  Instead,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">append the newly constructed filter to *dst.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">CreateFilter</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">keys</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dst</span>)
      <span style="font-weight: bold;">const</span> = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;key&#26159;&#21542;&#22312;filter&#37324;&#38754;&#12290;&#36825;&#20010;filter&#26159;&#22312;CreateFilter&#37324;&#38754;&#30340;dst&#21253;&#35013;&#20986;&#26469;&#30340;&#12290;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"filter" contains the data appended by a preceding call to</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">CreateFilter() on this class.  This method must return true if</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the key was in the list of keys passed to CreateFilter().</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This method may return true or false if the key was not on the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">list, but it should aim to return false with a high probability.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">KeyMayMatch</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">filter</span>) <span style="font-weight: bold;">const</span> = 0;
};

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a new filter policy that uses a bloom filter with approximately</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the specified number of bits per key.  A good value for bits_per_key</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">is 10, which yields a filter with ~ 1% false positive rate.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Callers must delete the result after any database that is using the</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">result has been closed.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note: if you are using a custom comparator that ignores some parts</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of the keys being compared, you must not use NewBloomFilterPolicy()</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and must provide your own FilterPolicy that also ignores the</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">corresponding parts of the keys.  For example, if the comparator</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ignores trailing spaces, it would be incorrect to use a</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">FilterPolicy (like NewBloomFilterPolicy) that does not ignore</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">trailing spaces in keys.</span>
<span style="font-weight: bold;">extern</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FilterPolicy</span>* <span style="font-weight: bold;">NewBloomFilterPolicy</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">bits_per_key</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb0f2806" class="outline-4">
<h4 id="orgb0f2806"><span class="section-number-4">10.1.6</span> iterator.h</h4>
<div class="outline-text-4" id="text-10-1-6">
<p>
遍历器接口非常简单，支持前向和反向遍历。还支持seek到某一个key.支持注册cleanup函数.实现是DBIter.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">Iterator</span>();
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">Iterator</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">An iterator is either positioned at a key/value pair, or</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">not valid.  This method returns true iff the iterator is valid.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Valid</span>() <span style="font-weight: bold;">const</span> = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Position at the first key in the source.  The iterator is Valid()</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">after this call iff the source is not empty.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToFirst</span>() = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Position at the last key in the source.  The iterator is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Valid() after this call iff the source is not empty.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToLast</span>() = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Position at the first key in the source that at or past target</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The iterator is Valid() after this call iff the source contains</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">an entry that comes at or past target.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Moves to the next entry in the source.  After this call, Valid() is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">true iff the iterator was not positioned at the last entry in the source.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Valid()</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Next</span>() = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Moves to the previous entry in the source.  After this call, Valid() is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">true iff the iterator was not positioned at the first entry in source.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Valid()</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Prev</span>() = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the key for the current entry.  The underlying storage for</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the returned slice is valid only until the next modification of</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the iterator.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Valid()</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">key</span>() <span style="font-weight: bold;">const</span> = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the value for the current entry.  The underlying storage for</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the returned slice is valid only until the next modification of</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the iterator.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: !AtEnd() &amp;&amp; !AtStart()</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">value</span>() <span style="font-weight: bold;">const</span> = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If an error has occurred, return it.  Else return an ok status.</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">status</span>() <span style="font-weight: bold;">const</span> = 0;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Clients are allowed to register function/arg1/arg2 triples that</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">will be invoked when this iterator is destroyed.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note that unlike all of the preceding methods, this method is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">not abstract and therefore clients should not override it.</span>
  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold; text-decoration: underline;">CleanupFunction</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg1</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg2</span>);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">RegisterCleanup</span>(<span style="font-weight: bold; text-decoration: underline;">CleanupFunction</span> <span style="font-weight: bold; font-style: italic;">function</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg1</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg2</span>);

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Cleanup</span> {
    <span style="font-weight: bold; text-decoration: underline;">CleanupFunction</span> <span style="font-weight: bold; font-style: italic;">function</span>;
    <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg1</span>;
    <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg2</span>;
    <span style="font-weight: bold; text-decoration: underline;">Cleanup</span>* <span style="font-weight: bold; font-style: italic;">next</span>;
  };
  <span style="font-weight: bold; text-decoration: underline;">Cleanup</span> <span style="font-weight: bold; font-style: italic;">cleanup_</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No copying allowed</span>
  <span style="font-weight: bold;">Iterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>&amp;);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>&amp;);
};
</pre>
</div>
<p>
这个里面部分实现在table/iterator.cc里面有.都非常简单.创建好cleanup对象然后组织称为链表,在析构函数时候调用.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">Iterator</span>() {
  cleanup_.function = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  cleanup_.next = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
}

<span style="font-weight: bold; text-decoration: underline;">Iterator</span>::~<span style="font-weight: bold;">Iterator</span>() {
  <span style="font-weight: bold;">if</span> (cleanup_.function != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">Cleanup</span>* <span style="font-weight: bold; font-style: italic;">c</span> = cleanup_.next; c != <span style="font-weight: bold; text-decoration: underline;">NULL</span>; ) {
      (*c-&gt;function)(c-&gt;arg1, c-&gt;arg2);
      <span style="font-weight: bold; text-decoration: underline;">Cleanup</span>* <span style="font-weight: bold; font-style: italic;">next</span> = c-&gt;next;
      <span style="font-weight: bold;">delete</span> c;
      c = next;
    }
  }
}

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">RegisterCleanup</span>(<span style="font-weight: bold; text-decoration: underline;">CleanupFunction</span> <span style="font-weight: bold; font-style: italic;">func</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg1</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg2</span>) {
  assert(func != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold; text-decoration: underline;">Cleanup</span>* <span style="font-weight: bold; font-style: italic;">c</span>;
  <span style="font-weight: bold;">if</span> (cleanup_.function == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    c = &amp;cleanup_;
  } <span style="font-weight: bold;">else</span> {
    c = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Cleanup</span>;
    c-&gt;next = cleanup_.next;
    cleanup_.next = c;
  }
  c-&gt;function = func;
  c-&gt;arg1 = arg1;
  c-&gt;arg2 = arg2;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2d86b14" class="outline-4">
<h4 id="org2d86b14"><span class="section-number-4">10.1.7</span> options.h</h4>
<div class="outline-text-4" id="text-10-1-7">
<p>
对于options来说存在3种
</p>
<ul class="org-ul">
<li>Options // 控制DB行为.</li>
<li>ReadOptions // 控制读取行为</li>
<li>WriteOptions // 控制写入行为</li>
</ul>
</div>

<ol class="org-ol">
<li><a id="org4c3b878"></a>Options<br />
<div class="outline-text-5" id="text-10-1-7-1">
<p>
Options控制DB行为，在DB::Open时候就传入.我们需要针对这些字段仔细看看.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">DB contents are stored in a set of blocks, each of which holds a</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sequence of key,value pairs.  Each block may be compressed before</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">being stored in a file.  The following enum describes which</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compression method (if any) is used to compress a block.</span>
<span style="font-weight: bold;">enum</span> <span style="font-weight: bold; text-decoration: underline;">CompressionType</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NOTE: do not change the values of existing entries, as these are</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">part of the persistent format on disk.</span>
  <span style="font-weight: bold; font-style: italic;">kNoCompression</span>     = 0x0,
  <span style="font-weight: bold; font-style: italic;">kSnappyCompression</span> = 0x1
};

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Options to control the behavior of a database (passed to DB::Open)</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Options</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">-------------------</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Parameters that affect behavior</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Comparator used to define the order of keys in the table.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: a comparator that uses lexicographic byte-wise ordering</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: The client must ensure that the comparator supplied</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">here has the same name and orders keys *exactly* the same as the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">comparator provided to previous open calls on the same DB.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">comparator</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#20309;&#36827;&#34892;slice compare</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If true, the database will be created if it is missing.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: false</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">create_if_missing</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">database&#19981;&#23384;&#22312;&#26159;&#21542;&#38656;&#35201;&#21019;&#24314;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If true, an error is raised if the database already exists.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: false</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">error_if_exists</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#25968;&#25454;&#24211;&#23384;&#22312;&#26159;&#21542;error</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If true, the implementation will do aggressive checking of the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">data it is processing and will stop early if it detects any</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">errors.  This may have unforeseen ramifications: for example, a</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">corruption of one DB entry may cause a large number of entries to</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">become unreadable or for the entire DB to become unopenable.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: false</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">paranoid_checks</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20250;&#26356;&#22810;&#22320;&#26816;&#26597;&#25968;&#25454;&#27491;&#30830;&#24615;.&#36825;&#20010;&#22312;&#26085;&#24535;&#22238;&#25918;&#30340;&#26102;&#20505;&#26377;&#25928;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">MaybeIgnoreError&#37324;&#38754;&#20351;&#29992;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Use the specified object to interact with the environment,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">e.g. to read/write files, schedule background work, etc.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: Env::Default()</span>
  <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold; font-style: italic;">env</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25805;&#20316;&#29615;&#22659;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Any internal progress/error information generated by the db will</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">be written to info_log if it is non-NULL, or to a file stored</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">in the same directory as the DB contents if info_log is NULL.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: NULL</span>
  <span style="font-weight: bold; text-decoration: underline;">Logger</span>* <span style="font-weight: bold; font-style: italic;">info_log</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Logger.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">-------------------</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Parameters that affect performance</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Amount of data to build up in memory (backed by an unsorted log</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">on disk) before converting to a sorted on-disk file.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Larger values increase performance, especially during bulk loads.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Up to two write buffers may be held in memory at the same time,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">so you may wish to adjust this parameter to control memory usage.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Also, a larger write buffer will result in a longer recovery time</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the next time the database is opened.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: 4MB</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">write_buffer_size</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">memtable&#36229;&#36807;&#36825;&#20123;&#20869;&#23384;&#22823;&#23567;&#30340;&#35805;&#23601;&#20250;&#20889;table.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Number of open files that can be used by the DB.  You may need to</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">increase this if your database has a large working set (budget</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">one open file per 2MB of working set).</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: 1000</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">max_open_files</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#22823;&#25991;&#20214;&#21477;&#26564;&#25968;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Control over blocks (user data is stored in a set of blocks, and</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a block is the unit of reading from disk).</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If non-NULL, use the specified cache for blocks.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If NULL, leveldb will automatically create and use an 8MB internal cache.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: NULL</span>
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>* <span style="font-weight: bold; font-style: italic;">block_cache</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20869;&#37096;cahce.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Approximate size of user data packed per block.  Note that the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block size specified here corresponds to uncompressed data.  The</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">actual size of the unit read from disk may be smaller if</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compression is enabled.  This parameter can be changed dynamically.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: 4K</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">block_size</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">SSTable&#37324;&#38754;&#30340;Block&#22823;&#23567;.&#20855;&#20307;&#21487;&#20197;&#30475;BlockBuilder.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Number of keys between restart points for delta encoding of keys.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This parameter can be changed dynamically.  Most clients should</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">leave this parameter alone.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: 16</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">block_restart_interval</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block&#37324;&#38754;&#30340;restart&#38388;&#38548;.&#20855;&#20307;&#21487;&#20197;&#30475;BlockBuilder.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Compress blocks using the specified compression algorithm.  This</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">parameter can be changed dynamically.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: kSnappyCompression, which gives lightweight but fast</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compression.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">~200-500MB/s compression</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">~400-800MB/s decompression</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note that these speeds are significantly faster than most</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">persistent storage speeds, and therefore it is typically never</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">worth switching to kNoCompression.  Even if the input data is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">incompressible, the kSnappyCompression implementation will</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">efficiently detect that and will switch to uncompressed mode.</span>
  <span style="font-weight: bold; text-decoration: underline;">CompressionType</span> <span style="font-weight: bold; font-style: italic;">compression</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21387;&#32553;&#31867;&#22411;.&#19981;&#21387;&#32553;&#21644;Snappy&#21387;&#32553;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create an Options object with default values for all fields.</span>
  <span style="font-weight: bold;">Options</span>();
};
</pre>
</div>
</div>
</li>

<li><a id="orgeb6fa84"></a>ReadOptions<br />
<div class="outline-text-5" id="text-10-1-7-2">
<p>
和Options一样里面也都是控制字段.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Options that control read operations</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If true, all data read from underlying storage will be</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">verified against corresponding checksums.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: false</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">verify_checksums</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462;&#26102;&#20505;&#36827;&#34892;checksum&#26657;&#39564;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Should the data read for this iteration be cached in memory?</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Callers may wish to set this field to false for bulk scans.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: true</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">fill_cache</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21542;&#38656;&#35201;&#20174;cache&#37324;&#38754;&#26597;&#25214;.&#22914;&#26524;&#26159;bulk scans&#30340;&#35805;&#37027;&#20040;&#35774;&#32622;false.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If "snapshot" is non-NULL, read as of the supplied snapshot</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(which must belong to the DB that is being read and which must</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">not have been released).  If "snapshot" is NULL, use an impliicit</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">snapshot of the state at the beginning of this read operation.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: NULL</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Snapshot</span>* <span style="font-weight: bold; font-style: italic;">snapshot</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#23384;&#22312;Snapshot&#30340;&#35805;&#37027;&#20040;&#23601;&#22312;snapshot&#19978;&#38754;&#35835;&#21462;.</span>

  <span style="font-weight: bold;">ReadOptions</span>()
      : verify_checksums(<span style="font-weight: bold; text-decoration: underline;">false</span>),
        fill_cache(<span style="font-weight: bold; text-decoration: underline;">true</span>),
        snapshot(<span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
  }
};
</pre>
</div>
</div>
</li>

<li><a id="orgc4d2298"></a>WriteOptions<br />
<div class="outline-text-5" id="text-10-1-7-3">
<p>
和Options一样里面也都是控制字段.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Options that control write operations</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">WriteOptions</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If true, the write will be flushed from the operating system</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">buffer cache (by calling WritableFile::Sync()) before the write</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">is considered complete.  If this flag is true, writes will be</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slower.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If this flag is false, and the machine crashes, some recent</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">writes may be lost.  Note that if it is just the process that</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">crashes (i.e., the machine does not reboot), no writes will be</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lost even if sync==false.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">In other words, a DB write with sync==false has similar</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">crash semantics as the "write()" system call.  A DB write</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">with sync==true has similar crash semantics to a "write()"</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">system call followed by "fsync()".</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Default: false</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">sync</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21542;&#27599;&#27425;&#20889;&#37117;&#38656;&#35201;fsync.</span>

  <span style="font-weight: bold;">WriteOptions</span>()
      : sync(<span style="font-weight: bold; text-decoration: underline;">false</span>) {
  }
};
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org93a7e60" class="outline-4">
<h4 id="org93a7e60"><span class="section-number-4">10.1.8</span> slice.h</h4>
<div class="outline-text-4" id="text-10-1-8">
<p>
leveldb里面的Slice对象是用来作为key使用的。内部实现非常简单，仅仅是存储二进制的指针和大小。
我们可能需要稍微注意一下slice对象的compare方法.首先按照最小长度比较，如果相等然后按照比较长度。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>::<span style="font-weight: bold;">compare</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">b</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">min_len</span> = (size_ &lt; b.size_) ? size_ : b.size_;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">r</span> = memcmp(data_, b.data_, min_len);
  <span style="font-weight: bold;">if</span> (r == 0) {
    <span style="font-weight: bold;">if</span> (size_ &lt; b.size_) r = -1;
    <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (size_ &gt; b.size_) r = +1;
  }
  <span style="font-weight: bold;">return</span> r;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga37f1a5" class="outline-4">
<h4 id="orga37f1a5"><span class="section-number-4">10.1.9</span> status.h</h4>
<div class="outline-text-4" id="text-10-1-9">
<p>
status就是一个非常简单的封装.内部持有一个char* status_;从注释里面可以看出如何安排的。
实现在util/status.cc里面，没有必要仔细阅读。不过我到觉得直接返回一个int就算了。
没有必要开辟char[].不过如果这个部分没有性能问题也就无所谓了。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create a success status.</span>
  <span style="font-weight: bold;">Status</span>() : state_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>) { }
  ~<span style="font-weight: bold;">Status</span>() { <span style="font-weight: bold;">delete</span>[] state_; }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Copy the specified status.</span>
  <span style="font-weight: bold;">Status</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">s</span>);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">s</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a success status.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">OK</span>() { <span style="font-weight: bold;">return</span> Status(); }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return error status of an appropriate type.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NotFound</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg2</span> = Slice()) {
    <span style="font-weight: bold;">return</span> Status(kNotFound, msg, msg2);
  }
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Corruption</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg2</span> = Slice()) {
    <span style="font-weight: bold;">return</span> Status(kCorruption, msg, msg2);
  }
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NotSupported</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg2</span> = Slice()) {
    <span style="font-weight: bold;">return</span> Status(kNotSupported, msg, msg2);
  }
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">InvalidArgument</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg2</span> = Slice()) {
    <span style="font-weight: bold;">return</span> Status(kInvalidArgument, msg, msg2);
  }
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">IOError</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg2</span> = Slice()) {
    <span style="font-weight: bold;">return</span> Status(kIOError, msg, msg2);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns true iff the status indicates success.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">ok</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> (state_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>); }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns true iff the status indicates a NotFound error.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">IsNotFound</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> code() == kNotFound; }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a string representation of this status suitable for printing.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns the string "OK" for success.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold;">ToString</span>() <span style="font-weight: bold;">const</span>;

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">OK status has a NULL state_.  Otherwise, state_ is a new[] array</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of the following form:</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">state_[0..3] == length of message</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">state_[4]    == code</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">state_[5..]  == message</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">state_</span>;

  <span style="font-weight: bold;">enum</span> <span style="font-weight: bold; text-decoration: underline;">Code</span> {
    <span style="font-weight: bold; font-style: italic;">kOk</span> = 0,
    <span style="font-weight: bold; font-style: italic;">kNotFound</span> = 1,
    <span style="font-weight: bold; font-style: italic;">kCorruption</span> = 2,
    <span style="font-weight: bold; font-style: italic;">kNotSupported</span> = 3,
    <span style="font-weight: bold; font-style: italic;">kInvalidArgument</span> = 4,
    <span style="font-weight: bold; font-style: italic;">kIOError</span> = 5
  };

  <span style="font-weight: bold; text-decoration: underline;">Code</span> <span style="font-weight: bold;">code</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> (state_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) ? kOk : <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Code</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">state_</span>[4]);
  }

  <span style="font-weight: bold;">Status</span>(<span style="font-weight: bold; text-decoration: underline;">Code</span> <span style="font-weight: bold; font-style: italic;">code</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">msg2</span>);
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">CopyState</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">s</span>);
};

<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::<span style="font-weight: bold;">Status</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">s</span>) {
  state_ = (s.state_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) ? <span style="font-weight: bold; text-decoration: underline;">NULL</span> : CopyState(s.state_);
}
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::<span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">s</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The following condition catches both aliasing (when this == &amp;s),</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and the common case where both s and *this are ok.</span>
  <span style="font-weight: bold;">if</span> (state_ != s.state_) {
    <span style="font-weight: bold;">delete</span>[] state_;
    state_ = (s.state_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) ? <span style="font-weight: bold; text-decoration: underline;">NULL</span> : CopyState(s.state_);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org80dc918" class="outline-4">
<h4 id="org80dc918"><span class="section-number-4">10.1.10</span> table<sub>builder.h</sub></h4>
<div class="outline-text-4" id="text-10-1-10">
<p>
TableBuilder用来帮助构建Table.而Table本身只是用来进行查询遍历等操作.用户在完成之后需要Finish或者是Abandon.
具体实现会在后面分析.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create a builder that will store the contents of the table it is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">building in *file.  Does not close the file.  It is up to the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">caller to close the file after calling Finish().</span>
  <span style="font-weight: bold;">TableBuilder</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>, <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20256;&#20837;options&#21644;&#21487;&#20889;&#25991;&#20214;(&#36861;&#21152;&#20889;&#27169;&#24335;)</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Either Finish() or Abandon() has been called.</span>
  ~<span style="font-weight: bold;">TableBuilder</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Change the options used by this builder.  Note: only some of the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">option fields can be changed after construction.  If a field is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">not allowed to change dynamically and its value in the structure</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">passed to the constructor is different from its value in the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">structure passed to this method, this method will return an error</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">without changing any fields.</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">ChangeOptions</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#26086;&#26500;&#24314;&#22909;&#20043;&#21518;&#21482;&#20801;&#35768;&#20462;&#25913;&#37096;&#20998;&#23383;&#27573;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add key,value to the table being constructed.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: key is after any previously added key according to comparator.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Finish(), Abandon() have not been called</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Add</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28155;&#21152;kv</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Advanced operation: flush any buffered key/value pairs to file.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Can be used to ensure that two adjacent entries never live in</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the same data block.  Most clients should not need to use this method.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Finish(), Abandon() have not been called</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Flush</span>(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;buffered&#30340;kv&#21047;&#26032;&#21040;&#25991;&#20214;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return non-ok iff some error has been detected.</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">status</span>() <span style="font-weight: bold;">const</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Finish building the table.  Stops using the file passed to the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">constructor after this function returns.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Finish(), Abandon() have not been called</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Finish</span>(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26500;&#24314;&#23436;&#25104;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Indicate that the contents of this builder should be abandoned.  Stops</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">using the file passed to the constructor after this function returns.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If the caller is not going to call Finish(), it must call Abandon()</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">before destroying this builder.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Finish(), Abandon() have not been called</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Abandon</span>(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#25918;&#24323;&#26500;&#24314;&#30340;&#35805;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Number of calls to Add() so far.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">NumEntries</span>() <span style="font-weight: bold;">const</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28155;&#21152;&#20102;&#22810;&#23569;&#27425;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Size of the file generated so far.  If invoked after a successful</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Finish() call, returns the size of the final generated file.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">FileSize</span>() <span style="font-weight: bold;">const</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#24050;&#32463;&#20889;&#20837;&#22810;&#23569;&#25991;&#20214;&#20102;.</span>

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">ok</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> status().ok(); }
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">WriteBlock</span>(<span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span>* <span style="font-weight: bold; font-style: italic;">block</span>, <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>* <span style="font-weight: bold; font-style: italic;">handle</span>);

  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Rep</span>;
  <span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">rep_</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No copying allowed</span>
  <span style="font-weight: bold;">TableBuilder</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>&amp;);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>&amp;);
};
</pre>
</div>
<p>
下面是一些比较重要的接口.
</p>
<ul class="org-ul">
<li>ChangeOptions // 修改选项</li>
<li>Add // 添加kv.k必须是有序</li>
<li>Flush // 刷新</li>
<li>Finish // 结束</li>
<li>Abandon // 放弃</li>
</ul>
</div>
</div>

<div id="outline-container-org5658088" class="outline-4">
<h4 id="org5658088"><span class="section-number-4">10.1.11</span> table.h</h4>
<div class="outline-text-4" id="text-10-1-11">
<p>
Table就是持久化并且不可变的sortedtable.下面来看看接口.具体实现会在后面分析.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A Table is a sorted map from strings to strings.  Tables are</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">immutable and persistent.  A Table may be safely accessed from</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">multiple threads without external synchronization.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Table</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Attempt to open the table that is stored in bytes [0..file_size)</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of "file", and read the metadata entries necessary to allow</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">retrieving data from the table.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If successful, returns ok and sets "*table" to the newly opened</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">table.  The client should delete "*table" when no longer needed.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If there was an error while initializing the table, sets "*table"</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to NULL and returns a non-ok status.  Does not take ownership of</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"*source", but the client must ensure that "source" remains live</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">for the duration of the returned table's lifetime.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">*file must remain live while this Table is in use.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Open</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                     <span style="font-weight: bold; text-decoration: underline;">RandomAccessFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>,
                     <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_size</span>,
                     <span style="font-weight: bold; text-decoration: underline;">Table</span>** <span style="font-weight: bold; font-style: italic;">table</span>);

  ~<span style="font-weight: bold;">Table</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns a new iterator over the table contents.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The result of NewIterator() is initially invalid (caller must</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">call one of the Seek methods on the iterator before using it).</span>
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp;) <span style="font-weight: bold;">const</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Given a key, return an approximate byte offset in the file where</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the data for that key begins (or would begin if the key were</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">present in the file).  The returned value is in terms of file</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bytes, and so includes effects like compression of the underlying data.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">E.g., the approximate offset of the last key in the table will</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">be close to the file length.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">ApproximateOffsetOf</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span>;

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Rep</span>;
  <span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">rep_</span>;

  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">Table</span>(<span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">rep</span>) { rep_ = rep; }
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">BlockReader</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>*, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp;, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp;);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No copying allowed</span>
  <span style="font-weight: bold;">Table</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Table</span>&amp;);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">=</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Table</span>&amp;);
};
</pre>
</div>
<p>
主要提供的接口如下
</p>
<ul class="org-ul">
<li>Open. // 这个接口可以看出访问的是随机文件.</li>
<li>NewIterator // 创建一个迭代器.</li>
<li>ApproximateOffsetOf // 可以通过key查找到大致位置然后后续可以发起读操作.</li>
</ul>
</div>
</div>

<div id="outline-container-org77bd8b5" class="outline-4">
<h4 id="org77bd8b5"><span class="section-number-4">10.1.12</span> write<sub>batch.h</sub></h4>
<div class="outline-text-4" id="text-10-1-12">
<p>
WriteBatch用来持有批量写入的内容.注意底层实现有Handler是需要具体实现的。关于这个具体实现部分会在后面分析.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">WriteBatch</span>();
  ~<span style="font-weight: bold;">WriteBatch</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Store the mapping "key-&gt;value" in the database.</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Put</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If the database contains a mapping for "key", erase it.  Else do nothing.</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Delete</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Clear all updates buffered in this batch.</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Clear</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Support for iterating over the contents of a batch.</span>
  <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Handler</span> {
   <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">Handler</span>();
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Put</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>) = 0;
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Delete</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) = 0;
  };
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Iterate</span>(<span style="font-weight: bold; text-decoration: underline;">Handler</span>* <span style="font-weight: bold; font-style: italic;">handler</span>) <span style="font-weight: bold;">const</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38405;&#35835;&#21518;&#38754;&#20250;&#21457;&#29616;&#65292;&#36825;&#20010;&#24847;&#24605;&#26159;&#36941;&#21382;&#25152;&#26377;&#30340;WriteBatch&#37324;&#38754;&#30340;item</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#25805;&#20316;handler.handler&#21487;&#33021;&#26159;&#19968;&#20010;memtable.&#36825;&#26679;&#21487;&#20197;&#23558;&#37324;&#38754;&#25152;&#26377;&#30340;&#20869;&#23481;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20840;&#37096;&#23384;&#25918;&#21040;memtable&#37324;&#38754;&#21435;.</span>

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">friend</span> <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24213;&#23618;&#23454;&#29616;&#26159;&#36825;&#20010;.</span>

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">rep_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">See comment in write_batch.cc for the format of rep_ // &#23558;&#25152;&#26377;&#30340;&#25805;&#20316;&#35831;&#27714;&#20570;&#25104;&#20108;&#36827;&#21046;&#23384;&#25918;&#22312;rep_</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Intentionally copyable</span>
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3469978" class="outline-3">
<h3 id="org3469978"><span class="section-number-3">10.2</span> Implementation</h3>
<div class="outline-text-3" id="text-10-2">
<p>
实现部分我按照功能划分了几个部分.
</p>
<ul class="org-ul">
<li>DB</li>
<li>Posix</li>
<li>Cache</li>
<li>Batch</li>
<li>Log</li>
<li>Table</li>
<li>Util</li>
</ul>
</div>
</div>

<div id="outline-container-orgea91e76" class="outline-3">
<h3 id="orgea91e76"><span class="section-number-3">10.3</span> DB</h3>
<div class="outline-text-3" id="text-10-3">
</div>
<div id="outline-container-orgd90d397" class="outline-4">
<h4 id="orgd90d397"><span class="section-number-4">10.3.1</span> FileName</h4>
<div class="outline-text-4" id="text-10-3-1">
<p>
db/filename.cc 这里面都是关于文件名称操作的方法.文件包括
</p>
<ul class="org-ul">
<li>db/CURRENT // 当前文件</li>
<li>db/LOCK // DB锁文件</li>
<li>db/LOG // info log.日志文件.</li>
<li>db/LOG.old // info log.日志文件.</li>
<li>db/MANIFEST-[0-9]+ // 描述文件</li>
<li>db/[0-9]+.log // db日志文件</li>
<li>db/[0-9]+.sst // dbtable文件</li>
<li>db/[0-9]+.dbtmp // db临时文件</li>
</ul>
<p>
这里[0-9]+都表示一个sequence number.这里还有另外一个不是操作FileName的函数.SetCurrentFile
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">SetCurrentFile</span>(<span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold; font-style: italic;">env</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>,
                      <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">descriptor_number</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Remove leading "dbname/" and add newline to manifest file name</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">manifest</span> = DescriptorFileName(dbname, descriptor_number);
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">contents</span> = manifest;
  assert(contents.starts_with(dbname + <span style="font-style: italic;">"/"</span>));
  contents.remove_prefix(dbname.size() + 1);
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">tmp</span> = TempFileName(dbname, descriptor_number);
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = WriteStringToFile(env, contents.ToString() + <span style="font-style: italic;">"\n"</span>, tmp);
  <span style="font-weight: bold;">if</span> (s.ok()) {
    s = env-&gt;RenameFile(tmp, CurrentFileName(dbname));
  }
  <span style="font-weight: bold;">if</span> (!s.ok()) {
    env-&gt;DeleteFile(tmp);
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
<p>
就是将MANIFEST-%(descriptor<sub>number</sub>)llu+"\n"写入到.dbtmp下面去然后rename成为CURRENT文件.
</p>
</div>
</div>

<div id="outline-container-orgdcef09e" class="outline-4">
<h4 id="orgdcef09e"><span class="section-number-4">10.3.2</span> Config</h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
db/dbformat.h config下面是一些静态常数.这里可以仔细看看.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Grouping of constants.  We may want to make some of these</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">parameters set via options.</span>
<span style="font-weight: bold;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">config</span> {
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">leveldb&#26368;&#22823;level&#22810;&#23569;.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kNumLevels</span> = 7;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Level-0 compaction is started when we hit this many files.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">level0&#25991;&#20214;&#36229;&#36807;&#22810;&#23569;&#20010;&#35302;&#21457;compaction.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kL0_CompactionTrigger</span> = 4;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#38754;&#20004;&#20010;&#21487;&#20197;&#22312;MakeRoomForWrite&#37324;&#38754;&#30475;&#21040;.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Soft limit on number of level-0 files.  We slow down writes at this point.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;level0&#25991;&#20214;&#36229;&#36807;&#36825;&#20040;&#22810;&#30340;&#35805;&#37027;&#20040;&#21487;&#33021;&#20250;&#25918;&#32531;memtable&#20889;&#20026;level0&#30340;&#36895;&#24230;.&#27604;&#22914;delay 1s&#21861;&#30340;.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kL0_SlowdownWritesTrigger</span> = 8;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Maximum number of level-0 files.  We stop writes at this point.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;level0&#25991;&#20214;&#36229;&#36807;&#36825;&#20040;&#22810;&#30340;&#35805;&#37027;&#19981;&#20250;memtable&#20889;&#20026;level0.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kL0_StopWritesTrigger</span> = 12;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;memtable&#36827;&#34892;compaction&#30340;&#35805;&#36873;&#25321;&#30340;&#26368;&#39640;level.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#21487;&#20197;&#22312;PickLevelForMemtableOutput&#37324;&#38754;&#21487;&#20197;&#30475;&#21040;.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Maximum level to which a new compacted memtable is pushed if it</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">does not create overlap.  We try to push to level 2 to avoid the</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">relatively expensive level 0=&gt;1 compactions and to avoid some</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">expensive manifest file operations.  We do not push all the way to</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the largest level since that can generate a lot of wasted disk</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">space if the same key space is being repeatedly overwritten.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kMaxMemCompactLevel</span> = 2;

}  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">namespace config</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d56679" class="outline-4">
<h4 id="org0d56679"><span class="section-number-4">10.3.3</span> DBImpl</h4>
<div class="outline-text-4" id="text-10-3-3">
<p>
db/db<sub>impl.cc</sub> DBImpl这个结构体挺大的。我们先过一个这个结构然后仔细看看每个字段是什么
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">DB</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Constant after construction</span>
  <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">env_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29615;&#22659;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span> <span style="font-weight: bold; font-style: italic;">internal_comparator_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20869;&#37096;&#27604;&#36739;&#22120;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span> <span style="font-weight: bold; font-style: italic;">options_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">options_.comparator == &amp;internal_comparator_ // &#36873;&#39033;.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">owns_info_log_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21542;&#33258;&#24049;&#20998;&#37197;&#30340;log.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">owns_cache_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21542;&#33258;&#24049;&#20998;&#37197;&#30340;cache.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">dbname_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">db&#21517;&#31216;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">table_cache_ provides its own synchronization</span>
  <span style="font-weight: bold; text-decoration: underline;">TableCache</span>* <span style="font-weight: bold; font-style: italic;">table_cache_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TableCache.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Lock over the persistent DB state.  Non-NULL iff successfully acquired.</span>
  <span style="font-weight: bold; text-decoration: underline;">FileLock</span>* <span style="font-weight: bold; font-style: italic;">db_lock_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">db FileLock. // &#23545;&#20110;&#22806;&#37096;&#36827;&#31243;&#26631;&#35760;DB&#23545;&#35937;&#20114;&#26021;&#38145;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">State below is protected by mutex_</span>
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">Mutex</span> <span style="font-weight: bold; font-style: italic;">mutex_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25972;&#20010;DB&#23545;&#35937;&#20114;&#26021;&#38145;.</span>
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">AtomicPointer</span> <span style="font-weight: bold; font-style: italic;">shutting_down_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26631;&#35760;&#36825;&#20010;DB&#23545;&#35937;&#27491;&#22312;&#36864;&#20986;&#12290;&#21518;&#21488;&#32447;&#31243;&#25110;&#30475;&#21040;&#20043;&#21518;&#19981;&#24212;&#35813;&#36827;&#34892;&#20219;&#20309;&#25805;&#20316;&#12290;</span>
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">CondVar</span> <span style="font-weight: bold; font-style: italic;">bg_cv_</span>;          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Signalled when background work finishes</span>
  <span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">mem_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27491;&#22312;&#25805;&#20316;&#30340;memtable.</span>
  <span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">imm_</span>;                <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Memtable being compacted.&#27491;&#22312;&#34987;compacted&#30340;memtable</span>
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">AtomicPointer</span> <span style="font-weight: bold; font-style: italic;">has_imm_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">So bg thread can detect non-NULL imm_</span>
  <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">logfile_</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">logfile_number_</span>;
  <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Writer</span>* <span style="font-weight: bold; font-style: italic;">log_</span>;
  <span style="font-weight: bold; text-decoration: underline;">LoggerId</span>* <span style="font-weight: bold; font-style: italic;">logger_</span>;            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NULL, or the id of the current logging thread</span>
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">CondVar</span> <span style="font-weight: bold; font-style: italic;">logger_cv_</span>;     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For threads waiting to log.&#21644;mutex_&#20851;&#32852;.</span>
  <span style="font-weight: bold; text-decoration: underline;">SnapshotList</span> <span style="font-weight: bold; font-style: italic;">snapshots_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#25152;&#26377;&#30340;snapshot</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Set of table files to protect from deletion because they are</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">part of ongoing compactions.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">set</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt; <span style="font-weight: bold; font-style: italic;">pending_outputs_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27491;&#22312;&#36755;&#20986;&#25110;&#32773;&#26159;&#36827;&#34892;compaction&#30340;file.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20445;&#23384;&#36825;&#20010;&#20449;&#24687;&#30340;&#35805;&#36825;&#26679;&#22312;delete&#25991;&#20214;&#30340;&#25918;&#32622;&#19981;&#34987;&#21024;&#38500;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Has a background compaction been scheduled or is running?</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">bg_compaction_scheduled_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#21488;&#32447;&#31243;&#26159;&#21542;&#22312;&#36816;&#34892;.&#36824;&#26159;&#21487;&#20197;&#36864;&#20986;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Information for a manual compaction</span>
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ManualCompaction</span> {
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>;
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">done</span>;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">begin</span>;   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NULL means beginning of key range</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">end</span>;     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NULL means end of key range</span>
    <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">tmp_storage</span>;    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Used to keep track of compaction progress</span>
  };
  <span style="font-weight: bold; text-decoration: underline;">ManualCompaction</span>* <span style="font-weight: bold; font-style: italic;">manual_compaction_</span>;

  <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>* <span style="font-weight: bold; font-style: italic;">versions_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29256;&#26412;&#38598;&#21512;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Have we encountered a background error in paranoid mode?</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">bg_error_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#21488;&#32447;&#31243;&#36816;&#34892;&#29366;&#24577;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Per level compaction stats.  stats_[level] stores the stats for</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compactions that produced data for the specified "level".</span>
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">CompactionStats</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21387;&#32553;&#29366;&#24577;&#20449;&#24687;.</span>
    <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">micros</span>;
    <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">bytes_read</span>;
    <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">bytes_written</span>;

    <span style="font-weight: bold;">CompactionStats</span>() : micros(0), bytes_read(0), bytes_written(0) { }

    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Add</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">CompactionStats</span>&amp; <span style="font-weight: bold; font-style: italic;">c</span>) {
      <span style="font-weight: bold;">this</span>-&gt;micros += c.micros;
      <span style="font-weight: bold;">this</span>-&gt;bytes_read += c.bytes_read;
      <span style="font-weight: bold;">this</span>-&gt;bytes_written += c.bytes_written;
    }
  };
  <span style="font-weight: bold; text-decoration: underline;">CompactionStats</span> <span style="font-weight: bold; font-style: italic;">stats_</span>[<span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21508;&#20010;&#32423;&#21035;&#30340;&#21387;&#32553;&#29366;&#24577;&#20449;&#24687;.</span>
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org81f497a"></a>Open<br />
<div class="outline-text-5" id="text-10-3-3-1">
<p>
在Interface部分的db.h里面可以知道构造这个DB对象是通过DB::Open来构造的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DB</span>::<span style="font-weight: bold;">Open</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>,
                <span style="font-weight: bold; text-decoration: underline;">DB</span>** <span style="font-weight: bold; font-style: italic;">dbptr</span>) {
  *dbptr = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

  <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>* <span style="font-weight: bold; font-style: italic;">impl</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>(options, dbname); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;DBImpl&#23454;&#20363;.</span>
  impl-&gt;mutex_.Lock(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20284;&#20046;&#27809;&#26377;&#22826;&#22823;&#24517;&#35201;.&#36825;&#37324;&#24212;&#35813;&#27809;&#26377;&#31454;&#20105;.</span>
  <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span> <span style="font-weight: bold; font-style: italic;">edit</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22238;&#22797;&#33258;&#19978;&#27425;&#20381;&#36182;&#30340;edit&#25152;&#26377;&#20869;&#23481;.&#28982;&#21518;&#22312;&#21518;&#38754;&#30452;&#25509;log and apply&#36825;&#20010;edit&#23545;&#35937;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = impl-&gt;Recover(&amp;edit); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Handles create_if_missing, error_if_exists</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#38754;&#27599;&#20010;&#27493;&#39588;&#22823;&#33268;&#19978;&#37117;&#24456;&#28165;&#26970;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1.&#21019;&#24314;&#26032;&#30340;log&#25991;&#20214;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2.&#22238;&#25918;&#21407;&#26469;log&#20449;&#24687;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">3.&#21024;&#38500;&#19981;&#24517;&#35201;&#30340;&#25991;&#20214;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">4.&#36827;&#34892;compaction.</span>
  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">new_log_number</span> = impl-&gt;versions_-&gt;NewFileNumber();
    <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">lfile</span>;
    s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),
                                     &amp;lfile);
    <span style="font-weight: bold;">if</span> (s.ok()) {
      edit.SetLogNumber(new_log_number);
      impl-&gt;logfile_ = lfile;
      impl-&gt;logfile_number_ = new_log_number;
      impl-&gt;log_ = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Writer</span>(lfile);
      s = impl-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;impl-&gt;mutex_);
    }
    <span style="font-weight: bold;">if</span> (s.ok()) {
      impl-&gt;DeleteObsoleteFiles();
      impl-&gt;MaybeScheduleCompaction();
    }
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#20135;&#29983;&#30340;DB&#23545;&#35937;&#36820;&#22238;.</span>
  impl-&gt;mutex_.Unlock();
  <span style="font-weight: bold;">if</span> (s.ok()) {
    *dbptr = impl;
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">delete</span> impl;
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="orgd064fc7"></a>DBImpl<br />
<div class="outline-text-5" id="text-10-3-3-2">
<p>
先看看构造函数
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">DBImpl</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>)
    : env_(options.env),
      internal_comparator_(options.comparator),
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#30340;&#39034;&#24207;.&#24517;&#39035;&#20808;&#35843;&#29992;SanitizeOptions.</span>
      options_(SanitizeOptions(dbname, &amp;internal_comparator_, options)),
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;&#26159;&#21542;&#33258;&#24049;&#25345;&#26377;info log&#21644;block cache.</span>
      owns_info_log_(options_.info_log != options.info_log),
      owns_cache_(options_.block_cache != options.block_cache),
      dbname_(dbname),
      db_lock_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      shutting_down_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      bg_cv_(&amp;mutex_),
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#26032;&#30340;MemTable&#23545;&#35937;.</span>
      mem_(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">MemTable</span>(internal_comparator_)),
      imm_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;log&#37117;&#26159;&#25351;db&#30340;log&#32780;&#19981;&#26159;&#31243;&#24207;log.</span>
      logfile_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      logfile_number_(0),
      log_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      logger_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      logger_cv_(&amp;mutex_),
      bg_compaction_scheduled_(<span style="font-weight: bold; text-decoration: underline;">false</span>),
      manual_compaction_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
  mem_-&gt;Ref();
  has_imm_.Release_Store(<span style="font-weight: bold; text-decoration: underline;">NULL</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Reserve ten files or so for other uses and give the rest to TableCache.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">table_cache_size</span> = options.max_open_files - 10;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#25991;&#20214;&#25551;&#36848;&#31526;&#38480;&#21046;&#21487;&#20197;&#36890;&#36807;TableCache&#26469;&#23436;&#25104;.&#19981;&#38169;:).</span>
  table_cache_ = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">TableCache</span>(dbname_, &amp;options_, table_cache_size);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;VersionSet.</span>
  versions_ = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>(dbname_, &amp;options_, table_cache_,
                             &amp;internal_comparator_);
}
</pre>
</div>

<p>
然后看看析构函数
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::~<span style="font-weight: bold;">DBImpl</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Wait for background work to finish</span>
  mutex_.Lock();
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;shuting down&#26631;&#35760;.&#21518;&#21488;&#32447;&#31243;&#31561;&#24453;&#26631;&#35760;&#36864;&#20986;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31561;&#24453;bg_compaction_scheduled_&#32622;&#20301;&#65292;&#36825;&#26679;bg&#32447;&#31243;&#23601;&#36864;&#20986;&#20102;&#12290;</span>
  shutting_down_.Release_Store(<span style="font-weight: bold;">this</span>);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Any non-NULL value is ok</span>
  <span style="font-weight: bold;">while</span> (bg_compaction_scheduled_) {
    bg_cv_.Wait();
  }
  mutex_.Unlock();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37322;&#25918;db&#38145;&#25991;&#20214;.</span>
  <span style="font-weight: bold;">if</span> (db_lock_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    env_-&gt;UnlockFile(db_lock_);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21024;&#38500;VersionSet.</span>
  <span style="font-weight: bold;">delete</span> versions_;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37322;&#25918;&#24341;&#29992;&#35745;&#25968;</span>
  <span style="font-weight: bold;">if</span> (mem_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) mem_-&gt;Unref();
  <span style="font-weight: bold;">if</span> (imm_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) imm_-&gt;Unref();
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21024;&#38500;&#21487;&#33021;&#20135;&#29983;&#30340;log,logfile&#20197;&#21450;table_cache.</span>
  <span style="font-weight: bold;">delete</span> log_;
  <span style="font-weight: bold;">delete</span> logfile_;
  <span style="font-weight: bold;">delete</span> table_cache_;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37322;&#25918;&#31243;&#24207;log&#20197;&#21450;cache.</span>
  <span style="font-weight: bold;">if</span> (owns_info_log_) {
    <span style="font-weight: bold;">delete</span> options_.info_log;
  }
  <span style="font-weight: bold;">if</span> (owns_cache_) {
    <span style="font-weight: bold;">delete</span> options_.block_cache;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org05c64aa"></a>NewDB<br />
<div class="outline-text-5" id="text-10-3-3-3">
<p>
但从名字上我们不知道里面做了哪些事情，所以还是来看看代码.
通过代码阅读会发现，完成的事情大致就是建立一个Manifest文件，然后将这个版本的Manifest文件
的文件名作为内容写入CURRENT文件。Manifest文件里面包含的就是VersionEdit信息。VersionEdit
可以认为就是这个数据库的元信息。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">NewDB</span>() {
  <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span> <span style="font-weight: bold; font-style: italic;">new_db</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#26032;&#30340;VersionEdit.&#35774;&#32622;&#22909;comparator&#30340;&#21517;&#23383;&#20197;&#21450;&#24517;&#35201;&#23383;&#27573;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20851;&#20110;VersionEdit&#30340;&#20449;&#24687;&#20250;&#22312;&#21518;&#38754;&#20180;&#32454;&#20998;&#26512;.</span>
  new_db.SetComparatorName(user_comparator()-&gt;Name());
  new_db.SetLogNumber(0); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;log number&#20174;0&#24320;&#22987;&#20998;&#37197;.</span>
  new_db.SetNextFile(2);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#19968;&#20010;number&#20174;2&#24320;&#22987;&#20998;&#37197;</span>
  new_db.SetLastSequence(0);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#26032;&#30340;Manifest&#25991;&#20214;.&#28982;&#21518;&#20316;&#20026;writable&#25991;&#20214;&#25171;&#24320;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1&#20998;&#37197;&#32473;manifest&#25991;&#20214;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">manifest</span> = DescriptorFileName(dbname_, 1);
  <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = env_-&gt;NewWritableFile(manifest, &amp;file);
  <span style="font-weight: bold;">if</span> (!s.ok()) {
    <span style="font-weight: bold;">return</span> s;
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25991;&#20214;&#20316;&#20026;log&#26684;&#24335;&#25171;&#24320;.&#23558;VersionEdit&#24207;&#21015;&#21270;&#20043;&#21518;&#20316;&#20026;log&#20889;&#20837;.</span>
  {
    <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Writer</span> <span style="font-weight: bold; font-style: italic;">log</span>(file);
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">record</span>;
    new_db.EncodeTo(&amp;record);
    s = log.AddRecord(record);
    <span style="font-weight: bold;">if</span> (s.ok()) {
      s = file-&gt;Close();
    }
  }
  <span style="font-weight: bold;">delete</span> file;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23558;CURRENT&#37324;&#38754;&#30340;&#25991;&#20214;&#35774;&#32622;&#20026;&#29256;&#26412;1&#30340;manifest&#25991;&#20214;.</span>
  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Make "CURRENT" file that points to the new manifest file.</span>
    s = SetCurrentFile(env_, dbname_, 1);
  } <span style="font-weight: bold;">else</span> {
    env_-&gt;DeleteFile(manifest);
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="orgaabc744"></a>Recover<br />
<div class="outline-text-5" id="text-10-3-3-4">
<p>
恢复状态并且将恢复对于version日志操作.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">Recover</span>(<span style="font-weight: bold; text-decoration: underline;">VersionEdit</span>* <span style="font-weight: bold; font-style: italic;">edit</span>) {
  mutex_.AssertHeld();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Ignore error from CreateDir since the creation of the DB is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">committed only when the descriptor is created, and this directory</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">may already exist from a previous failed creation attempt.</span>
  env_-&gt;CreateDir(dbname_);
  assert(db_lock_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = env_-&gt;LockFile(LockFileName(dbname_), &amp;db_lock_);
  <span style="font-weight: bold;">if</span> (!s.ok()) {
    <span style="font-weight: bold;">return</span> s;
  }

  <span style="font-weight: bold;">if</span> (!env_-&gt;FileExists(CurrentFileName(dbname_))) {
    <span style="font-weight: bold;">if</span> (options_.create_if_missing) {
      s = NewDB(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;DB.</span>
      <span style="font-weight: bold;">if</span> (!s.ok()) {
        <span style="font-weight: bold;">return</span> s;
      }
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::InvalidArgument(
          dbname_, <span style="font-style: italic;">"does not exist (create_if_missing is false)"</span>);
    }
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">if</span> (options_.error_if_exists) {
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::InvalidArgument(
          dbname_, <span style="font-style: italic;">"exists (error_if_exists is true)"</span>);
    }
  }

  s = versions_-&gt;Recover(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;VersionSet&#39318;&#20808;&#36827;&#34892;&#24674;&#22797;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24674;&#22797;&#20043;&#21518;,&#26681;&#25454;&#37324;&#38754;&#30340;&#20869;&#23481;&#28982;&#21518;&#35835;&#21462;&#37324;&#38754;&#23545;&#24212;&#30340;version edit&#20869;&#23481;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#36807;&#20174;versionset&#30340;Recover&#26041;&#27861;&#26469;&#30475;&#30340;&#35805;&#37324;&#38754;&#25152;&#26377;&#30340;&#20869;&#23481;&#24050;&#32463;&#20840;&#37096;&#24674;&#22797;&#20102;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#38754;edit&#30340;&#20869;&#23481;&#26159;&#22240;&#20026;&#22312;&#24674;&#22797;log&#37324;&#38754;&#30340;&#20869;&#23481;&#36896;&#25104;&#30340;.&#28982;&#21518;&#23558;&#36825;&#20010;&#37096;&#20998;&#36896;&#25104;&#30340;edit</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20043;&#21518;&#35843;&#29992;LogAndApply.</span>
  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">max_sequence</span>(0);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Recover from all newer log files than the ones named in the</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">descriptor (new log files may have been added by the previous</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">incarnation without registering them in the descriptor).</span>
    <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note that PrevLogNumber() is no longer used, but we pay</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">attention to it in case we are recovering a database</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">produced by an older version of leveldb.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;&#27880;&#37322;&#36825;&#37324;&#30475;&#20197;&#30475;&#20986;prev_log&#24050;&#32463;&#19981;&#36866;&#29992;&#20102;.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">min_log</span> = versions_-&gt;LogNumber();
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">prev_log</span> = versions_-&gt;PrevLogNumber();
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">std</span>::string&gt; <span style="font-weight: bold; font-style: italic;">filenames</span>;
    s = env_-&gt;GetChildren(dbname_, &amp;filenames);
    <span style="font-weight: bold;">if</span> (!s.ok()) {
      <span style="font-weight: bold;">return</span> s;
    }
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">number</span>;
    <span style="font-weight: bold; text-decoration: underline;">FileType</span> <span style="font-weight: bold; font-style: italic;">type</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt; <span style="font-weight: bold; font-style: italic;">logs</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#26512;logs&#25991;&#20214;&#28982;&#21518;&#21028;&#26029;&#21738;&#20123;log&#25991;&#20214;&#26159;&#21518;&#26469;&#36861;&#21152;&#25105;&#20204;&#38656;&#35201;&#37325;&#25918;&#30340;.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; filenames.size(); i++) {
      <span style="font-weight: bold;">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)
          &amp;&amp; type == kLogFile
          &amp;&amp; ((number &gt;= min_log) || (number == prev_log))) {
        logs.push_back(number);
      }
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Recover in the order in which the logs were generated</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25353;&#29031;&#39034;&#24207;&#36827;&#34892;&#37325;&#25918;.</span>
    <span style="font-weight: bold; text-decoration: underline;">std</span>::sort(logs.begin(), logs.end());
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; logs.size(); i++) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24674;&#22797;&#26576;&#20010;log&#25991;&#20214;.&#24182;&#19988;&#23558;&#37324;&#38754;&#30340;&#25805;&#20316;&#20462;&#25913;&#22635;&#20889;&#21040;edit</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21516;&#26102;&#30693;&#36947;&#24403;&#21069;&#26368;&#22823;&#30340;sequence&#26159;&#22810;&#23569;.</span>
      s = RecoverLogFile(logs[i], edit, &amp;max_sequence);

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The previous incarnation may not have written any MANIFEST</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">records after allocating this log number.  So we manually</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">update the file number allocation counter in VersionSet.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26631;&#35760;file number&#24050;&#32463;&#34987;&#20351;&#29992;&#20102;.</span>
      versions_-&gt;MarkFileNumberUsed(logs[i]);
    }

    <span style="font-weight: bold;">if</span> (s.ok()) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26356;&#26032;&#19968;&#19979;sequence number.</span>
      <span style="font-weight: bold;">if</span> (versions_-&gt;LastSequence() &lt; max_sequence) {
        versions_-&gt;SetLastSequence(max_sequence);
      }
    }
  }

  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="org67f3746"></a>RecoverLogFile<br />
<div class="outline-text-5" id="text-10-3-3-5">
<p>
从单个log恢复写入的内容.并且根据log里面内容了解到对于version修改以及max<sub>sequence</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">RecoverLogFile</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">log_number</span>,
                              <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span>* <span style="font-weight: bold; font-style: italic;">edit</span>,
                              <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span>* <span style="font-weight: bold; font-style: italic;">max_sequence</span>) {
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">LogReporter</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Reader</span>::<span style="font-weight: bold; text-decoration: underline;">Reporter</span> {
    <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold; font-style: italic;">env</span>;
    <span style="font-weight: bold; text-decoration: underline;">Logger</span>* <span style="font-weight: bold; font-style: italic;">info_log</span>;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">fname</span>;
    <span style="font-weight: bold; text-decoration: underline;">Status</span>* <span style="font-weight: bold; font-style: italic;">status</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NULL if options_.paranoid_checks==false</span>
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Corruption</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">s</span>) {
      Log(info_log, <span style="font-style: italic;">"%s%s: dropping %d bytes; %s"</span>,
          (<span style="font-weight: bold;">this</span>-&gt;status == <span style="font-weight: bold; text-decoration: underline;">NULL</span> ? <span style="font-style: italic;">"(ignoring error) "</span> : <span style="font-style: italic;">""</span>),
          fname, <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;(bytes), s.ToString().c_str());
      <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">this</span>-&gt;status != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; <span style="font-weight: bold;">this</span>-&gt;status-&gt;ok()) *<span style="font-weight: bold;">this</span>-&gt;status = s;
    }
  };

  mutex_.AssertHeld();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25171;&#24320;&#26085;&#24535;&#25991;&#20214;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Open the log file</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">fname</span> = LogFileName(dbname_, log_number);
  <span style="font-weight: bold; text-decoration: underline;">SequentialFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status</span> = env_-&gt;NewSequentialFile(fname, &amp;file);
  <span style="font-weight: bold;">if</span> (!status.ok()) {
    MaybeIgnoreError(&amp;status);
    <span style="font-weight: bold;">return</span> status;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26500;&#36896;reporter&#23545;&#35937;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create the log reader.</span>
  <span style="font-weight: bold; text-decoration: underline;">LogReporter</span> <span style="font-weight: bold; font-style: italic;">reporter</span>;
  reporter.env = env_;
  reporter.info_log = options_.info_log;
  reporter.fname = fname.c_str();
  reporter.status = (options_.paranoid_checks ? &amp;status : <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We intentially make log::Reader do checksumming even if</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">paranoid_checks==false so that corruptions cause entire commits</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to be skipped instead of propagating bad information (like overly</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">large sequence numbers).</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462;&#26085;&#24535;&#25991;&#20214;.&#20570;&#26657;&#39564;&#24182;&#19988;&#20174;0&#20559;&#31227;&#24320;&#22987;&#35835;&#21462;.</span>
  <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Reader</span> <span style="font-weight: bold; font-style: italic;">reader</span>(file, &amp;reporter, <span style="font-weight: bold; text-decoration: underline;">true</span><span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">checksum*/</span>,
                     0<span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">initial_offset*/</span>);
  Log(options_.info_log, <span style="font-style: italic;">"Recovering log #%llu"</span>,
      (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) log_number);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read all the records and add to a memtable</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">scratch</span>;
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">record</span>;
  <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span> <span style="font-weight: bold; font-style: italic;">batch</span>;
  <span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">mem</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#26029;&#22320;&#35835;&#21462;</span>
  <span style="font-weight: bold;">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp;
         status.ok()) {
    <span style="font-weight: bold;">if</span> (record.size() &lt; 12) {
      reporter.Corruption(
          record.size(), <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"log record too small"</span>));
      <span style="font-weight: bold;">continue</span>;
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">log&#37324;&#38754;&#37117;&#26159;write batch&#30340;&#20869;&#23481;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#21487;&#20197;&#30452;&#25509;&#35774;&#32622;.</span>
    <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::SetContents(&amp;batch, record);

    <span style="font-weight: bold;">if</span> (mem == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;mem table.</span>
      mem = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">MemTable</span>(internal_comparator_);
      mem-&gt;Ref();
    }
    status = <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::InsertInto(&amp;batch, mem);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#26085;&#24535;&#24674;&#22797;&#30340;&#35805;&#25105;&#20204;&#20063;&#21487;&#20197;&#36873;&#25321;&#24615;&#22320;&#36827;&#34892;status&#21028;&#26029;&#26816;&#26597;.</span>
    MaybeIgnoreError(&amp;status);
    <span style="font-weight: bold;">if</span> (!status.ok()) {
      <span style="font-weight: bold;">break</span>;
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26356;&#26032;sequence.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">last_seq</span> =
        <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::Sequence(&amp;batch) +
        <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::Count(&amp;batch) - 1;
    <span style="font-weight: bold;">if</span> (last_seq &gt; *max_sequence) {
      *max_sequence = last_seq;
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#21344;&#29992;&#20869;&#23384;&#22823;&#20110;&#36825;&#20010;&#22823;&#23567;&#30340;&#35805;&#37027;&#20040;&#23601;&#20250;&#20889;level0.</span>
    <span style="font-weight: bold;">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) {
      status = WriteLevel0Table(mem, edit, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
      <span style="font-weight: bold;">if</span> (!status.ok()) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Reflect errors immediately so that conditions like full</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file-systems cause the DB::Open() to fail.</span>
        <span style="font-weight: bold;">break</span>;
      }
      mem-&gt;Unref();
      mem = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21097;&#19979;&#30340;&#20869;&#23384;&#25991;&#20214;&#20063;&#20250;&#20570;table.</span>
  <span style="font-weight: bold;">if</span> (status.ok() &amp;&amp; mem != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    status = WriteLevel0Table(mem, edit, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Reflect errors immediately so that conditions like full</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file-systems cause the DB::Open() to fail.</span>
  }

  <span style="font-weight: bold;">if</span> (mem != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) mem-&gt;Unref();
  <span style="font-weight: bold;">delete</span> file;
  <span style="font-weight: bold;">return</span> status;
}
</pre>
</div>
</div>
</li>

<li><a id="org7d25a17"></a>MaybeIgnoreError<br />
<div class="outline-text-5" id="text-10-3-3-6">
<p>
这个是在日志恢复部分是否进行错误恢复.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">MaybeIgnoreError</span>(<span style="font-weight: bold; text-decoration: underline;">Status</span>* <span style="font-weight: bold; font-style: italic;">s</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">if</span> (s-&gt;ok() || options_.paranoid_checks) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No change needed</span>
  } <span style="font-weight: bold;">else</span> {
    Log(options_.info_log, <span style="font-style: italic;">"Ignoring error %s"</span>, s-&gt;ToString().c_str());
    *s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org495c4c4"></a>WriteLevel0Table<br />
<div class="outline-text-5" id="text-10-3-3-7">
<p>
将memtable写到level0.不过现在就实现来看的话不一定是写到level0.对于产生或者是删除的文件等
对于version的操作都会反映到edit里面
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">WriteLevel0Table</span>(<span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">mem</span>, <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span>* <span style="font-weight: bold; font-style: italic;">edit</span>,
                                <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">base</span>) {
  mutex_.AssertHeld();
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20250;&#38024;&#23545;&#36825;&#20010;&#25805;&#20316;&#36827;&#34892;&#35745;&#26102;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">start_micros</span> = env_-&gt;NowMicros();
  <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span> <span style="font-weight: bold; font-style: italic;">meta</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20135;&#29983;&#26032;&#30340;file number.</span>
  meta.number = versions_-&gt;NewFileNumber();
  <span style="font-weight: bold; font-style: italic;">//</span>
  pending_outputs_.insert(meta.number);
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">iter</span> = mem-&gt;NewIterator();
  Log(options_.info_log, <span style="font-style: italic;">"Level-0 table #%llu: started"</span>,
      (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) meta.number);

  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
  {
    mutex_.Unlock();
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#20889;&#30913;&#30424;&#30340;&#26102;&#20505;&#27809;&#26377;&#24517;&#35201;&#21152;&#38145;.</span>
    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);
    mutex_.Lock();
  }

  Log(options_.info_log, <span style="font-style: italic;">"Level-0 table #%llu: %lld bytes %s"</span>,
      (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) meta.number,
      (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) meta.file_size,
      s.ToString().c_str());
  <span style="font-weight: bold;">delete</span> iter;
  pending_outputs_.erase(meta.number);


  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note that if file_size is zero, the file has been deleted and</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">should not be added to the manifest.</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0;
  <span style="font-weight: bold;">if</span> (s.ok() &amp;&amp; meta.file_size &gt; 0) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">min_user_key</span> = meta.smallest.user_key();
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">max_user_key</span> = meta.largest.user_key();
    <span style="font-weight: bold;">if</span> (base != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#23384;&#22312;base version&#30340;&#35805;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#20250;&#26681;&#25454;base version&#20197;&#21450;range&#26469;&#36873;&#25321;&#26032;&#30340;level&#36827;&#34892;&#24207;&#21015;&#21270;.</span>
      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);
    }
    edit-&gt;AddFile(level, meta.number, meta.file_size,
                  meta.smallest, meta.largest);
  }

  <span style="font-weight: bold; text-decoration: underline;">CompactionStats</span> <span style="font-weight: bold; font-style: italic;">stats</span>;
  stats.micros = env_-&gt;NowMicros() - start_micros;
  stats.bytes_written = meta.file_size;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#25913;&#36825;&#20010;level&#30340;compaction&#25968;&#25454;.</span>
  stats_[level].Add(stats);
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="org6b7c8d0"></a>Put<br />
<div class="outline-text-5" id="text-10-3-3-8">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">Put</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">o</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">val</span>) {
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">DB</span>::Put(o, key, val);
}
<span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DB</span>::<span style="font-weight: bold;">Put</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">opt</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span> <span style="font-weight: bold; font-style: italic;">batch</span>;
  batch.Put(key, value); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#20869;&#23481;&#20889;&#21040;WriteBatch&#37324;&#38754;.&#28982;&#21518;&#36890;&#36807;</span>
  <span style="font-weight: bold;">return</span> Write(opt, &amp;batch); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Write&#20889;&#20837;&#21040;db&#20869;&#37096;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgeb6af09"></a>Delete<br />
<div class="outline-text-5" id="text-10-3-3-9">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">Delete</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">DB</span>::Delete(options, key);
}
<span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DB</span>::<span style="font-weight: bold;">Delete</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">opt</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span> <span style="font-weight: bold; font-style: italic;">batch</span>;
  batch.Delete(key); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#21024;&#38500;&#20869;&#23481;&#20889;&#21040;WriteBatch&#37324;&#38754;&#65292;&#28982;&#21518;&#36890;&#36807;</span>
  <span style="font-weight: bold;">return</span> Write(opt, &amp;batch); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Write&#20889;&#20837;&#21040;db&#20869;&#37096;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org85836b3"></a>LoggingResponsibility<br />
<div class="outline-text-5" id="text-10-3-3-10">
<p>
对于Log信息的打印的话确保每次只有一个实例在操作.这里logger<sub>cv和mutex</sub><sub>关联起来的.可以看到</sub>
在调用AcquireLoggingResponsibility的地方之前都会加锁
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">There is at most one thread that is the current logger.  This call</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">waits until preceding logger(s) have finished and becomes the</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">current logger.</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">AcquireLoggingResponsibility</span>(<span style="font-weight: bold; text-decoration: underline;">LoggerId</span>* <span style="font-weight: bold; font-style: italic;">self</span>) {
  <span style="font-weight: bold;">while</span> (logger_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    logger_cv_.Wait();
  }
  logger_ = self;
}
</pre>
</div>

<p>
而ReleaseLoggingResponsibility是释放logger的所有权.注意这里我们不会去主动操作解锁而是外部解锁。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">ReleaseLoggingResponsibility</span>(<span style="font-weight: bold; text-decoration: underline;">LoggerId</span>* <span style="font-weight: bold; font-style: italic;">self</span>) {
  assert(logger_ == self);
  logger_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  logger_cv_.SignalAll();
}
</pre>
</div>
</div>
</li>

<li><a id="org32b747a"></a>MakeRoomForWrite<br />
<div class="outline-text-5" id="text-10-3-3-11">
<p>
仅仅从函数名称上面开不出到底是开辟什么空间.看看实现吧.代码里面可以分析出这个部分是存在compaction的.
我们这里稍微总结一下逻辑
</p>
<ul class="org-ul">
<li>如果允许delay的话并且level0文件数目超过slowdown的阈值的话，那么就会先尝试delay 1s.下次不会进行delay</li>
<li>如果不是force的话并且memtable空间允许的话那么直接返回</li>
<li>剩下的逻辑就是force出一个memtable了.那么这个时候必须进行compaction to level0.</li>
<li>先检查是否正在被memtable compaction.如果正在的话那么等待</li>
<li>然后查看level0文件数目是否过多.如果过多的话那么也等待</li>
<li>最后创建新的memtable以及logfile.将原来的memtable保存起来准备后台compaction</li>
<li>发起compaction.并且force=false.</li>
</ul>
<p>
按照性能角度出发的话，这种逻辑应该非常make sense.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: mutex_ is held</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: this thread is the current logger</span>
<span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">MakeRoomForWrite</span>(<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">force</span>) {
  mutex_.AssertHeld();
  assert(logger_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">allow_delay</span> = !force; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#35774;&#32622;force&#30340;&#35805;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#31354;&#38388;&#19981;&#22815;&#30340;&#35805;&#37027;&#20040;&#23601;&#20250;&#21457;&#36215;compaction&#25805;&#20316;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#31561;&#24453;compaction&#25805;&#20316;&#23436;&#25104;&#30475;&#31354;&#38388;&#26159;&#21542;&#36275;&#22815;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
  <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">true</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#21518;&#21488;&#23384;&#22312;&#38169;&#35823;&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;&#36820;&#22238;.</span>
    <span style="font-weight: bold;">if</span> (!bg_error_.ok()) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">yield previous error</span>
      s = bg_error_;
      <span style="font-weight: bold;">break</span>;
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (
        allow_delay &amp;&amp;
        versions_-&gt;NumLevelFiles(0) &gt;= <span style="font-weight: bold; text-decoration: underline;">config</span>::kL0_SlowdownWritesTrigger) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We are getting close to hitting a hard limit on the number of</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">L0 files.  Rather than delaying a single write by several</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">seconds when we hit the hard limit, start delaying each</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">individual write by 1ms to reduce latency variance.  Also,</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">this delay hands over some CPU to the compaction thread in</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">case it is sharing the same core as the writer.</span>
      mutex_.Unlock();
      env_-&gt;SleepForMicroseconds(1000); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24310;&#36831;1s&#26469;&#30475;level0&#25991;&#20214;&#20010;&#25968;.</span>
      allow_delay = <span style="font-weight: bold; text-decoration: underline;">false</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Do not delay a single write more than once</span>
      mutex_.Lock();
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (!force &amp;&amp;
               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;memtable&#20801;&#35768;&#20889;&#20837;&#30340;&#35805;&#37027;&#20040;&#27809;&#26377;&#20219;&#20309;&#38382;&#39064;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">There is room in current memtable</span>
      <span style="font-weight: bold;">break</span>;
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (imm_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We have filled up the current memtable, but the previous</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">one is still being compacted, so we wait.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">imm_&#24212;&#35813;&#26159;&#34920;&#31034;&#27491;&#22312;&#36827;&#34892;compact&#30340;memtable.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#25105;&#25285;&#24515;condition&#26159;&#36793;&#32536;&#35302;&#21457;&#32780;&#19981;&#26159;&#27700;&#24179;&#35302;&#21457;&#30340;&#35805;&#37027;&#20040;signal&#23601;&#20250;&#20002;&#22833;.</span>
      bg_cv_.Wait();
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (versions_-&gt;NumLevelFiles(0) &gt;= <span style="font-weight: bold; text-decoration: underline;">config</span>::kL0_StopWritesTrigger) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">There are too many level-0 files.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">level0&#25991;&#20214;&#20010;&#25968;&#36807;&#22810;&#30340;&#35805;&#37027;&#20040;&#31561;&#24453;compaction&#30340;&#23436;&#25104;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">note:&#36825;&#20010;&#37096;&#20998;&#38750;&#24120;&#37325;&#35201;&#65292;&#36825;&#26679;&#21487;&#20197;&#38480;&#21046;&#20889;&#20837;&#36895;&#24230;&#20445;&#35777;&#31995;&#32479;balance.</span>
      Log(options_.info_log, <span style="font-style: italic;">"waiting...\n"</span>);
      bg_cv_.Wait();
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Attempt to switch to a new memtable and trigger compaction of old</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35797;&#22270;&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;memtable&#29992;&#26469;&#20889;.&#21019;&#24314;memtable&#30340;&#35805;&#21516;&#26102;&#20063;&#21019;&#24314;&#19968;&#20010;log&#25991;&#20214;.</span>
      assert(versions_-&gt;PrevLogNumber() == 0);
      <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">new_log_number</span> = versions_-&gt;NewFileNumber();
      <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">lfile</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);
      <span style="font-weight: bold;">if</span> (!s.ok()) {
        <span style="font-weight: bold;">break</span>;
      }
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38144;&#27585;&#21407;&#26469;&#30340;log&#25991;&#20214;b&#24182;&#19988;&#21019;&#24314;&#26032;&#30340;memtable.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26032;memtable&#23384;&#25918;&#22312;imm&#37324;&#38754;.&#21518;&#21488;&#24212;&#35813;&#26159;&#23558;imm&#36827;&#34892;compaction&#25110;&#32773;&#26159;level disk files&#20043;&#38388;&#36827;&#34892;compaction.</span>
      <span style="font-weight: bold;">delete</span> log_;
      <span style="font-weight: bold;">delete</span> logfile_;
      logfile_ = lfile;
      logfile_number_ = new_log_number;
      log_ = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Writer</span>(lfile);
      imm_ = mem_; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#21407;&#26469;&#30340;mem_&#23384;&#25918;&#36215;&#26469;.</span>
      has_imm_.Release_Store(imm_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">imm&#23384;&#22312;&#26631;&#35760;.</span>
      mem_ = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">MemTable</span>(internal_comparator_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26032;&#21019;&#24314;memtable.</span>
      mem_-&gt;Ref();
      force = <span style="font-weight: bold; text-decoration: underline;">false</span>;   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Do not force another compaction if have room</span>
      MaybeScheduleCompaction(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23581;&#35797;&#36827;&#34892;compaction.&#36825;&#20010;&#20989;&#25968;&#25105;&#20204;&#21518;&#38754;&#20998;&#26512;.</span>
    }
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="orgbeb8b81"></a>MaybeScheduleCompaction<br />
<div class="outline-text-5" id="text-10-3-3-12">
<p>
发起compaction调度.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">MaybeScheduleCompaction</span>() {
  mutex_.AssertHeld();
  <span style="font-weight: bold;">if</span> (bg_compaction_scheduled_) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#24050;&#32463;&#34987;&#35843;&#24230;&#30340;&#35805;.&#37027;&#20040;&#27809;&#26377;&#24517;&#35201;&#20135;&#33021;&#37325;&#26032;&#21457;&#36215;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Already scheduled</span>
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (shutting_down_.Acquire_Load()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#24050;&#32463;&#20851;&#38381;&#30340;&#35805;&#37027;&#20040;&#24573;&#30053;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">DB is being deleted; no more background compactions</span>
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (imm_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;memtable&#27809;&#26377;</span>
             manual_compaction_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#20154;&#24037;compaction</span>
             !versions_-&gt;NeedsCompaction()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;leveldb&#26412;&#36523;&#20063;&#27809;&#26377;&#24517;&#35201;&#35748;&#20026;compaction.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No work to be done</span>
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compaction&#20043;&#21069;&#26631;&#35760;</span>
    bg_compaction_scheduled_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#36825;&#20010;&#26102;&#20505;&#21457;&#36215;compaction&#25805;&#20316;.&#36825;&#20010;&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;BGWork&#36825;&#20010;&#36807;&#31243;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">BGWork&#26159;pthread_create&#23553;&#35013;&#30340;&#25509;&#21475;&#65292;&#37324;&#38754;&#20165;&#20165;&#26159;&#35843;&#29992;&#20102;BackgroundCall&#36825;&#20010;&#20989;&#25968;.</span>
    env_-&gt;Schedule(&amp;<span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::BGWork, <span style="font-weight: bold;">this</span>);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgcd04721"></a>BackgroundCall<br />
<div class="outline-text-5" id="text-10-3-3-13">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">BackgroundCall</span>() {
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  assert(bg_compaction_scheduled_);
  <span style="font-weight: bold;">if</span> (!shutting_down_.Acquire_Load()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#20851;&#38381;&#30340;&#35805;.</span>
    BackgroundCompaction(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#20250;&#35843;&#29992;&#36825;&#20010;&#20989;&#25968;&#21457;&#36215;compaction.</span>
  }
  bg_compaction_scheduled_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Previous compaction may have produced too many files in a level,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">so reschedule another compaction if needed.</span>
  MaybeScheduleCompaction(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#21487;&#33021;&#20250;&#37325;&#26032;&#21457;&#36215;compaction.</span>
  bg_cv_.SignalAll();
}
</pre>
</div>
</div>
</li>

<li><a id="org60e6bf1"></a>BackgroundCompaction<br />
<div class="outline-text-5" id="text-10-3-3-14">
<p>
这个部分是真正进行compaction的部分.我们仔细分析其中的行为.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">BackgroundCompaction</span>() {
  mutex_.AssertHeld();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;&#20195;&#30721;&#23454;&#29616;&#19978;&#26469;&#30475;&#30340;&#35805;&#65292;&#22914;&#26524;&#30495;&#23454;&#22320;&#36827;&#34892;compaction&#30340;&#35805;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;version&#36896;&#25104;&#30340;&#20462;&#25913;&#37117;&#20250;&#35760;&#24405;&#20026;edit,&#28982;&#21518;&#35843;&#29992;VersionSet::LogAndApply&#20445;&#23384;&#36215;&#26469;.</span>
  <span style="font-weight: bold;">if</span> (imm_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    CompactMemTable(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;imm!=NULL&#30340;&#35805;&#37027;&#20040;&#39318;&#20808;&#23545;imm&#36827;&#34892;compaction.</span>
    <span style="font-weight: bold;">return</span>;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;imm_==NULL.</span>
  <span style="font-weight: bold; text-decoration: underline;">Compaction</span>* <span style="font-weight: bold; font-style: italic;">c</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">is_manual</span> = (manual_compaction_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">manual_end</span>;
  <span style="font-weight: bold;">if</span> (is_manual) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;manual compaction&#30340;&#35805;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;compaction&#37324;&#38754;&#38656;&#35201;&#25552;&#20379;level&#20197;&#21450;range.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#26159;&#25105;&#29468;&#24819;&#20165;&#20165;&#26159;&#23558;&#36825;&#20010;compaction&#25552;&#20379;&#19968;&#20010;&#21253;&#35013;&#20449;&#24687;&#20986;&#26469;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20855;&#20307;&#25805;&#20316;&#24310;&#36831;&#21040;&#21518;&#38754;&#36827;&#34892;.</span>
    <span style="font-weight: bold; text-decoration: underline;">ManualCompaction</span>* <span style="font-weight: bold; font-style: italic;">m</span> = manual_compaction_;
    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;begin, m-&gt;end);
    m-&gt;done = (c == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    <span style="font-weight: bold;">if</span> (c != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      manual_end = c-&gt;input(0, c-&gt;num_input_files(0) - 1)-&gt;largest;
    }
    Log(options_.info_log,
        <span style="font-style: italic;">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,
        m-&gt;level,
        (m-&gt;begin ? m-&gt;begin-&gt;DebugString().c_str() : <span style="font-style: italic;">"(begin)"</span>),
        (m-&gt;end ? m-&gt;end-&gt;DebugString().c_str() : <span style="font-style: italic;">"(end)"</span>),
        (m-&gt;done ? <span style="font-style: italic;">"(end)"</span> : manual_end.DebugString().c_str()));
  } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19981;&#26159;manual compaction&#37027;&#20040;&#25361;&#36873;&#19968;&#20010;&#20986;&#26469;.</span>
    c = versions_-&gt;PickCompaction();
  }

  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status</span>;
  <span style="font-weight: bold;">if</span> (c == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Nothing to do</span>
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Move file to next level</span>
    assert(c-&gt;num_input_files(0) == 1);
    <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = c-&gt;input(0, 0);
    c-&gt;edit()-&gt;DeleteFile(c-&gt;level(), f-&gt;number);
    c-&gt;edit()-&gt;AddFile(c-&gt;level() + 1, f-&gt;number, f-&gt;file_size,
                       f-&gt;smallest, f-&gt;largest);
    status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);
    <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold; text-decoration: underline;">LevelSummaryStorage</span> <span style="font-weight: bold; font-style: italic;">tmp</span>;
    Log(options_.info_log, <span style="font-style: italic;">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,
        <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>&gt;(f-&gt;number),
        c-&gt;level() + 1,
        <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>&gt;(f-&gt;file_size),
        status.ToString().c_str(),
        versions_-&gt;LevelSummary(&amp;tmp));
  } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;compaction&#20449;&#24687;&#21253;&#35013;&#31216;&#20026;state&#36827;&#34892;&#25805;&#20316;.</span>
    <span style="font-weight: bold; text-decoration: underline;">CompactionState</span>* <span style="font-weight: bold; font-style: italic;">compact</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">CompactionState</span>(c);
    status = DoCompactionWork(compact);
    CleanupCompaction(compact);
  }
  <span style="font-weight: bold;">delete</span> c;

  <span style="font-weight: bold;">if</span> (status.ok()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Done</span>
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (shutting_down_.Acquire_Load()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Ignore compaction errors found during shutting down</span>
  } <span style="font-weight: bold;">else</span> {
    Log(options_.info_log,
        <span style="font-style: italic;">"Compaction error: %s"</span>, status.ToString().c_str());
    <span style="font-weight: bold;">if</span> (options_.paranoid_checks &amp;&amp; bg_error_.ok()) {
      bg_error_ = status;
    }
  }

  <span style="font-weight: bold;">if</span> (is_manual) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;manual_compaction&#30340;&#35805;&#37027;&#20040;&#25105;&#20204;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26377;&#26041;&#27861;&#21487;&#20197;&#30693;&#36947;&#36825;&#27425;manual compaction&#23454;&#38469;&#25805;&#20316;&#33539;&#22260;&#26377;&#22810;&#23569;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23454;&#38469;&#33539;&#22260;&#23601;&#26159;range&#25152;&#23545;&#24212;&#25991;&#20214;&#30340;largest key.:).&#36825;&#20010;&#20043;&#21069;&#21487;&#20197;&#30475;&#21040;.</span>
    <span style="font-weight: bold; text-decoration: underline;">ManualCompaction</span>* <span style="font-weight: bold; font-style: italic;">m</span> = manual_compaction_;
    <span style="font-weight: bold;">if</span> (!m-&gt;done) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We only compacted part of the requested range.  Update *m</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to the range that is left to be compacted.</span>
      m-&gt;tmp_storage = manual_end;
      m-&gt;begin = &amp;m-&gt;tmp_storage;
    }
    manual_compaction_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org564111b"></a>CompactMemTable<br />
<div class="outline-text-5" id="text-10-3-3-15">
<p>
对memtable进行compaction.注意这里针对的对象是imm<sub>.mem对象是write操作的对象</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">CompactMemTable</span>() {
  mutex_.AssertHeld();
  assert(imm_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Save the contents of the memtable as a new Table</span>
  <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span> <span style="font-weight: bold; font-style: italic;">edit</span>;
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">base</span> = versions_-&gt;current();
  base-&gt;Ref();
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = WriteLevel0Table(imm_, &amp;edit, base);
  base-&gt;Unref();

  <span style="font-weight: bold;">if</span> (s.ok() &amp;&amp; shutting_down_.Acquire_Load()) {
    s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::IOError(<span style="font-style: italic;">"Deleting DB during memtable compaction"</span>);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Replace immutable memtable with the generated Table</span>
  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#26086;&#36825;&#20010;memtable&#36827;&#34892;compaction&#23436;&#25104;&#20043;&#21518;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#23601;&#21487;&#20197;&#35748;&#20026;&#36825;&#20010;log file number&#19981;&#38656;&#35201;&#20102;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20010;&#20449;&#24687;&#35760;&#24405;&#22312;version edit&#37324;&#38754;.</span>
    edit.SetPrevLogNumber(0);
    edit.SetLogNumber(logfile_number_);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Earlier logs no longer needed</span>
    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#37322;&#25918;imm&#36825;&#20010;&#20869;&#23384;&#24182;&#19988;&#21024;&#38500;&#22810;&#20313;&#25991;&#20214;.</span>
  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Commit to the new state</span>
    imm_-&gt;Unref();
    imm_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    has_imm_.Release_Store(<span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    DeleteObsoleteFiles();
  }

  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="org2b0a62a"></a>CompactRange<br />
<div class="outline-text-5" id="text-10-3-3-16">
<p>
这个语义应该是针对某个range来进行compaction的.
</p>
<ul class="org-ul">
<li>首先查看和这些range存在overlap的最大level是多少</li>
<li>首先对memtable进行compaction(不管是否存在overlap)(TEST<sub>CompactMemTable</sub>)</li>
<li>然后遍历这些level,分别对每层进行compact range.(TEST<sub>CompactRange</sub>)</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">CompactRange</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">begin</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">end</span>) {
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">max_level_with_files</span> = 1;
  {
   x MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
    <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">base</span> = versions_-&gt;current();
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 1; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
      <span style="font-weight: bold;">if</span> (base-&gt;OverlapInLevel(level, begin, end)) {
        max_level_with_files = level;
      }
    }
  }
  TEST_CompactMemTable(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO(sanjay): Skip if memtable does not overlap</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; max_level_with_files; level++) {
    TEST_CompactRange(level, begin, end);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgf587d35"></a>TEST<sub>CompactMemTable</sub><br />
<div class="outline-text-5" id="text-10-3-3-17">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">TEST_CompactMemTable</span>() {
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  <span style="font-weight: bold; text-decoration: underline;">LoggerId</span> <span style="font-weight: bold; font-style: italic;">self</span>;
  AcquireLoggingResponsibility(&amp;self);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#24212;&#35813;&#26159;&#35201;&#27714;imm==NULL&#20063;&#23601;&#26159;&#35828;&#27809;&#26377;memtable&#22312;&#36827;&#34892;compaction&#30340;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#36825;&#26679;&#30340;&#34892;&#20026;&#38750;&#24120;&#26126;&#26174;&#23601;&#26159;&#24076;&#26395;mem&#37325;&#26032;&#24320;&#36767;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#21407;&#26469;&#30340;mem&#36827;&#34892;compaction</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = MakeRoomForWrite(<span style="font-weight: bold; text-decoration: underline;">true</span> <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">force compaction */</span>);
  ReleaseLoggingResponsibility(&amp;self);
  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Wait until the compaction completes</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#31561;&#24453;memtable compaction&#32467;&#26463;.</span>
    <span style="font-weight: bold;">while</span> (imm_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; bg_error_.ok()) {
      bg_cv_.Wait();
    }
    <span style="font-weight: bold;">if</span> (imm_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      s = bg_error_;
    }
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="org6a3f54c"></a>TEST<sub>CompactRange</sub><br />
<div class="outline-text-5" id="text-10-3-3-18">
<p>
针对某个Level来进行range compaction.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">TEST_CompactRange</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">begin</span>,<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">end</span>) {
  assert(level &gt;= 0);
  assert(level + 1 &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels);

  <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">begin_storage</span>, <span style="font-weight: bold; font-style: italic;">end_storage</span>;

  <span style="font-weight: bold; text-decoration: underline;">ManualCompaction</span> <span style="font-weight: bold; font-style: italic;">manual</span>;
  manual.level = level; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">level</span>
  manual.done = <span style="font-weight: bold; text-decoration: underline;">false</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21542;&#24050;&#32463;&#23436;&#25104;.</span>
  <span style="font-weight: bold;">if</span> (begin == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36873;&#25321;manual compaction range.</span>
    manual.begin = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  } <span style="font-weight: bold;">else</span> {
    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
    manual.begin = &amp;begin_storage;
  }
  <span style="font-weight: bold;">if</span> (end == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    manual.end = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  } <span style="font-weight: bold;">else</span> {
    end_storage = InternalKey(*end, 0, <span style="font-weight: bold;">static_cast</span>&lt;ValueType&gt;(0));
    manual.end = &amp;end_storage;
  }

  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  <span style="font-weight: bold;">while</span> (!manual.done) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#23436;&#25104;&#30340;&#35805;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31561;&#24453;&#19978;&#19968;&#27425;&#23436;&#25104;</span>
    <span style="font-weight: bold;">while</span> (manual_compaction_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      bg_cv_.Wait();
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31561;&#24453;&#26412;&#27425;&#23436;&#25104;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36824;&#26159;&#35843;&#29992;maybe schedule compaction</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25353;&#29031;&#20195;&#30721;&#26469;&#30475;&#30340;&#35805;&#36208;&#30340;&#20998;&#25903;&#20027;&#35201;&#26159;&#20851;&#27880;VersionSet::CompactRange&#36825;&#20010;&#37096;&#20998;.</span>
    manual_compaction_ = &amp;manual;
    MaybeScheduleCompaction();
    <span style="font-weight: bold;">while</span> (manual_compaction_ == &amp;manual) {
      bg_cv_.Wait();
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org8a8269e"></a>DoCompactionWork<br />
<div class="outline-text-5" id="text-10-3-3-19">
<p>
完成的工作是实质性地Compaction.通过读取提交的CompactionState来完成.过程比较长可以逐段逐段地阅读代码.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">DoCompactionWork</span>(<span style="font-weight: bold; text-decoration: underline;">CompactionState</span>* <span style="font-weight: bold; font-style: italic;">compact</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">start_micros</span> = env_-&gt;NowMicros();
  <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">imm_micros</span> = 0;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Micros spent doing imm_ compactions</span>

  Log(options_.info_log,  <span style="font-style: italic;">"Compacting %d@%d + %d@%d files"</span>,
      compact-&gt;compaction-&gt;num_input_files(0),
      compact-&gt;compaction-&gt;level(),
      compact-&gt;compaction-&gt;num_input_files(1),
      compact-&gt;compaction-&gt;level() + 1);

  assert(versions_-&gt;NumLevelFiles(compact-&gt;compaction-&gt;level()) &gt; 0);
  assert(compact-&gt;builder == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  assert(compact-&gt;outfile == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#26681;&#25454;&#24403;&#21069;&#25152;&#26377;&#25552;&#20132;&#30340;snapshot&#30693;&#36947;&#24403;&#21069;&#26368;&#23567;&#30340;sequence number&#26159;&#22810;&#23569;.</span>
  <span style="font-weight: bold;">if</span> (snapshots_.empty()) {
    compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();
  } <span style="font-weight: bold;">else</span> {
    compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;number_;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Release mutex while we're actually doing the compaction work</span>
  mutex_.Unlock();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38024;&#23545;&#36825;&#20010;compaction&#21019;&#24314;&#20986;iterator.&#25105;&#20204;&#22312;&#21518;&#38754;&#30475;&#30475;&#36825;&#20010;iterator&#26159;&#22914;&#20309;&#24314;&#31435;&#30340;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">input</span> = versions_-&gt;MakeInputIterator(compact-&gt;compaction);
  input-&gt;SeekToFirst();
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status</span>;
  <span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span> <span style="font-weight: bold; font-style: italic;">ikey</span>;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">current_user_key</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">has_current_user_key</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">last_sequence_for_key</span> = kMaxSequenceNumber;
  <span style="font-weight: bold;">for</span> (; input-&gt;Valid() &amp;&amp; !shutting_down_.Acquire_Load(); ) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Prioritize immutable compaction work</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20570;compaction&#20043;&#21069;&#20808;&#23558;immutable table compaction.</span>
    <span style="font-weight: bold;">if</span> (has_imm_.NoBarrier_Load() != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">imm_start</span> = env_-&gt;NowMicros();
      mutex_.Lock();
      <span style="font-weight: bold;">if</span> (imm_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
        CompactMemTable();
        bg_cv_.SignalAll();  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Wakeup MakeRoomForWrite() if necessary</span>
      }
      mutex_.Unlock();
      imm_micros += (env_-&gt;NowMicros() - imm_start);
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;&#22312;&#36825;&#20010;key&#26159;&#21542;&#24212;&#35813;&#29420;&#31435;&#20135;&#29983;&#19968;&#20010;&#25991;&#20214;.</span>
    <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">key</span> = input-&gt;key();
    <span style="font-weight: bold;">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;
        compact-&gt;builder != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      status = FinishCompactionOutputFile(compact, input);
      <span style="font-weight: bold;">if</span> (!status.ok()) {
        <span style="font-weight: bold;">break</span>;
      }
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Handle key/value, add to state, etc.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">drop&#34920;&#31034;&#36825;&#20010;key&#26159;&#21542;&#24212;&#35813;&#30452;&#25509;&#20002;&#24323;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#22320;&#26041;&#22987;&#32456;&#24863;&#35273;&#26377;&#28857;&#38382;&#39064;.&#20026;&#20160;&#20040;&#35745;&#31639;last seuqnce number&#21602;?.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#36807;&#22823;&#33268;&#24605;&#24819;&#26159;&#20102;&#35299;&#30340;.</span>
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">drop</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
    <span style="font-weight: bold;">if</span> (!ParseInternalKey(key, &amp;ikey)) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Do not hide error keys</span>
      current_user_key.clear();
      has_current_user_key = <span style="font-weight: bold; text-decoration: underline;">false</span>;
      last_sequence_for_key = kMaxSequenceNumber;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold;">if</span> (!has_current_user_key ||
          user_comparator()-&gt;Compare(ikey.user_key,
                                     Slice(current_user_key)) != 0) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">First occurrence of this user key</span>
        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());
        has_current_user_key = <span style="font-weight: bold; text-decoration: underline;">true</span>;
        last_sequence_for_key = kMaxSequenceNumber;
      }
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#27573;&#36923;&#36753;&#21028;&#26029;&#26159;&#21542;&#38656;&#35201;&#20002;&#24323;.</span>
      <span style="font-weight: bold;">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Hidden by an newer entry for same user key</span>
        drop = <span style="font-weight: bold; text-decoration: underline;">true</span>;    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(A)</span>
      } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (ikey.type == kTypeDeletion &amp;&amp; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;&#21024;&#38500;&#24182;&#19988;&#36825;&#20010;key &lt; snapshot.</span>
                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;
                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For this user key:</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(1) there is no data in higher levels</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(2) data in lower levels will have larger sequence numbers</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(3) data in layers that are being compacted here and have</span>
        <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">smaller sequence numbers will be dropped in the next</span>
        <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">few iterations of this loop (by rule (A) above).</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Therefore this deletion marker is obsolete and can be dropped.</span>
        drop = <span style="font-weight: bold; text-decoration: underline;">true</span>;
      }

      last_sequence_for_key = ikey.sequence;
    }
<span style="font-weight: bold;">#if</span> 0
    Log(options_.info_log,
        <span style="font-style: italic;">"  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, "</span>
        <span style="font-style: italic;">"%d smallest_snapshot: %d"</span>,
        ikey.user_key.ToString().c_str(),
        (<span style="font-weight: bold; text-decoration: underline;">int</span>)ikey.sequence, ikey.type, kTypeValue, drop,
        compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key),
        (<span style="font-weight: bold; text-decoration: underline;">int</span>)last_sequence_for_key, (<span style="font-weight: bold; text-decoration: underline;">int</span>)compact-&gt;smallest_snapshot);
<span style="font-weight: bold;">#endif</span>

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#31649;&#21069;&#38754;&#32454;&#33410;&#22914;&#20309;&#21040;&#36825;&#20010;&#27493;&#39588;&#34920;&#26126;&#36825;&#20010;kv&#27809;&#26377;&#34987;drop&#25481;.</span>
    <span style="font-weight: bold;">if</span> (!drop) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Open output file if necessary</span>
      <span style="font-weight: bold;">if</span> (compact-&gt;builder == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454;compaction&#29366;&#24577;&#20135;&#29983;&#26032;&#36755;&#20986;&#25991;&#20214;.</span>
        status = OpenCompactionOutputFile(compact);
        <span style="font-weight: bold;">if</span> (!status.ok()) {
          <span style="font-weight: bold;">break</span>;
        }
      }
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">==0&#30340;&#26102;&#20505;&#35760;&#24405;&#26368;&#23567;key.</span>
      <span style="font-weight: bold;">if</span> (compact-&gt;builder-&gt;NumEntries() == 0) {
        compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);
      }
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20043;&#21518;&#27599;&#27425;&#26356;&#26032;&#26368;&#22823;key</span>
      compact-&gt;current_output()-&gt;largest.DecodeFrom(key);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35760;&#24405;&#36825;&#20010;kv.</span>
      compact-&gt;builder-&gt;Add(key, input-&gt;value());

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Close output file if it is big enough</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#25991;&#20214;&#36229;&#36807;&#22823;&#23567;&#30340;&#35805;&#37027;&#20040;&#38656;&#35201;&#20999;&#25442;&#25991;&#20214;.</span>
      <span style="font-weight: bold;">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=
          compact-&gt;compaction-&gt;MaxOutputFileSize()) {
        status = FinishCompactionOutputFile(compact, input);
        <span style="font-weight: bold;">if</span> (!status.ok()) {
          <span style="font-weight: bold;">break</span>;
        }
      }
    }

    input-&gt;Next();
  }

  <span style="font-weight: bold;">if</span> (status.ok() &amp;&amp; shutting_down_.Acquire_Load()) {
    status = <span style="font-weight: bold; text-decoration: underline;">Status</span>::IOError(<span style="font-style: italic;">"Deleting DB during compaction"</span>);
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#21518;&#21487;&#33021;&#38656;&#35201;&#20851;&#38381;compaction&#30340;&#25991;&#20214;.</span>
  <span style="font-weight: bold;">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    status = FinishCompactionOutputFile(compact, input);
  }
  <span style="font-weight: bold;">if</span> (status.ok()) {
    status = input-&gt;status();
  }
  <span style="font-weight: bold;">delete</span> input; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21024;&#38500;&#36825;&#20010;iterator.</span>
  input = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

  <span style="font-weight: bold; text-decoration: underline;">CompactionStats</span> <span style="font-weight: bold; font-style: italic;">stats</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compaction&#37096;&#20998;&#30340;&#26102;&#38388;&#36824;&#38656;&#35201;&#20986;&#21435;&#20869;&#23384;memtable compaction&#26159;&#26102;&#38388;.</span>
  stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32479;&#35745;&#36825;&#27425;&#25805;&#20316;&#35835;&#21462;&#30340;&#22823;&#23567;.</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">which</span> = 0; which &lt; 2; which++) {
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) {
      stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;
    }
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32479;&#35745;&#36825;&#27425;&#25805;&#20316;&#20889;&#30913;&#30424;&#22823;&#23567;.</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; compact-&gt;outputs.size(); i++) {
    stats.bytes_written += compact-&gt;outputs[i].file_size;
  }

  mutex_.Lock();
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20010;&#29366;&#24577;&#21512;&#24182;&#19978;&#26469;.</span>
  stats_[compact-&gt;compaction-&gt;level() + 1].Add(stats);

  <span style="font-weight: bold;">if</span> (status.ok()) {
    status = InstallCompactionResults(compact);
  }
  <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold; text-decoration: underline;">LevelSummaryStorage</span> <span style="font-weight: bold; font-style: italic;">tmp</span>;
  Log(options_.info_log,
      <span style="font-style: italic;">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));
  <span style="font-weight: bold;">return</span> status;
}
</pre>
</div>
</div>
</li>

<li><a id="org40e6c65"></a>CleanupCompaction<br />
<div class="outline-text-5" id="text-10-3-3-20">
<p>
完成compaction之后的工作.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">CleanupCompaction</span>(<span style="font-weight: bold; text-decoration: underline;">CompactionState</span>* <span style="font-weight: bold; font-style: italic;">compact</span>) {
  mutex_.AssertHeld();
  <span style="font-weight: bold;">if</span> (compact-&gt;builder != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36825;&#20010;builder&#27809;&#26377;&#38144;&#27585;&#30340;&#35805;&#37027;&#20040;&#35748;&#20026;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20013;&#36884;&#26159;shutdown&#20102;.&#37027;&#20040;&#25105;&#20204;&#36825;&#37324;&#30452;&#25509;abandon&#25481;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">May happen if we get a shutdown call in the middle of compaction</span>
    compact-&gt;builder-&gt;Abandon();
    <span style="font-weight: bold;">delete</span> compact-&gt;builder;
  } <span style="font-weight: bold;">else</span> {
    assert(compact-&gt;outfile == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  }
  <span style="font-weight: bold;">delete</span> compact-&gt;outfile;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compaction&#36807;&#31243;&#20013;&#30340;&#35805;&#26032;&#36755;&#20986;&#30340;output&#25991;&#20214;&#24212;&#35813;&#37117;&#21152;&#20837;&#20102;pengding_outputs</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38450;&#27490;&#36825;&#20010;&#25991;&#20214;&#37096;&#20998;&#34987;&#21024;&#38500;.&#23436;&#25104;compaction&#20043;&#21518;&#30340;&#35805;&#21487;&#20197;&#31227;&#38500;&#20102;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32771;&#34385;&#36825;&#37324;&#22806;&#37096;&#24212;&#35813;&#26377;&#26631;&#35760;&#36890;&#30693;&#36825;&#20123;&#25991;&#20214;&#36824;&#26159;&#38656;&#35201;&#30340;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#38024;&#23545;&#36825;&#20123;&#25991;&#20214;&#21487;&#33021;&#24050;&#32463;&#21019;&#24314;&#20102;&#21478;&#22806;&#19968;&#20010;version&#23545;&#35937;&#23384;&#25918;&#22312;version_set&#20869;&#37096;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#26159;&#21861;&#26102;&#20505;&#37322;&#25918;version&#36825;&#20010;&#23545;&#35937;&#21602;???.</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; compact-&gt;outputs.size(); i++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">CompactionState</span>::<span style="font-weight: bold; text-decoration: underline;">Output</span>&amp; <span style="font-weight: bold; font-style: italic;">out</span> = compact-&gt;outputs[i];
    pending_outputs_.erase(out.number);
  }
  <span style="font-weight: bold;">delete</span> compact;
}
</pre>
</div>
</div>
</li>

<li><a id="orge611912"></a>InstallCompactionResults<br />
<div class="outline-text-5" id="text-10-3-3-21">
<p>
这个函数调用过程是在DoCompactionWork里面.大致工作就是将这次compaction工作内容作为日志保存起来.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">InstallCompactionResults</span>(<span style="font-weight: bold; text-decoration: underline;">CompactionState</span>* <span style="font-weight: bold; font-style: italic;">compact</span>) {
  mutex_.AssertHeld();
  Log(options_.info_log,  <span style="font-style: italic;">"Compacted %d@%d + %d@%d files =&gt; %lld bytes"</span>,
      compact-&gt;compaction-&gt;num_input_files(0),
      compact-&gt;compaction-&gt;level(),
      compact-&gt;compaction-&gt;num_input_files(1),
      compact-&gt;compaction-&gt;level() + 1,
      <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>&gt;(compact-&gt;total_bytes));

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add compaction outputs</span>
  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;compaction&#36825;&#27425;&#25805;&#20316;&#21024;&#38500;&#21644;&#22686;&#21152;&#25991;&#20214;&#21152;&#20837;version_edit.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = compact-&gt;compaction-&gt;level();
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; compact-&gt;outputs.size(); i++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">CompactionState</span>::<span style="font-weight: bold; text-decoration: underline;">Output</span>&amp; <span style="font-weight: bold; font-style: italic;">out</span> = compact-&gt;outputs[i];
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#26412;&#22320;&#25805;&#20316;&#25918;&#22312;version_edit&#37324;&#38754;.</span>
    compact-&gt;compaction-&gt;edit()-&gt;AddFile(
        level + 1,
        out.number, out.file_size, out.smallest, out.largest);
    pending_outputs_.erase(out.number); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;pending output&#37324;&#38754;&#21024;&#38500;.</span>
  }
  compact-&gt;outputs.clear();

  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36890;&#30693;version set&#26412;&#27425;&#20462;&#25913;&#20869;&#23481;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#23558;&#36825;&#27425;compaction&#30340;&#20869;&#23481;&#20316;&#20026;version&#20889;&#20837;log&#37324;&#38754;&#21435;.</span>
  <span style="font-weight: bold;">if</span> (s.ok()) {
    compact-&gt;compaction-&gt;ReleaseInputs();
    DeleteObsoleteFiles();
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Discard any files we may have created during this failed compaction</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; compact-&gt;outputs.size(); i++) {
      env_-&gt;DeleteFile(TableFileName(dbname_, compact-&gt;outputs[i].number));
    }
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="org74a2817"></a>OpenCompactionOutputFile<br />
<div class="outline-text-5" id="text-10-3-3-22">
<p>
打开用于compaction输出的文件.倒不是非常麻烦.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">OpenCompactionOutputFile</span>(<span style="font-weight: bold; text-decoration: underline;">CompactionState</span>* <span style="font-weight: bold; font-style: italic;">compact</span>) {
  assert(compact != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  assert(compact-&gt;builder == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_number</span>;
  {
    mutex_.Lock();
    file_number = versions_-&gt;NewFileNumber();
    pending_outputs_.insert(file_number); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25918;&#22312;pending output&#37324;&#38754;.</span>
    <span style="font-weight: bold; text-decoration: underline;">CompactionState</span>::<span style="font-weight: bold; text-decoration: underline;">Output</span> <span style="font-weight: bold; font-style: italic;">out</span>;
    out.number = file_number;
    out.smallest.Clear();
    out.largest.Clear();
    compact-&gt;outputs.push_back(out);
    mutex_.Unlock();
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Make the output file</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#36755;&#20986;&#25991;&#20214;&#20197;&#21450;&#23545;&#24212;&#30340;table builder.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">fname</span> = TableFileName(dbname_, file_number);
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = env_-&gt;NewWritableFile(fname, &amp;compact-&gt;outfile);
  <span style="font-weight: bold;">if</span> (s.ok()) {
    compact-&gt;builder = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>(options_, compact-&gt;outfile);
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="org2b42aa9"></a>FinishCompactionOutputFile<br />
<div class="outline-text-5" id="text-10-3-3-23">
<p>
对于输出了文件之后我们需要finish的操作.倒不是非常麻烦.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">FinishCompactionOutputFile</span>(<span style="font-weight: bold; text-decoration: underline;">CompactionState</span>* <span style="font-weight: bold; font-style: italic;">compact</span>,
                                          <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">input</span>) {
  assert(compact != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  assert(compact-&gt;outfile != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  assert(compact-&gt;builder != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);

  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">output_number</span> = compact-&gt;current_output()-&gt;number;
  assert(output_number != 0);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Check for iterator errors</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = input-&gt;status();
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">current_entries</span> = compact-&gt;builder-&gt;NumEntries();
  <span style="font-weight: bold;">if</span> (s.ok()) {
    s = compact-&gt;builder-&gt;Finish(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36890;&#30693;&#23545;&#24212;&#30340;builder&#23545;&#35937;finish.</span>
  } <span style="font-weight: bold;">else</span> {
    compact-&gt;builder-&gt;Abandon();
  }
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">current_bytes</span> = compact-&gt;builder-&gt;FileSize();
  compact-&gt;current_output()-&gt;file_size = current_bytes;
  compact-&gt;total_bytes += current_bytes;
  <span style="font-weight: bold;">delete</span> compact-&gt;builder; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37322;&#25918;&#21407;&#26469;builder.</span>
  compact-&gt;builder = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Finish and check for file errors</span>
  <span style="font-weight: bold;">if</span> (s.ok()) {
    s = compact-&gt;outfile-&gt;Sync();
  }
  <span style="font-weight: bold;">if</span> (s.ok()) {
    s = compact-&gt;outfile-&gt;Close();
  }
  <span style="font-weight: bold;">delete</span> compact-&gt;outfile; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37322;&#25918;&#21407;&#26469;&#30340;file&#23545;&#35937;.</span>
  compact-&gt;outfile = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39564;&#35777;&#36825;&#20010;&#25991;&#20214;&#26159;&#21542;OK.</span>
  <span style="font-weight: bold;">if</span> (s.ok() &amp;&amp; current_entries &gt; 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Verify that the table is usable</span>
    <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">iter</span> = table_cache_-&gt;NewIterator(ReadOptions(),
                                               output_number,
                                               current_bytes);
    s = iter-&gt;status();
    <span style="font-weight: bold;">delete</span> iter;
    <span style="font-weight: bold;">if</span> (s.ok()) {
      Log(options_.info_log,
          <span style="font-style: italic;">"Generated table #%llu: %lld keys, %lld bytes"</span>,
          (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) output_number,
          (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) current_entries,
          (<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>) current_bytes);
    }
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="orgf0d05ed"></a>Write<br />
<div class="outline-text-5" id="text-10-3-3-24">
<p>
这个是Put/Delete底层的最终实现.仔细看看吧
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">Write</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>, <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>* <span style="font-weight: bold; font-style: italic;">updates</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status</span>;
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  <span style="font-weight: bold; text-decoration: underline;">LoggerId</span> <span style="font-weight: bold; font-style: italic;">self</span>;
  AcquireLoggingResponsibility(&amp;self);
  status = MakeRoomForWrite(<span style="font-weight: bold; text-decoration: underline;">false</span>);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">May temporarily release lock and wait</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">last_sequence</span> = versions_-&gt;LastSequence(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197;sequence.</span>
  <span style="font-weight: bold;">if</span> (status.ok()) {
    <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::SetSequence(updates, last_sequence + 1); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">WriteBatch&#30340;sequence&#20174;+1&#24320;&#22987;.</span>
    last_sequence += <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::Count(updates); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26356;&#26032;&#19978;&#27425;sequence.</span>

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add to log and apply to memtable.  We can release the lock during</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">this phase since the "logger_" flag protects against concurrent</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">loggers and concurrent writes into mem_.</span>
    {
      assert(logger_ == &amp;self);
      mutex_.Unlock();
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#37096;&#20998;&#26159;&#32943;&#23450;&#38656;&#35201;&#20889;&#20837;log&#30340;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#37322;&#25918;&#38145;&#26159;&#27809;&#26377;&#38382;&#39064;&#65292;&#22240;&#20026;&#36825;&#20010;&#22320;&#26041;logger&#21487;&#20197;&#20316;&#20026;&#38145;&#23384;&#22312;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#35299;&#24320;mutex&#20284;&#20046;&#21487;&#20197;&#20351;&#24471;Get&#36827;&#34892;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25105;&#35273;&#24471;&#31532;&#19968;&#36941;&#30475;leveldb&#20195;&#30721;&#30340;&#26102;&#20505;&#21487;&#20197;&#25735;&#24320;&#24182;&#21457;&#36825;&#20010;&#37096;&#20998;.</span>
      status = log_-&gt;AddRecord(<span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::Contents(updates)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;updates&#30340;&#20869;&#23481;&#20316;&#20026;contents&#24471;&#21040;&#20889;&#20837;log.</span>
      <span style="font-weight: bold;">if</span> (status.ok() &amp;&amp; options.sync) {
        status = logfile_-&gt;Sync();
      }
      <span style="font-weight: bold;">if</span> (status.ok()) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23558;updates&#20889;&#20837;memtable.</span>
        status = <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::InsertInto(updates, mem_);
      }
      mutex_.Lock();
      assert(logger_ == &amp;self);
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20889;&#20837;&#25104;&#21151;&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#23558;&#36825;&#20010;sequence&#37325;&#26032;&#20889;&#22238;.</span>
    versions_-&gt;SetLastSequence(last_sequence); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;&#26032;&#30340;sequence.</span>
  }
  ReleaseLoggingResponsibility(&amp;self);
  <span style="font-weight: bold;">return</span> status;
}
</pre>
</div>
</div>
</li>

<li><a id="orge42dadc"></a>SanitizeOptions<br />
<div class="outline-text-5" id="text-10-3-3-25">
<p>
这个函数应该就是规范一下options这个结构.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fix user-supplied options to be reasonable</span>
<span style="font-weight: bold;">template</span> &lt;<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">T</span>,<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">V</span>&gt;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ClipToRange</span>(<span style="font-weight: bold; text-decoration: underline;">T</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>, <span style="font-weight: bold; text-decoration: underline;">V</span> <span style="font-weight: bold; font-style: italic;">minvalue</span>, <span style="font-weight: bold; text-decoration: underline;">V</span> <span style="font-weight: bold; font-style: italic;">maxvalue</span>) {
  <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">V</span>&gt;(*ptr) &gt; maxvalue) *ptr = maxvalue;
  <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">V</span>&gt;(*ptr) &lt; minvalue) *ptr = minvalue;
}
<span style="font-weight: bold; text-decoration: underline;">Options</span> <span style="font-weight: bold;">SanitizeOptions</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>,
                        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>* <span style="font-weight: bold; font-style: italic;">icmp</span>,
                        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">src</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Options</span> <span style="font-weight: bold; font-style: italic;">result</span> = src;
  result.comparator = icmp;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35268;&#33539;&#21462;&#20540;&#33539;&#22260;.</span>
  ClipToRange(&amp;result.max_open_files,           20,     50000); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">20 , 50000</span>
  ClipToRange(&amp;result.write_buffer_size,        64&lt;&lt;10, 1&lt;&lt;30); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">64K , 1G</span>
  ClipToRange(&amp;result.block_size,               1&lt;&lt;10,  4&lt;&lt;20); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1K, 4M.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#29992;&#25143;&#27809;&#26377;&#22635;&#20889;logger&#23545;&#35937;&#30340;&#35805;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#20135;&#29983;&#19968;&#20010;logger&#23545;&#35937;.</span>
  <span style="font-weight: bold;">if</span> (result.info_log == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Open a log file in the same directory as the db</span>
    src.env-&gt;CreateDir(dbname);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">In case it does not exist</span>
    src.env-&gt;RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = src.env-&gt;NewLogger(InfoLogFileName(dbname), &amp;result.info_log);
    <span style="font-weight: bold;">if</span> (!s.ok()) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No place suitable for logging</span>
      result.info_log = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    }
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;block cache&#20063;&#26159;.&#24320;&#36767;&#30340;block cache&#22823;&#23567;8MB.</span>
  <span style="font-weight: bold;">if</span> (result.block_cache == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    result.block_cache = NewLRUCache(8 &lt;&lt; 20);
  }
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</li>

<li><a id="orga4a7b10"></a>GetProperty<br />
<div class="outline-text-5" id="text-10-3-3-26">
<p>
关于db的属性信息.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">GetProperty</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">property</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">value</span>) {
  value-&gt;clear();

  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">in</span> = property;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23646;&#24615;&#30340;key&#24517;&#39035;&#26159;&#20197;leveldb.&#24320;&#22836;&#30340;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">prefix</span>(<span style="font-style: italic;">"leveldb."</span>);
  <span style="font-weight: bold;">if</span> (!in.starts_with(prefix)) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  in.remove_prefix(prefix.size());

  <span style="font-weight: bold;">if</span> (in.starts_with(<span style="font-style: italic;">"num-files-at-level"</span>)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010;level&#30340;&#25991;&#20214;&#25968;&#30446;.</span>
    in.remove_prefix(strlen(<span style="font-style: italic;">"num-files-at-level"</span>));
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">level</span>;
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">ok</span> = ConsumeDecimalNumber(&amp;in, &amp;level) &amp;&amp; in.empty();
    <span style="font-weight: bold;">if</span> (!ok || level &gt;= <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels) {
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[100];
      snprintf(buf, <span style="font-weight: bold;">sizeof</span>(buf), <span style="font-style: italic;">"%d"</span>,
               versions_-&gt;NumLevelFiles(<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;(level)));
      *value = buf;
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
    }
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (in == <span style="font-style: italic;">"stats"</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25972;&#20010;db&#30340;&#29366;&#24577;.</span>
    <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[200];
    snprintf(buf, <span style="font-weight: bold;">sizeof</span>(buf),
             <span style="font-style: italic;">"                               Compactions\n"</span>
             <span style="font-style: italic;">"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n"</span>
             <span style="font-style: italic;">"--------------------------------------------------\n"</span>
             );
    value-&gt;append(buf);
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">files</span> = versions_-&gt;NumLevelFiles(level);
      <span style="font-weight: bold;">if</span> (stats_[level].micros &gt; 0 || files &gt; 0) {
        snprintf(
            buf, <span style="font-weight: bold;">sizeof</span>(buf),
            <span style="font-style: italic;">"%3d %8d %8.0f %9.0f %8.0f %9.0f\n"</span>,
            level,
            files,
            versions_-&gt;NumLevelBytes(level) / 1048576.0,
            stats_[level].micros / 1e6, <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#36825;&#20010;level&#19978;&#38754;&#25805;&#20316;&#30340;&#26102;&#38388;.</span>
            stats_[level].bytes_read / 1048576.0, <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#36825;&#20010;level&#19978;&#38754;&#35835;&#21462;&#30340;&#23383;&#33410;&#25968;&#30446;.</span>
            stats_[level].bytes_written / 1048576.0); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#36825;&#20010;level&#19978;&#38754;&#20889;&#20837;&#30340;&#23383;&#33410;&#25968;&#30446;.</span>
        value-&gt;append(buf);
      }
    }
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (in == <span style="font-style: italic;">"sstables"</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;sstables&#30340;&#29366;&#24577;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#26159;Version&#25171;&#21360;&#20986;&#30340;&#23383;&#31526;&#20018;.</span>
    *value = versions_-&gt;current()-&gt;DebugString();
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }

  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
}
</pre>
</div>
</div>
</li>

<li><a id="org2520fca"></a>GetApproximateSizes<br />
<div class="outline-text-5" id="text-10-3-3-27">
<p>
得到某个Range占用的大小.底层依赖于VersionSet
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">GetApproximateSizes</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Range</span>* <span style="font-weight: bold; font-style: italic;">range</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>,
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span>* <span style="font-weight: bold; font-style: italic;">sizes</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO(opt): better implementation</span>
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span>;
  {
    MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#26159;&#20840;&#23616;&#21152;&#38145;&#30340;.</span>
    versions_-&gt;current()-&gt;Ref(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#24403;&#21069;version&#21152;&#19978;&#24341;&#29992;&#35745;&#25968;.</span>
    v = versions_-&gt;current();
  }

  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Convert user_key into a corresponding internal key.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;sequence number&#26159;&#21542;&#27491;&#30830;&#21602;?</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#36807;&#22823;&#33268;&#19978;&#21344;&#29992;&#30340;&#31354;&#38388;&#24046;&#19981;&#22810;&#23601;&#26159;&#36825;&#20040;&#22823;.</span>
    <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">k1</span>(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
    <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">k2</span>(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20855;&#20307;&#23454;&#29616;&#21487;&#20197;&#26597;&#30475;VersionSet&#26041;&#27861;.&#26681;&#25454;&#26576;&#20010;key&#21028;&#26029;&#36825;&#20010;key&#22312;&#25991;&#20214;&#20013;&#30340;&#20559;&#31227;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21487;&#33021;&#20250;&#26377;&#19968;&#37096;&#20998;&#20559;&#24046;&#21543;&#20294;&#26159;&#22823;&#33268;&#27491;&#30830;.</span>
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">start</span> = versions_-&gt;ApproximateOffsetOf(v, k1);
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">limit</span> = versions_-&gt;ApproximateOffsetOf(v, k2);
    sizes[i] = (limit &gt;= start ? limit - start : 0);
  }

  {
    MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
    v-&gt;Unref();
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgb552e0f"></a>GetSnapshot<br />
<div class="outline-text-5" id="text-10-3-3-28">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Snapshot</span>* <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">GetSnapshot</span>() {
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36820;&#22238;&#26368;&#26032;&#30340;sequence number&#21019;&#24314;&#19968;&#20010;Snapshot&#23454;&#20363;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#28155;&#21152;&#21040;snapshot list&#37324;&#38754;.</span>
  <span style="font-weight: bold;">return</span> snapshots_.New(versions_-&gt;LastSequence());
}
</pre>
</div>
</div>
</li>

<li><a id="org6d0455e"></a>ReleaseSnapshot<br />
<div class="outline-text-5" id="text-10-3-3-29">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">ReleaseSnapshot</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Snapshot</span>* <span style="font-weight: bold; font-style: italic;">s</span>) {
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;snapshot list&#37324;&#38754;&#21024;&#38500;.</span>
  snapshots_.Delete(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>*&gt;(s));
}
</pre>
</div>
</div>
</li>

<li><a id="orgb2e381f"></a>DeleteObsoleteFiles<br />
<div class="outline-text-5" id="text-10-3-3-30">
<p>
根据当前所有version所持有的file来决定哪些文件是不再需要的.version里面会持有file meta信息.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">DeleteObsoleteFiles</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Make a set of all of the live files</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">set</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt; <span style="font-weight: bold; font-style: italic;">live</span> = pending_outputs_;
  versions_-&gt;AddLiveFiles(&amp;live); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25345;&#26377;pending outputs&#37324;&#38754;&#27491;&#22312;&#36755;&#20986;&#30340;&#25991;&#20214;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#23558;verisons&#37324;&#38754;&#25152;&#26377;version&#25345;&#26377;&#30340;&#25991;&#20214;&#24471;&#21040;.</span>

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">std</span>::string&gt; <span style="font-weight: bold; font-style: italic;">filenames</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36941;&#21382;&#24403;&#21069;&#30446;&#24405;&#19979;&#38754;&#30340;&#25991;&#20214;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#25991;&#20214;&#25968;&#30446;&#19981;&#20250;&#36807;&#22810;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;&#36890;&#24120;&#26469;&#35828;&#27599;&#20010;level&#25991;&#20214;&#37117;&#20250;&#26377;&#19968;&#20010;&#19979;&#38480;&#22823;&#23567;&#25968;&#30446;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32780;&#27599;&#20010;level&#30340;bytes&#26377;&#19968;&#20010;&#38480;&#21046;.&#23545;&#20110;&#26368;&#39640;&#23618;&#30340;level&#30340;&#35805;&#37027;&#20040;&#25991;&#20214;&#24050;&#32463;&#38750;&#24120;&#22823;&#20102;:)</span>
  env_-&gt;GetChildren(dbname_, &amp;filenames); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Ignoring errors on purpose</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">number</span>;
  <span style="font-weight: bold; text-decoration: underline;">FileType</span> <span style="font-weight: bold; font-style: italic;">type</span>;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; filenames.size(); i++) {
    <span style="font-weight: bold;">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) {
      <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">keep</span> = <span style="font-weight: bold; text-decoration: underline;">true</span>;
      <span style="font-weight: bold;">switch</span> (type) {
        <span style="font-weight: bold;">case</span> kLogFile:
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;log&#25991;&#20214;&#30340;number&#26159;&#25353;&#29031;&#39034;&#24207;&#20998;&#37197;&#30340;.</span>
          keep = ((number &gt;= versions_-&gt;LogNumber()) || <span style="font-weight: bold; font-style: italic;">//</span>
                  (number == versions_-&gt;PrevLogNumber())); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">prev log number&#24050;&#32463;&#27809;&#26377;&#24517;&#35201;&#20102;.</span>
          <span style="font-weight: bold;">break</span>;
        <span style="font-weight: bold;">case</span> kDescriptorFile:
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Keep my manifest file, and any newer incarnations'</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(in case there is a race that allows other incarnations)</span>
          keep = (number &gt;= versions_-&gt;ManifestFileNumber());
          <span style="font-weight: bold;">break</span>;
        <span style="font-weight: bold;">case</span> kTableFile:
          keep = (live.find(number) != live.end()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;&#36825;&#20010;&#25991;&#20214;&#26159;&#21542;&#38656;&#35201;&#21024;&#38500;.</span>
          <span style="font-weight: bold;">break</span>;
        <span style="font-weight: bold;">case</span> kTempFile:
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Any temp files that are currently being written to must</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">be recorded in pending_outputs_, which is inserted into "live"</span>
          keep = (live.find(number) != live.end()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;&#25991;&#20214;&#26159;&#21542;&#38656;&#35201;&#21024;&#38500;.</span>
          <span style="font-weight: bold;">break</span>;
        <span style="font-weight: bold;">case</span> kCurrentFile:
        <span style="font-weight: bold;">case</span> kDBLockFile:
        <span style="font-weight: bold;">case</span> kInfoLogFile:
          keep = <span style="font-weight: bold; text-decoration: underline;">true</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#20854;&#20182;&#25991;&#20214;&#30340;&#35805;&#30452;&#25509;keep&#20303;&#23601;&#22909;&#20102;.</span>
          <span style="font-weight: bold;">break</span>;
      }

      <span style="font-weight: bold;">if</span> (!keep) {
        <span style="font-weight: bold;">if</span> (type == kTableFile) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;table&#25991;&#20214;&#30340;&#35805;&#36824;&#38656;&#35201;&#20174;cache&#37324;&#38754;&#21435;&#25481;.</span>
          table_cache_-&gt;Evict(number);
        }
        Log(options_.info_log, <span style="font-style: italic;">"Delete type=%d #%lld\n"</span>,
            <span style="font-weight: bold; text-decoration: underline;">int</span>(<span style="font-weight: bold; font-style: italic;">type</span>),
            <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span>&gt;(number));
        env_-&gt;DeleteFile(dbname_ + <span style="font-style: italic;">"/"</span> + filenames[i]); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#21024;&#38500;&#25991;&#20214;.</span>
      }
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org3dd1114"></a>Get<br />
<div class="outline-text-5" id="text-10-3-3-31">
<p>
Get的过程非常简单.因为实际Get的过程已经托管为Version::Get这个方法了.这里面我们只需要
构造出正确的seuqnce number,和user key拼接成为internal key即可.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">Get</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                   <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>,
                   <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">snapshot</span>;
  <span style="font-weight: bold;">if</span> (options.snapshot != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;&#24403;&#21069;&#35835;&#21462;&#26159;&#21542;&#38656;&#35201;snapshot.</span>
    snapshot = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>*&gt;(options.snapshot)-&gt;number_;
  } <span style="font-weight: bold;">else</span> {
    snapshot = versions_-&gt;LastSequence();
  }

  <span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">mem</span> = mem_;
  <span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">imm</span> = imm_;
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">current</span> = versions_-&gt;current();
  mem-&gt;Ref();
  <span style="font-weight: bold;">if</span> (imm != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) imm-&gt;Ref();
  current-&gt;Ref();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#26597;&#35810;&#26159;&#21542;&#20250;&#36896;&#25104;compaction&#35302;&#21457;.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">have_stat_update</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold; text-decoration: underline;">GetStats</span> <span style="font-weight: bold; font-style: italic;">stats</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Unlock while reading from files and memtables</span>
  {
    mutex_.Unlock();
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20197;&#36825;&#20010;key&#21435;&#36827;&#34892;&#26597;&#35810;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1.&#39318;&#20808;&#26597;&#35810;memtable 2.&#28982;&#21518;&#26597;&#35810;&#27491;&#22312;dump&#30340;memtable 3.&#26597;&#35810;&#30913;&#30424;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">First look in the memtable, then in the immutable memtable (if any).</span>
    <span style="font-weight: bold; text-decoration: underline;">LookupKey</span> <span style="font-weight: bold; font-style: italic;">lkey</span>(key, snapshot);
    <span style="font-weight: bold;">if</span> (mem-&gt;Get(lkey, value, &amp;s)) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Done</span>
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (imm != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Done</span>
    } <span style="font-weight: bold;">else</span> {
      s = current-&gt;Get(options, lkey, value, &amp;stats);
      have_stat_update = <span style="font-weight: bold; text-decoration: underline;">true</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26597;&#35810;&#30913;&#30424;&#30340;&#35805;&#20250;&#36827;&#34892;&#26631;&#35760;.</span>
    }
    mutex_.Lock();
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24471;&#21040;&#30340;&#20869;&#23481;&#20250;&#21453;&#39304;&#21040;&#24403;&#21069;&#30340;version&#37324;&#38754;&#28982;&#21518;&#23581;&#35797;&#35302;&#21457;compaction.</span>
  <span style="font-weight: bold;">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) {
    MaybeScheduleCompaction();
  }
  mem-&gt;Unref();
  <span style="font-weight: bold;">if</span> (imm != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) imm-&gt;Unref();
  current-&gt;Unref();
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="orgb128ec4"></a>NewInternalIterator<br />
<div class="outline-text-5" id="text-10-3-3-32">
<p>
开辟内部的迭代器.但是功能上来说基本上以及完成了db::iterator所需要完成的工作.但是需要
注意这里面merge iterator接口是针对internal key的，所以外部的话还是需要保证user key
并且配合sequence number的行为.另外还需要考虑存在deletion情况.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">IterState</span> {
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">Mutex</span>* <span style="font-weight: bold; font-style: italic;">mu</span>;
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">version</span>;
  <span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">mem</span>;
  <span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">imm</span>;
};

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">CleanupIteratorState</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg1</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg2</span>) {
  <span style="font-weight: bold; text-decoration: underline;">IterState</span>* <span style="font-weight: bold; font-style: italic;">state</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">IterState</span>*&gt;(arg1);
  state-&gt;mu-&gt;Lock();
  state-&gt;mem-&gt;Unref();
  <span style="font-weight: bold;">if</span> (state-&gt;imm != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) state-&gt;imm-&gt;Unref();
  state-&gt;version-&gt;Unref();
  state-&gt;mu-&gt;Unlock();
  <span style="font-weight: bold;">delete</span> state;
}

<span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">NewInternalIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                                      <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span>* <span style="font-weight: bold; font-style: italic;">latest_snapshot</span>) {
  <span style="font-weight: bold; text-decoration: underline;">IterState</span>* <span style="font-weight: bold; font-style: italic;">cleanup</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">IterState</span>;
  mutex_.Lock();
  *latest_snapshot = versions_-&gt;LastSequence();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#21487;&#33021;&#23384;&#22312;&#30340;iterator&#25918;&#22312;&#19968;&#20010;list&#37324;&#38754;&#20570;&#25104;&#19968;&#20010;merge list&#20869;&#23481;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Collect together all needed child iterators</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Iterator</span>*&gt; <span style="font-weight: bold; font-style: italic;">list</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;memtable&#19979;&#38754;&#38656;&#35201;&#36941;&#21382;.</span>
  list.push_back(mem_-&gt;NewIterator());
  mem_-&gt;Ref();
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20854;&#27425;imm memtable&#38656;&#35201;&#36941;&#21382;</span>
  <span style="font-weight: bold;">if</span> (imm_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    list.push_back(imm_-&gt;NewIterator());
    imm_-&gt;Ref();
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;version&#26469;&#35828;&#21487;&#33021;&#23384;&#22312;&#24456;&#22810;&#25991;&#20214;&#38656;&#35201;&#36941;&#21382;.</span>
  versions_-&gt;current()-&gt;AddIterators(options, &amp;list);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20123;&#20869;&#23481;&#26500;&#36896;&#31216;&#20026;&#19968;&#20010;merge iterator.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#30340;&#20869;&#23481;&#37117;&#21152;&#20102;&#24341;&#29992;&#35745;&#25968;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">internal_iter</span> =
      NewMergingIterator(&amp;internal_comparator_, &amp;list[0], list.size());
  versions_-&gt;current()-&gt;Ref();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23558;&#36825;&#20123;&#37322;&#25918;&#20869;&#23481;&#23384;&#25918;&#22312;internal iter&#38144;&#27585;&#22238;&#35843;&#37324;&#38754;.</span>
  cleanup-&gt;mu = &amp;mutex_;
  cleanup-&gt;mem = mem_;
  cleanup-&gt;imm = imm_;
  cleanup-&gt;version = versions_-&gt;current();
  internal_iter-&gt;RegisterCleanup(CleanupIteratorState, cleanup, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);

  mutex_.Unlock();
  <span style="font-weight: bold;">return</span> internal_iter;
}
</pre>
</div>
</div>
</li>

<li><a id="org09e2845"></a>NewInterator<br />
<div class="outline-text-5" id="text-10-3-3-33">
<p>
实现在DBIter里面.工厂方式进行创建.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold;">NewIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20102;&#35299;&#24403;&#21069;&#26368;&#36817;&#30340;snapshot sequence number.</span>
  <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">latest_snapshot</span>;
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">internal_iter</span> = NewInternalIterator(options, &amp;latest_snapshot);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992;NewDBIterator&#26469;&#36827;&#34892;&#21019;&#24314;.&#20855;&#20307;&#21487;&#20197;&#26597;&#30475;DBIter&#23454;&#29616;.</span>
  <span style="font-weight: bold;">return</span> NewDBIterator(
      &amp;dbname_, env_, user_comparator(), internal_iter,
      (options.snapshot != <span style="font-weight: bold; text-decoration: underline;">NULL</span>
       ? <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>*&gt;(options.snapshot)-&gt;number_
       : latest_snapshot));
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org43456bc" class="outline-4">
<h4 id="org43456bc"><span class="section-number-4">10.3.4</span> DBIter</h4>
<div class="outline-text-4" id="text-10-3-4">
<p>
db/db<sub>iter.cc</sub> DBIter通过工厂方法创建.然后就DBIter结构以及里面的接口看看.
关于这个iterator的具体细节的话可以不用了解非常清楚，稍微了解工作原理即可。
实际上里面FindNextUserEntry和FindPrevUserEntry没有仔细阅读.:(.
</p>
</div>

<ol class="org-ol">
<li><a id="org7f67449"></a>NewDBIterator<br />
<div class="outline-text-5" id="text-10-3-4-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewDBIterator</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dbname</span>,
    <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold; font-style: italic;">env</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">user_key_comparator</span>,
    <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">internal_iter</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span>&amp; <span style="font-weight: bold; font-style: italic;">sequence</span>) {
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>(dbname, env, user_key_comparator, internal_iter, sequence);
}
</pre>
</div>
</div>
</li>

<li><a id="org4c09349"></a>DBIter<br />
<div class="outline-text-5" id="text-10-3-4-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Memtables and sstables that make the DB representation contain</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(userkey,seq,type) =&gt; uservalue entries.  DBIter</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">combines multiple entries for the same userkey found in the DB</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">representation into a single entry while accounting for sequence</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">numbers, deletion markers, overwrites, etc.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>: <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Which direction is the iterator currently moving?</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(1) When moving forward, the internal iterator is positioned at</span>
  <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">the exact entry that yields this-&gt;key(), this-&gt;value()</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(2) When moving backwards, the internal iterator is positioned</span>
  <span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">just before all entries whose user key == this-&gt;key().</span>
  <span style="font-weight: bold;">enum</span> <span style="font-weight: bold; text-decoration: underline;">Direction</span> {
    <span style="font-weight: bold; font-style: italic;">kForward</span>,
    <span style="font-weight: bold; font-style: italic;">kReverse</span>
  };

  <span style="font-weight: bold;">DBIter</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dbname</span>, <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold; font-style: italic;">env</span>,
         <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">cmp</span>, <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">iter</span>, <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">s</span>)
      : dbname_(dbname),
        env_(env),
        user_comparator_(cmp),
        iter_(iter),
        sequence_(s),
        direction_(kForward), <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#40664;&#35748;&#26159;&#21521;&#21069;&#26597;&#25214;.</span>
        valid_(<span style="font-weight: bold; text-decoration: underline;">false</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#27809;&#26377;&#20219;&#20309;kv.</span>
  }
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">DBIter</span>() {
    <span style="font-weight: bold;">delete</span> iter_;
  }
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">dbname_</span>;
  <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">env_</span>;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">user_comparator_</span>;
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">iter_</span>;
  <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">sequence_</span>;

  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status_</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;kReverse&#26041;&#21521;&#30340;&#35805;,&#37027;&#20040;&#20174;&#36825;&#37324;&#36820;&#22238;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#30452;&#25509;&#35843;&#29992;iter&#36820;&#22238;.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">saved_key_</span>;     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">== current key when direction_==kReverse</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">saved_value_</span>;   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">== current raw value when direction_==kReverse</span>
  <span style="font-weight: bold; text-decoration: underline;">Direction</span> <span style="font-weight: bold; font-style: italic;">direction_</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">valid_</span>;
};
</pre>
</div>
</div>
</li>

<li><a id="orgcf6ef75"></a>ClearSavedValue<br />
<div class="outline-text-5" id="text-10-3-4-3">
<p>
清除saved<sub>value这个字段.好像有点技巧.可以看看代码啥的测试一下</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ClearSavedValue</span>() {
  <span style="font-weight: bold;">if</span> (saved_value_.capacity() &gt; 1048576) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&gt;1M&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;swap.</span>
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">empty</span>;
    swap(empty, saved_value_);
  } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#20351;&#29992;clear.</span>
    saved_value_.clear();
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org22cceb5"></a>ParseKey<br />
<div class="outline-text-5" id="text-10-3-4-4">
<p>
工作非常简单就是从iter得到对应的key.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>::<span style="font-weight: bold;">ParseKey</span>(<span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span>* <span style="font-weight: bold; font-style: italic;">ikey</span>) {
  <span style="font-weight: bold;">if</span> (!ParseInternalKey(iter_-&gt;key(), ikey)) {
    status_ = <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"corrupted internal key in DBIter"</span>);
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org7f475fc"></a>SaveKey<br />
<div class="outline-text-5" id="text-10-3-4-5">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SaveKey</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">k</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dst</span>) {
  dst-&gt;assign(k.data(), k.size());
}
</pre>
</div>
</div>
</li>

<li><a id="org40ab679"></a>Seek<br />
<div class="outline-text-5" id="text-10-3-4-6">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>::<span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) {
  direction_ = kForward;
  ClearSavedValue(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;saved_value_&#28165;&#31354;.</span>
  saved_key_.clear(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;saved_key_&#28165;&#31354;.</span>
  AppendInternalKey( <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37325;&#26032;&#35774;&#32622;&#26597;&#35810;key.&#20445;&#23384;&#21040;saved_key_.</span>
      &amp;saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));
  iter_-&gt;Seek(saved_key_);
  <span style="font-weight: bold;">if</span> (iter_-&gt;Valid()) {
    FindNextUserEntry(<span style="font-weight: bold; text-decoration: underline;">false</span>, &amp;saved_key_ <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">temporary storage */</span>);
  } <span style="font-weight: bold;">else</span> {
    valid_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org993a4c3"></a>Next<br />
<div class="outline-text-5" id="text-10-3-4-7">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>::<span style="font-weight: bold;">Next</span>() {
  assert(valid_);

  <span style="font-weight: bold;">if</span> (direction_ == kReverse) {  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Switch directions?</span>
    direction_ = kForward;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iter_ is pointing just before the entries for this-&gt;key(),</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">so advance into the range of entries for this-&gt;key() and then</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">use the normal skipping code below.</span>
    <span style="font-weight: bold;">if</span> (!iter_-&gt;Valid()) {
      iter_-&gt;SeekToFirst();
    } <span style="font-weight: bold;">else</span> {
      iter_-&gt;Next();
    }
    <span style="font-weight: bold;">if</span> (!iter_-&gt;Valid()) {
      valid_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
      saved_key_.clear();
      <span style="font-weight: bold;">return</span>;
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Temporarily use saved_key_ as storage for key to skip.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">skip</span> = &amp;saved_key_;
  SaveKey(ExtractUserKey(iter_-&gt;key()), skip);
  FindNextUserEntry(<span style="font-weight: bold; text-decoration: underline;">true</span>, skip);
}
</pre>
</div>
</div>
</li>

<li><a id="org9dc4558"></a>Prev<br />
<div class="outline-text-5" id="text-10-3-4-8">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>::<span style="font-weight: bold;">Prev</span>() {
  assert(valid_);

  <span style="font-weight: bold;">if</span> (direction_ == kForward) {  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Switch directions?</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iter_ is pointing at the current entry.  Scan backwards until</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the key changes so we can use the normal reverse scanning code.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#21521;&#21069;&#19968;&#30452;&#25214;&#21040;&#30053;&#36807;&#24403;&#21069;saved_key&#30340;&#20869;&#23481;.</span>
    assert(iter_-&gt;Valid());  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Otherwise valid_ would have been false</span>
    SaveKey(ExtractUserKey(iter_-&gt;key()), &amp;saved_key_);
    <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">true</span>) {
      iter_-&gt;Prev();
      <span style="font-weight: bold;">if</span> (!iter_-&gt;Valid()) {
        valid_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
        saved_key_.clear();
        ClearSavedValue();
        <span style="font-weight: bold;">return</span>;
      }
      <span style="font-weight: bold;">if</span> (user_comparator_-&gt;Compare(ExtractUserKey(iter_-&gt;key()),
                                    saved_key_) &lt; 0) {
        <span style="font-weight: bold;">break</span>;
      }
    }
    direction_ = kReverse;
  }

  FindPrevUserEntry();
}
</pre>
</div>
</div>
</li>

<li><a id="orged91177"></a>FindNextUserEntry<br />
<div class="outline-text-5" id="text-10-3-4-9">
<p>
我们需要考虑到在DBIter里面处理的是mergeiterator.多路的话可能会存在很多.
</p>

<p>
:现在才发现原来在find的时候并没有将sequence number放在里面而仅仅是比较user key
的内容，然后将所有的user key内容放在一起然后来处理sequence.不过对于memtable等
在插入的时候还是按照user key+sequence来进行存放.按照这个理解的话很多事情就比较好懂了.
</p>

<p>
总感觉这个地方可能存在问题，没有考虑到delete k然后add k的情况.不过撇开这个问题就好理解多了，
我们这里得到skip之后的话就可以在next的时候需要越过skip这个key.因为上次已经得到这个key的内容了.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>::<span style="font-weight: bold;">FindNextUserEntry</span>(<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">skipping</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">skip</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Loop until we hit an acceptable entry to yield</span>
  assert(iter_-&gt;Valid());
  assert(direction_ == kForward);
  <span style="font-weight: bold;">do</span> {
    <span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span> <span style="font-weight: bold; font-style: italic;">ikey</span>;
    <span style="font-weight: bold;">if</span> (ParseKey(&amp;ikey) &amp;&amp; ikey.sequence &lt;= sequence_) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#38656;&#35201;&#28385;&#36275;sequence.</span>
      <span style="font-weight: bold;">switch</span> (ikey.type) {
        <span style="font-weight: bold;">case</span> kTypeDeletion: <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;deletion&#30340;&#35805;,&#37027;&#20040;&#20445;&#23384;&#36825;&#20010;skip&#30340;&#20869;&#23481;.</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Arrange to skip all upcoming entries for this key since</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">they are hidden by this deletion.</span>
          SaveKey(ikey.user_key, skip);
          skipping = <span style="font-weight: bold; text-decoration: underline;">true</span>;
          <span style="font-weight: bold;">break</span>;
        <span style="font-weight: bold;">case</span> kTypeValue:
          <span style="font-weight: bold;">if</span> (skipping &amp;&amp;
              user_comparator_-&gt;Compare(ikey.user_key, *skip) &lt;= 0) {
            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Entry hidden</span>
          } <span style="font-weight: bold;">else</span> {
            valid_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
            saved_key_.clear();
            <span style="font-weight: bold;">return</span>;
          }
          <span style="font-weight: bold;">break</span>;
      }
    }
    iter_-&gt;Next();
  } <span style="font-weight: bold;">while</span> (iter_-&gt;Valid());
  saved_key_.clear();
  valid_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
}
</pre>
</div>
</div>
</li>

<li><a id="org446ccdc"></a>FindPrevUserEntry<br />
<div class="outline-text-5" id="text-10-3-4-10">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>::<span style="font-weight: bold;">FindPrevUserEntry</span>() {
  assert(direction_ == kReverse);

  <span style="font-weight: bold; text-decoration: underline;">ValueType</span> <span style="font-weight: bold; font-style: italic;">value_type</span> = kTypeDeletion;
  <span style="font-weight: bold;">if</span> (iter_-&gt;Valid()) {
    <span style="font-weight: bold;">do</span> {
      <span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span> <span style="font-weight: bold; font-style: italic;">ikey</span>;
      <span style="font-weight: bold;">if</span> (ParseKey(&amp;ikey) &amp;&amp; ikey.sequence &lt;= sequence_) {
        <span style="font-weight: bold;">if</span> ((value_type != kTypeDeletion) &amp;&amp;
            user_comparator_-&gt;Compare(ikey.user_key, saved_key_) &lt; 0) {
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We encountered a non-deleted value in entries for previous keys,</span>
          <span style="font-weight: bold;">break</span>;
        }
        value_type = ikey.type;
        <span style="font-weight: bold;">if</span> (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } <span style="font-weight: bold;">else</span> {
          <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">raw_value</span> = iter_-&gt;value();
          <span style="font-weight: bold;">if</span> (saved_value_.capacity() &gt; raw_value.size() + 1048576) {
            <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">empty</span>;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_-&gt;key()), &amp;saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }
      iter_-&gt;Prev();
    } <span style="font-weight: bold;">while</span> (iter_-&gt;Valid());
  }

  <span style="font-weight: bold;">if</span> (value_type == kTypeDeletion) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">End</span>
    valid_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
    saved_key_.clear();
    ClearSavedValue();
    direction_ = kForward;
  } <span style="font-weight: bold;">else</span> {
    valid_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgf4c8a4d"></a>SeekToFirst<br />
<div class="outline-text-5" id="text-10-3-4-11">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>::<span style="font-weight: bold;">SeekToFirst</span>() {
  direction_ = kForward;
  ClearSavedValue();
  iter_-&gt;SeekToFirst();
  <span style="font-weight: bold;">if</span> (iter_-&gt;Valid()) {
    FindNextUserEntry(<span style="font-weight: bold; text-decoration: underline;">false</span>, &amp;saved_key_ <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">temporary storage */</span>);
  } <span style="font-weight: bold;">else</span> {
    valid_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org04b08cf"></a>SeekToLast<br />
<div class="outline-text-5" id="text-10-3-4-12">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">DBIter</span>::<span style="font-weight: bold;">SeekToLast</span>() {
  direction_ = kReverse;
  ClearSavedValue();
  iter_-&gt;SeekToLast();
  FindPrevUserEntry();
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgfa858ad" class="outline-4">
<h4 id="orgfa858ad"><span class="section-number-4">10.3.5</span> LookupKey</h4>
<div class="outline-text-4" id="text-10-3-5">
<p>
db/dbformat.h LookupKey是为了方便对不同的结构进行查询的key结构.抽象出来的话会使得操作更加方便.
我们只需要传入我们的user<sub>key之后的话</sub>，那么就可以构造出对应查询结构的key.首先我们看看结构
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A helper class useful for DBImpl::Get()</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">LookupKey</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Initialize *this for looking up user_key at a snapshot with</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the specified sequence number.</span>
  <span style="font-weight: bold;">LookupKey</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">user_key</span>, <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">sequence</span>);

  ~<span style="font-weight: bold;">LookupKey</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a key suitable for lookup in a MemTable.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36820;&#22238;&#33021;&#22815;&#20026;memtable&#26597;&#35810;&#30340;key.</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">memtable_key</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> Slice(start_, end_ - start_); }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return an internal key (suitable for passing to an internal iterator)</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36820;&#22238;internal key.&#36825;&#20010;&#24212;&#35813;&#26159;&#20316;&#20026;sstable&#26597;&#35810;&#30340;key.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#38754;&#25105;&#20204;&#30475;&#30475;InternalKey&#30340;&#32467;&#26500;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">internal_key</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> Slice(kstart_, end_ - kstart_); }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36820;&#22238;user_key&#26412;&#36523;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the user key</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">user_key</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> Slice(kstart_, end_ - kstart_ - 8); }

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#38754;&#32473;&#20986;&#20102;&#20256;&#20837;user_key&#20043;&#21518;&#26500;&#36896;&#20986;key&#30340;&#26684;&#24335;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We construct a char array of the form:</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">klength  varint32               &lt;-- start_</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">userkey  char[klength]          &lt;-- kstart_</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">tag      uint64</span>
  <span style="font-weight: bold; font-style: italic;">//                                    </span><span style="font-weight: bold; font-style: italic;">&lt;-- end_</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The array is a suitable MemTable key.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The suffix starting with "userkey" can be used as an InternalKey.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">start_</span>;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">kstart_</span>;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">end_</span>;
  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">space_</span>[200];      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Avoid allocation for short keys</span>
};
</pre>
</div>
<p>
结构非常好理解，在看看构造函数和析构函数即可
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">LookupKey</span>::~<span style="font-weight: bold;">LookupKey</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;space_&#26159;&#20026;&#20102;&#23545;&#20110;short keys&#19981;&#36827;&#34892;&#20998;&#37197;.</span>
  <span style="font-weight: bold;">if</span> (start_ != space_) <span style="font-weight: bold;">delete</span>[] start_;
}

<span style="font-weight: bold; text-decoration: underline;">LookupKey</span>::<span style="font-weight: bold;">LookupKey</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">user_key</span>, <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">s</span>) {
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">usize</span> = user_key.size();
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">klength&#21344;&#29992;5&#20010;&#23383;&#33410;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">tag&#21344;&#29992;8&#20010;&#23383;&#33410;.</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">needed</span> = usize + 13;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A conservative estimate</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">dst</span>;
  <span style="font-weight: bold;">if</span> (needed &lt;= <span style="font-weight: bold;">sizeof</span>(space_)) {
    dst = space_;
  } <span style="font-weight: bold;">else</span> {
    dst = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[needed];
  }
  start_ = dst;
  dst = EncodeVarint32(dst, usize + 8);
  kstart_ = dst;
  memcpy(dst, user_key.data(), usize);
  dst += usize;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst += 8;
  end_ = dst;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org340d037" class="outline-4">
<h4 id="org340d037"><span class="section-number-4">10.3.6</span> ValueType</h4>
<div class="outline-text-4" id="text-10-3-6">
<p>
db/dbformat.h ValueType是存在于internal key内部的key类型.有普通类型和删除类型.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Value types encoded as the last component of internal keys.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">data structures.</span>
<span style="font-weight: bold;">enum</span> <span style="font-weight: bold; text-decoration: underline;">ValueType</span> {
  <span style="font-weight: bold; font-style: italic;">kTypeDeletion</span> = 0x0,
  <span style="font-weight: bold; font-style: italic;">kTypeValue</span> = 0x1
};
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kValueTypeForSeek defines the ValueType that should be passed when</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">constructing a ParsedInternalKey object for seeking to a particular</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sequence number (since we sort sequence numbers in decreasing order</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and the value type is embedded as the low 8 bits in the sequence</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">number in internal keys, we need to use the highest-numbered</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ValueType, not the lowest).</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ValueType</span> <span style="font-weight: bold; font-style: italic;">kValueTypeForSeek</span> = kTypeValue;
</pre>
</div>
</div>
</div>

<div id="outline-container-org8df6043" class="outline-4">
<h4 id="org8df6043"><span class="section-number-4">10.3.7</span> SequenceNumber</h4>
<div class="outline-text-4" id="text-10-3-7">
<p>
db/dbfotmat.h SequenceNumber也存在于internal key内部，表示这个key的序号。现在就我自己的理解，
能想到这个序号的用户就是用来完成snapshot.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span>;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We leave eight bits empty at the bottom so a type and sequence#</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">can be packed together into 64-bits.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">kMaxSequenceNumber</span> =
    ((0x1ull &lt;&lt; 56) - 1);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf9dcd9d" class="outline-4">
<h4 id="orgf9dcd9d"><span class="section-number-4">10.3.8</span> InternalKey</h4>
<div class="outline-text-4" id="text-10-3-8">
<p>
db/dbformat.h InternalKey的实现一份还存在于MemTable里面.因为从WriteBatch是首先写入MemTable的.
这个部分MemTable并没有复用而是重新实现.InternalKey应该也存在于SSTable里面.内部非常简单就是std::string
存储打包之后的格式。里面的方法比较多但是都相对非常简单。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Modules in this directory should keep internal keys wrapped inside</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the following class instead of plain strings so that we do not</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">incorrectly use string comparisons instead of an InternalKeyComparator.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">rep_</span>;
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">InternalKey</span>() { }   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Leave rep_ as empty to indicate it is invalid</span>
  <span style="font-weight: bold;">InternalKey</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">user_key</span>, <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">s</span>, <span style="font-weight: bold; text-decoration: underline;">ValueType</span> <span style="font-weight: bold; font-style: italic;">t</span>) {
    AppendInternalKey(&amp;rep_, ParsedInternalKey(user_key, s, t));
  }

  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">DecodeFrom</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">s</span>) { rep_.assign(s.data(), s.size()); }
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">Encode</span>() <span style="font-weight: bold;">const</span> {
    assert(!rep_.empty());
    <span style="font-weight: bold;">return</span> rep_;
  }

  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">user_key</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> ExtractUserKey(rep_); }

  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SetFrom</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span>&amp; <span style="font-weight: bold; font-style: italic;">p</span>) {
    rep_.clear();
    AppendInternalKey(&amp;rep_, p);
  }

  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Clear</span>() { rep_.clear(); }

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold;">DebugString</span>() <span style="font-weight: bold;">const</span>;
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org2aa22c2"></a>ExtracrUserKey<br />
<div class="outline-text-5" id="text-10-3-8-1">
<p>
之前我们知道user key是如何分布的了.后面8个字节有附加信息.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">ExtractUserKey</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">internal_key</span>) {
  assert(internal_key.size() &gt;= 8);
  <span style="font-weight: bold;">return</span> Slice(internal_key.data(), internal_key.size() - 8);
}
</pre>
</div>
</div>
</li>

<li><a id="orgbd4f1b5"></a>ExtractValueType<br />
<div class="outline-text-5" id="text-10-3-8-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">ValueType</span> <span style="font-weight: bold;">ExtractValueType</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">internal_key</span>) {
  assert(internal_key.size() &gt;= 8);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span> = internal_key.size();
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">num</span> = DecodeFixed64(internal_key.data() + n - 8);
  <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">c</span> = num &amp; 0xff;
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ValueType</span>&gt;(c);
}
</pre>
</div>
</div>
</li>

<li><a id="orgf9d6dc2"></a>ParsedInternalKey<br />
<div class="outline-text-5" id="text-10-3-8-3">
<p>
ParsedInternalKey是从InternalKey解析之后的表示.非常简单.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span> {
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">user_key</span>;
  <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">sequence</span>;
  <span style="font-weight: bold; text-decoration: underline;">ValueType</span> <span style="font-weight: bold; font-style: italic;">type</span>;

  <span style="font-weight: bold;">ParsedInternalKey</span>() { }  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Intentionally left uninitialized (for speed)</span>
  <span style="font-weight: bold;">ParsedInternalKey</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">u</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span>&amp; <span style="font-weight: bold; font-style: italic;">seq</span>, <span style="font-weight: bold; text-decoration: underline;">ValueType</span> <span style="font-weight: bold; font-style: italic;">t</span>)
      : user_key(u), sequence(seq), type(t) { }
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold;">DebugString</span>() <span style="font-weight: bold;">const</span>;
};
</pre>
</div>
</div>
</li>

<li><a id="orgb327ed0"></a>InternalKeyEncodingLength<br />
<div class="outline-text-5" id="text-10-3-8-4">
<p>
如果ParsedInternalKey打包称为InternalKey的长度.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the length of the encoding of "key".</span>
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">InternalKeyEncodingLength</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  <span style="font-weight: bold;">return</span> key.user_key.size() + 8;
}
</pre>
</div>
</div>
</li>

<li><a id="org9612902"></a>AppendInternalKey<br />
<div class="outline-text-5" id="text-10-3-8-5">
<p>
将ParsedInternalKey直接序列化到二进制格式.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">AppendInternalKey</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">result</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  result-&gt;append(key.user_key.data(), key.user_key.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
}
</pre>
</div>
</div>
</li>

<li><a id="orgf825ef8"></a>PackSequenceAndType<br />
<div class="outline-text-5" id="text-10-3-8-6">
<p>
sequence number占据高56bits,type占据低8bits
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">PackSequenceAndType</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">seq</span>, <span style="font-weight: bold; text-decoration: underline;">ValueType</span> <span style="font-weight: bold; font-style: italic;">t</span>) {
  assert(seq &lt;= kMaxSequenceNumber);
  assert(t &lt;= kValueTypeForSeek);
  <span style="font-weight: bold;">return</span> (seq &lt;&lt; 8) | t;
}
</pre>
</div>
</div>
</li>

<li><a id="org30e0dcc"></a>ParseInternalKey<br />
<div class="outline-text-5" id="text-10-3-8-7">
<p>
根据InternalKey解析出ParsedInternalKey
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">ParseInternalKey</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">internal_key</span>,
                             <span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span>* <span style="font-weight: bold; font-style: italic;">result</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span> = internal_key.size();
  <span style="font-weight: bold;">if</span> (n &lt; 8) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">num</span> = DecodeFixed64(internal_key.data() + n - 8);
  <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">c</span> = num &amp; 0xff;
  result-&gt;sequence = num &gt;&gt; 8;
  result-&gt;type = <span style="font-weight: bold;">static_cast</span>&lt;ValueType&gt;(c);
  result-&gt;user_key = Slice(internal_key.data(), n - 8);
  <span style="font-weight: bold;">return</span> (c &lt;= <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>&gt;(kTypeValue));
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org9925010" class="outline-4">
<h4 id="org9925010"><span class="section-number-4">10.3.9</span> InternalKeyComparator</h4>
<div class="outline-text-4" id="text-10-3-9">
<p>
db/dbformat.cc 我们在MemTable::KeyComparator::operator()里面看到了调用InternalKeyComparator的Compare方法.
Compare接收两个Slice对象。对象是这样encode的,key<sub>size</sub> + key<sub>data</sub> + (seq &lt;&lt; 8) | type(8 bytes).
其中key<sub>size包括了后面附加的8个字节.我们来看看InternalKeyComparator是怎么实现的.底层的Comparator是用来直接比较UserKey的</sub>，
没有考虑sequence number.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A comparator for internal keys that uses a specified comparator for</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the user key portion and breaks ties by decreasing sequence number.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">user_comparator_</span>;
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">InternalKeyComparator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">c</span>) : user_comparator_(c) { }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">Name</span>() <span style="font-weight: bold;">const</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"leveldb.InternalKeyComparator"</span>
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">Compare</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">b</span>) <span style="font-weight: bold;">const</span>;
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">FindShortestSeparator</span>(
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">start</span>,
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">limit</span>) <span style="font-weight: bold;">const</span>;
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">FindShortSuccessor</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span>;

  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold;">user_comparator</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> user_comparator_; }

  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">Compare</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>&amp; <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>&amp; <span style="font-weight: bold; font-style: italic;">b</span>) <span style="font-weight: bold;">const</span>;
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orga26732a"></a>Compare<br />
<div class="outline-text-5" id="text-10-3-9-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>::<span style="font-weight: bold;">Compare</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">akey</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">bkey</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Order by:</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">increasing user key (according to user-supplied comparator)</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">decreasing sequence number</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">decreasing type (though sequence# should be enough to disambiguate)</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">r</span> = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
  <span style="font-weight: bold;">if</span> (r == 0) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">anum</span> = DecodeFixed64(akey.data() + akey.size() - 8);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">bnum</span> = DecodeFixed64(bkey.data() + bkey.size() - 8);
    <span style="font-weight: bold;">if</span> (anum &gt; bnum) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25353;&#29031;sequence number&#27604;&#36739;.</span>
     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20043;&#21069;&#25105;&#20204;&#22312;MemTableInserter&#37324;&#38754;&#21487;&#20197;&#30475;&#21040;sequence number&#26159;&#19981;&#26029;&#22686;&#21152;&#30340;.</span>
      r = -1;
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (anum &lt; bnum) {
      r = +1;
    }
  }
  <span style="font-weight: bold;">return</span> r;
}
</pre>
</div>
</div>
</li>

<li><a id="org2c1fe5f"></a>FindShortestSeparator<br />
<div class="outline-text-5" id="text-10-3-9-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>::<span style="font-weight: bold;">FindShortestSeparator</span>(
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">start</span>,
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">limit</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Attempt to shorten the user portion of the key</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">user_start</span> = ExtractUserKey(*start);
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">user_limit</span> = ExtractUserKey(limit);
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">tmp</span>(user_start.data(), user_start.size());
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#20351;&#29992;user_comparator&#25214;&#21040;&#26356;&#30701;&#30340;</span>
  user_comparator_-&gt;FindShortestSeparator(&amp;tmp, user_limit);
  <span style="font-weight: bold;">if</span> (tmp.size() &lt; user_start.size() &amp;&amp; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#27604;&#36739;&#26159;&#21542;&#30495;&#30340;&#26356;&#30701;.</span>
      user_comparator_-&gt;Compare(user_start, tmp) &lt; 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26356;&#30701;&#30340;&#35805;&#65292;&#37027;&#20040;&#20250;&#23558;&#21518;&#38754;&#30340;8&#20010;&#23383;&#33410;&#34917;&#40784;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#30340;8&#20010;&#23383;&#33410;&#20351;&#29992;kMaxSequenceNumber&#20197;&#21450;kValueTypeForSeek</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20854;&#20013;kMaxSequenceNumber == (1 &lt;&lt; 56)-1</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32780;kValueTypeForSeek == KValueType.(&#23601;&#26159;&#26222;&#36890;&#30340;kv&#31867;&#22411;)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">User key has become shorter physically, but larger logically.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Tack on the earliest possible number to the shortened user key.</span>
    PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(<span style="font-weight: bold;">this</span>-&gt;Compare(*start, tmp) &lt; 0);
    assert(<span style="font-weight: bold;">this</span>-&gt;Compare(tmp, limit) &lt; 0);
    start-&gt;swap(tmp);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org10139fd"></a>FindShortSuccessor<br />
<div class="outline-text-5" id="text-10-3-9-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>::<span style="font-weight: bold;">FindShortSuccessor</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">user_key</span> = ExtractUserKey(*key);
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">tmp</span>(user_key.data(), user_key.size());
  user_comparator_-&gt;FindShortSuccessor(&amp;tmp); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#36890;&#36807;user_comparator_&#25214;&#21040;&#19979;&#19968;&#20010;</span>
  <span style="font-weight: bold;">if</span> (tmp.size() &lt; user_key.size() &amp;&amp;
      user_comparator_-&gt;Compare(user_key, tmp) &lt; 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#30830;&#23454;&#26356;&#30701;&#30340;&#35805;&#37027;&#20040;&#20250;&#21152;&#19978;&#29305;&#23450;&#30340;8&#23383;&#33410;&#38468;&#21152;&#20449;&#24687;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20851;&#20110;&#38468;&#21152;&#20449;&#24687;&#22312;&#19978;&#38754;&#37027;&#20010;&#20989;&#25968;&#24050;&#32463;&#35299;&#37322;&#36807;&#20102;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">User key has become shorter physically, but larger logically.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Tack on the earliest possible number to the shortened user key.</span>
    PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(<span style="font-weight: bold;">this</span>-&gt;Compare(*key, tmp) &lt; 0);
    key-&gt;swap(tmp);
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org36e14db" class="outline-4">
<h4 id="org36e14db"><span class="section-number-4">10.3.10</span> FileMetaData</h4>
<div class="outline-text-4" id="text-10-3-10">
<p>
db/version<sub>edit.h</sub> 对于一个sstable的元信息表示.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span> {
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">refs</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#20250;&#35774;&#32622;&#19968;&#20010;&#21021;&#20540;</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">allowed_seeks</span>;          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Seeks allowed until compaction</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">number</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file_number.&#27604;&#22914;1.sst.&#36825;&#20010;&#32467;&#21512;BuildTable&#21644;TableCache&#21487;&#20197;&#29702;&#35299;&#24847;&#24605;.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_size</span>;         <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">File size in bytes</span>
  <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">smallest</span>;       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Smallest internal key served by table</span>
  <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">largest</span>;        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Largest internal key served by table</span>

  <span style="font-weight: bold;">FileMetaData</span>() : refs(0), allowed_seeks(1 &lt;&lt; 30), file_size(0) { }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orga188df5" class="outline-4">
<h4 id="orga188df5"><span class="section-number-4">10.3.11</span> Version</h4>
<div class="outline-text-4" id="text-10-3-11">
<p>
db/version<sub>set.h</sub> 对于Version可以理解为每个Snapshot对应的内容。因为每个snapshot可能需要持有不同的文件，
这样Version里面可以带上所需要管理的文件。如果释放Snapshot的话并且也可以释放Version的话，那么就可以认为这些文件
没有被任何Snapshot所引用就可以被回收。首先看看Version结构题里面的字段。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Version</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">private:</span>
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">friend</span> <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span>;
  <span style="font-weight: bold;">friend</span> <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>;

  <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">LevelFileNumIterator</span>;
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewConcatenatingIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp;, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>) <span style="font-weight: bold;">const</span>;

  <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>* <span style="font-weight: bold; font-style: italic;">vset_</span>;            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">VersionSet to which this Version belongs</span>
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">next_</span>;               <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Next version in linked list</span>
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">prev_</span>;               <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Previous version in linked list</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">refs_</span>;                    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Number of live refs to this version</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">List of files per level</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010;level&#30340;files_&#37117;&#26159;&#32463;&#36807;&#25490;&#24207;&#30340;&#12290;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;level0&#21487;&#33021;&#23384;&#22312;overlap,&#23545;&#20110;level-x&#19981;&#23384;&#22312;overlap.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt; <span style="font-weight: bold; font-style: italic;">files_</span>[<span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;version&#22312;&#21508;&#20010;level&#20445;&#25345;&#30340;&#25991;&#20214;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Next file to compact based on seek stats.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454;seek&#30340;&#32479;&#35745;&#19979;&#27425;&#38656;&#35201;&#36827;&#34892;compact&#30340;&#25991;&#20214;.</span>
  <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">file_to_compact_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#27425;&#36827;&#34892;compact&#25991;&#20214;</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">file_to_compact_level_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#25991;&#20214;&#25152;&#22312;&#30340;level.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Level that should be compacted next and its compaction score.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Score &lt; 1 means compaction is not strictly needed.  These fields</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">are initialized by Finalize().</span>
  <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">compaction_score_</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">compaction_level_</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26500;&#36896;&#20989;&#25968;&#38750;&#24120;&#31616;&#21333;.</span>
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">Version</span>(<span style="font-weight: bold; text-decoration: underline;">VersionSet</span>* <span style="font-weight: bold; font-style: italic;">vset</span>)
      : vset_(vset), next_(<span style="font-weight: bold;">this</span>), prev_(<span style="font-weight: bold;">this</span>), refs_(0),
        file_to_compact_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
        file_to_compact_level_(-1),
        compaction_score_(-1),
        compaction_level_(-1) {
  }

  ~<span style="font-weight: bold;">Version</span>();
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org57d6c75"></a>AddIterators<br />
<div class="outline-text-5" id="text-10-3-11-1">
<p>
将所持有的所有的level文件打开并且返回iterator.从注释上来看的话得到这些iterators的话是为了进行merge.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold;">AddIterators</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                           <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Iterator</span>*&gt;* <span style="font-weight: bold; font-style: italic;">iters</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Merge all level zero files together since they may overlap</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25171;&#24320;&#25152;&#26377;&#30340;level0&#25991;&#20214;.</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; files_[0].size(); i++) {
    iters-&gt;push_back(
        vset_-&gt;table_cache_-&gt;NewIterator(
            options, files_[0][i]-&gt;number, files_[0][i]-&gt;file_size));
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25171;&#24320;&#20854;&#20182;level&#30340;&#25991;&#20214;.&#20851;&#20110;&#36825;&#20010;concatenating&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For levels &gt; 0, we can use a concatenating iterator that sequentially</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">walks through the non-overlapping files in the level, opening them</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lazily.</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 1; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
    <span style="font-weight: bold;">if</span> (!files_[level].empty()) {
      iters-&gt;push_back(NewConcatenatingIterator(options, level));
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org0421afd"></a>NewConcatenatingIterator<br />
<div class="outline-text-5" id="text-10-3-11-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold;">NewConcatenatingIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                                            <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">return</span> NewTwoLevelIterator(
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#30340;level&gt;1.&#27599;&#20010;&#25991;&#20214;&#20043;&#38388;&#26159;&#27809;&#26377;overlap&#30340;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#36825;&#37324;&#25105;&#20204;&#20063;&#21487;&#20197;&#30693;&#36947;files_&#23545;&#20110;meta&#20043;&#38388;&#37117;&#26159;&#36827;&#34892;&#20102;&#25490;&#24207;&#30340;&#12290;</span>
      <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">LevelFileNumIterator</span>(vset_-&gt;icmp_, &amp;files_[level]), <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#32423;&#36941;&#21382;&#22120;&#37319;&#29992;LevelFileNumberIterator.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26144;&#23556;&#21040;&#20108;&#32423;&#36941;&#21382;&#22120;&#30340;&#35805;&#20351;&#29992;GetFileIterator&#26469;&#33719;&#24471;.</span>
      &amp;GetFileIterator, vset_-&gt;table_cache_, options);
}
</pre>
</div>
</div>
</li>

<li><a id="org34040c8"></a>LevelFileNumIterator<br />
<div class="outline-text-5" id="text-10-3-11-3">
<p>
结构应该非常简单，我们大致看看即可。主要是关心一下二级映射函数GetFileIterator.对于
key的话采用这个filemetadata里面的最大的key,而value采用filenumber+filesize表示.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold; text-decoration: underline;">LevelFileNumIterator</span> : <span style="font-weight: bold;">public</span> Iterator {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">LevelFileNumIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>&amp; <span style="font-weight: bold; font-style: italic;">icmp</span>,
                       <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;* <span style="font-weight: bold; font-style: italic;">flist</span>)
      : icmp_(icmp),
        flist_(flist),
        index_(flist-&gt;size()) {        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Marks as invalid</span>
  }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Valid</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> index_ &lt; flist_-&gt;size();
  }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) {
    index_ = FindFile(icmp_, *flist_, target); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25214;&#21040;&#36825;&#20010;target&#25152;&#23384;&#22312;&#30340;&#26368;&#23567;&#30340;index.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#21518;&#38754;&#20250;&#20855;&#20307;&#20998;&#26512;.&#20043;&#21069;&#30475;&#21040;&#20102;&#36825;&#23618;level&#37117;&#26159;disjoint&#30340;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#22312;FindFile&#37324;&#38754;&#21487;&#20197;&#26681;&#25454;smallest&#20063;&#21487;&#20197;&#26681;&#25454;largest&#26469;&#36827;&#34892;&#26597;&#25214;.</span>
  }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToFirst</span>() { index_ = 0; }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToLast</span>() {
    index_ = flist_-&gt;empty() ? 0 : flist_-&gt;size() - 1;
  }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Next</span>() {
    assert(Valid());
    index_++;
  }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Prev</span>() {
    assert(Valid());
    <span style="font-weight: bold;">if</span> (index_ == 0) {
      index_ = flist_-&gt;size();  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Marks as invalid</span>
    } <span style="font-weight: bold;">else</span> {
      index_--;
    }
  }
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">key</span>() <span style="font-weight: bold;">const</span> {
    assert(Valid());
    <span style="font-weight: bold;">return</span> (*flist_)[index_]-&gt;largest.Encode();
  }
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">value</span>() <span style="font-weight: bold;">const</span> {
    assert(Valid()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file_number + file_size.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20851;&#20110;&#22914;&#20309;&#20351;&#29992;&#36825;&#20010;value.&#24212;&#35813;&#26159;&#26681;&#25454;&#36825;&#20010;value&#23545;&#24212;&#21040;&#36825;&#20010;&#20855;&#20307;&#25991;&#20214;&#30340;iterator.</span>
    EncodeFixed64(value_buf_, (*flist_)[index_]-&gt;number);
    EncodeFixed64(value_buf_+8, (*flist_)[index_]-&gt;file_size);
    <span style="font-weight: bold;">return</span> Slice(value_buf_, <span style="font-weight: bold;">sizeof</span>(value_buf_));
  }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">status</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK(); }
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span> <span style="font-weight: bold; font-style: italic;">icmp_</span>;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">flist_</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">index_</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Backing store for value().  Holds the file number and size.</span>
  <span style="font-weight: bold;">mutable</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">value_buf_</span>[16];
};
</pre>
</div>
</div>
</li>

<li><a id="org33cfb1f"></a>GetFileIterator<br />
<div class="outline-text-5" id="text-10-3-11-4">
<p>
根据上面的分析file<sub>value就是file</sub><sub>number</sub> + file<sub>size.这里我们可以知道file</sub><sub>number应该是全局唯一的</sub>，
而不是在level上面唯一的。关于TableCache后面会分析。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">GetFileIterator</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>,
                                 <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                                 <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">file_value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">TableCache</span>* <span style="font-weight: bold; font-style: italic;">cache</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">TableCache</span>*&gt;(arg);
  <span style="font-weight: bold;">if</span> (file_value.size() != 16) {
    <span style="font-weight: bold;">return</span> NewErrorIterator(
        <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"FileReader invoked with unexpected value"</span>));
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> cache-&gt;NewIterator(options,
                              DecodeFixed64(file_value.data()),
                              DecodeFixed64(file_value.data() + 8));
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgbd85bef"></a>FindFile<br />
<div class="outline-text-5" id="text-10-3-11-5">
<p>
db/version<sub>set.h</sub> 语义直接阅读注释即可.注意这里files都是排好序并且是不重叠的。按照二分法搜索largest key即可.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the smallest index i such that files[i]-&gt;largest &gt;= key.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return files.size() if there is no such file.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: "files" contains a sorted list of non-overlapping files.</span>
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">FindFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>&amp; <span style="font-weight: bold; font-style: italic;">icmp</span>,
             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">files</span>,
             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">left</span> = 0;
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">right</span> = files.size();
  <span style="font-weight: bold;">while</span> (left &lt; right) {
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">mid</span> = (left + right) / 2;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = files[mid];
    <span style="font-weight: bold;">if</span> (icmp.<span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>::Compare(f-&gt;largest.Encode(), key) &lt; 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Key at "mid.largest" is &lt; "target".  Therefore all</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">files at or before "mid" are uninteresting.</span>
      left = mid + 1;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Key at "mid.largest" is &gt;= "target".  Therefore all files</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">after "mid" are uninteresting.</span>
      right = mid;
    }
  }
  <span style="font-weight: bold;">return</span> right;
}
</pre>
</div>
</div>
</li>

<li><a id="org7433dd7"></a>SomeFileOverlapsRange<br />
<div class="outline-text-5" id="text-10-3-11-6">
<p>
db/version<sub>set.h</sub> 判断是否有文件和某个范围[smallest,largest]相交.注意这里这里files也是按照key排序的.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns true iff some file in "files" overlaps the user key range</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">[*smallest,*largest].</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">smallest==NULL represents a key smaller than all keys in the DB.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">largest==NULL represents a key largest than all keys in the DB.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: If disjoint_sorted_files, files[] contains disjoint ranges</span>
<span style="font-weight: bold; font-style: italic;">//           </span><span style="font-weight: bold; font-style: italic;">in sorted order.</span>
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">SomeFileOverlapsRange</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>&amp; <span style="font-weight: bold; font-style: italic;">icmp</span>,
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">disjoint_sorted_files</span>, <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#34920;&#31034;files</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">files</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">smallest_user_key</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">largest_user_key</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">ucmp</span> = icmp.user_comparator();
  <span style="font-weight: bold;">if</span> (!disjoint_sorted_files) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#25991;&#20214;&#20043;&#38388;&#21487;&#33021;&#23384;&#22312;overlap&#30340;&#35805;.&#37027;&#20040;&#24517;&#39035;&#39034;&#24207;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#38656;&#35201;&#36941;&#21382;&#27599;&#20010;&#25991;&#20214;.&#21028;&#26029;&#36825;&#20010;&#25991;&#20214;&#26159;&#21542;&#21644;[small,large]&#30456;&#20132;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26377;&#30456;&#20132;&#65292;&#37027;&#20040;&#30452;&#25509;&#36820;&#22238;.:).</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Need to check against all files</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; files.size(); i++) {
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = files[i];
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">AfterFile&#21644;BeforeFile&#31245;&#21518;&#20998;&#26512;.</span>
      <span style="font-weight: bold;">if</span> (AfterFile(ucmp, smallest_user_key, f) ||
          BeforeFile(ucmp, largest_user_key, f)) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No overlap</span>
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Overlap</span>
      }
    }
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#25991;&#20214;&#26412;&#36523;&#20043;&#38388;&#27809;&#26377;overlap&#30340;&#35805;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#25105;&#20204;&#21482;&#38656;&#35201;&#39318;&#20808;&#25353;&#29031;&#20108;&#20998;&#26041;&#27861;&#25214;&#21040;&#30456;&#20132;&#25991;&#20214;index.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#38024;&#23545;&#36825;&#20010;index&#20998;&#26512;&#21363;&#21487;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Binary search over file list</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">index</span> = 0;
  <span style="font-weight: bold;">if</span> (smallest_user_key != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Find the earliest possible internal key for smallest_user_key</span>
    <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">small</span>(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);
    index = FindFile(icmp, files, small.Encode());
  }

  <span style="font-weight: bold;">if</span> (index &gt;= files.size()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">beginning of range is after all files, so no overlap.</span>
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }

  <span style="font-weight: bold;">return</span> !BeforeFile(ucmp, largest_user_key, files[index]);
}
</pre>
</div>
</div>
</li>

<li><a id="orgaf98f07"></a>AfterFile<br />
<div class="outline-text-5" id="text-10-3-11-7">
<p>
判断user<sub>key是否在这个file之后</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">AfterFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">ucmp</span>,
                      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">user_key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NULL user_key occurs before all keys and is therefore never after *f</span>
  <span style="font-weight: bold;">return</span> (user_key != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp;
          ucmp-&gt;Compare(*user_key, f-&gt;largest.user_key()) &gt; 0);
}
</pre>
</div>
</div>
</li>

<li><a id="orga2be83d"></a>BeforeFile<br />
<div class="outline-text-5" id="text-10-3-11-8">
<p>
判断user<sub>key是否在这个file之前</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">BeforeFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">ucmp</span>,
                       <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">user_key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NULL user_key occurs after all keys and is therefore never before *f</span>
  <span style="font-weight: bold;">return</span> (user_key != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp;
          ucmp-&gt;Compare(*user_key, f-&gt;smallest.user_key()) &lt; 0);
}
</pre>
</div>
</div>
</li>

<li><a id="org3d50d17"></a>GetStats<br />
<div class="outline-text-5" id="text-10-3-11-9">
<p>
这个结构反应的是查询到的一些附加结果可以用来指导compaction.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">GetStats</span> {
  <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">seek_file</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#34987;seek&#21040;&#30340;&#25991;&#20214;</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">seek_file_level</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20197;&#21450;&#36825;&#20010;&#25991;&#20214;&#25152;&#22788;level.</span>
};
</pre>
</div>
</div>
</li>

<li><a id="org7cef926"></a>NewestFirst<br />
<div class="outline-text-5" id="text-10-3-11-10">
<p>
按照file<sub>number进行排序.逆序.越迟生成的file那么是最新的</sub>。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">NewestFirst</span>(<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">b</span>) {
  <span style="font-weight: bold;">return</span> a-&gt;number &gt; b-&gt;number;
}
</pre>
</div>
</div>
</li>

<li><a id="org03bca0d"></a>Get<br />
<div class="outline-text-5" id="text-10-3-11-11">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold;">Get</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">LookupKey</span>&amp; <span style="font-weight: bold; font-style: italic;">k</span>,
                    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">value</span>,
                    <span style="font-weight: bold; text-decoration: underline;">GetStats</span>* <span style="font-weight: bold; font-style: italic;">stats</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">ikey</span> = k.internal_key();
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">user_key</span> = k.user_key();
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">ucmp</span> = vset_-&gt;icmp_.user_comparator();
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;

  stats-&gt;seek_file = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  stats-&gt;seek_file_level = -1;
  <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">last_file_read</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">last_file_read_level</span> = -1;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We can search level-by-level since entries never hop across</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">levels.  Therefore we are guaranteed that if we find data</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">in an smaller level, later levels are irrelevant.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt; <span style="font-weight: bold; font-style: italic;">tmp</span>;
  <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">tmp2</span>;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">num_files</span> = files_[level].size();
    <span style="font-weight: bold;">if</span> (num_files == 0) <span style="font-weight: bold;">continue</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Get the list of files to search in this level</span>
    <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold;">const</span>* <span style="font-weight: bold; font-style: italic;">files</span> = &amp;files_[level][0];
    <span style="font-weight: bold;">if</span> (level == 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Level-0 files may overlap each other.  Find all files that</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">overlap user_key and process them in order from newest to oldest.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;level0&#23384;&#22312;&#37325;&#21472;&#65292;&#25152;&#20197;&#38656;&#35201;&#37117;&#36827;&#34892;&#25628;&#32034;.</span>
      tmp.reserve(num_files);
      <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; num_files; i++) {
        <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = files[i];
        <span style="font-weight: bold;">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= 0 &amp;&amp;
            ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= 0) {
          tmp.push_back(f);
        }
      }
      <span style="font-weight: bold;">if</span> (tmp.empty()) <span style="font-weight: bold;">continue</span>;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#25353;&#29031;&#36827;&#34892;&#25490;&#24207;.&#26368;&#26032;&#29983;&#25104;&#30340;file&#25918;&#22312;&#26368;&#21069;&#38754;.</span>
      <span style="font-weight: bold; text-decoration: underline;">std</span>::sort(tmp.begin(), tmp.end(), NewestFirst);
      files = &amp;tmp[0];
      num_files = tmp.size();
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#20854;&#20182;level&#30340;&#35805;&#36234;&#20302;level&#36234;&#26032;.&#24182;&#19988;level&#20869;&#37096;&#27809;&#26377;overlap</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#21487;&#20197;&#36890;&#36807;&#31616;&#21333;&#30340;&#20108;&#20998;&#27861;&#26469;&#21028;&#26029;&#21738;&#20010;&#25991;&#20214;.&#21482;&#20250;&#23384;&#22312;&#19968;&#20010;&#25991;&#20214;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Binary search to find earliest index whose largest key &gt;= ikey.</span>
      <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">index</span> = FindFile(vset_-&gt;icmp_, files_[level], ikey);
      <span style="font-weight: bold;">if</span> (index &gt;= num_files) {
        files = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
        num_files = 0;
      } <span style="font-weight: bold;">else</span> {
        tmp2 = files[index];
        <span style="font-weight: bold;">if</span> (ucmp-&gt;Compare(user_key, tmp2-&gt;smallest.user_key()) &lt; 0) {
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">All of "tmp2" is past any data for user_key</span>
          files = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
          num_files = 0;
        } <span style="font-weight: bold;">else</span> {
          files = &amp;tmp2;
          num_files = 1;
        }
      }
    }

    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; num_files; ++i) {
      <span style="font-weight: bold;">if</span> (last_file_read != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; stats-&gt;seek_file == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We have had more than one seek for this read.  Charge the 1st file.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">stats&#36825;&#37324;&#21482;&#20445;&#30041;&#31532;&#19968;&#27425;&#35835;&#21462;&#30340;&#25991;&#20214;.</span>
        stats-&gt;seek_file = last_file_read;
        stats-&gt;seek_file_level = last_file_read_level;
      }

      <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = files[i];
      last_file_read = f;
      last_file_read_level = level;

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36890;&#36807;iterator&#30340;seek&#26041;&#24335;&#26469;&#36827;&#34892;&#26597;&#25214;.</span>
      <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">iter</span> = vset_-&gt;table_cache_-&gt;NewIterator(
          options,
          f-&gt;number,
          f-&gt;file_size);
      iter-&gt;Seek(ikey);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">seek&#21482;&#26159;&#19968;&#20010;&#22823;&#27010;&#20301;&#32622;&#36825;&#37324;&#38656;&#35201;&#31934;&#30830;&#27604;&#36739;&#36820;&#22238;&#20540;.&#21518;&#38754;&#25105;&#20204;&#20180;&#32454;&#20998;&#26512;GetValue.</span>
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">done</span> = GetValue(ucmp, iter, user_key, value, &amp;s);
      <span style="font-weight: bold;">if</span> (!iter-&gt;status().ok()) {
        s = iter-&gt;status();
        <span style="font-weight: bold;">delete</span> iter;
        <span style="font-weight: bold;">return</span> s;
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold;">delete</span> iter;
        <span style="font-weight: bold;">if</span> (done) {
          <span style="font-weight: bold;">return</span> s;
        }
      }
    }
  }

  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::NotFound(Slice());  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Use an empty error message for speed</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org4475bb3"></a>GetValue<br />
<div class="outline-text-5" id="text-10-3-11-12">
<p>
GetValue根据某个iter和key判断这个key是否为想查询的key.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If "*iter" points at a value or deletion for user_key, store</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">either the value, or a NotFound error and return true.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Else return false.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">GetValue</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">cmp</span>,
                     <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">iter</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">user_key</span>,
                     <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">value</span>,
                     <span style="font-weight: bold; text-decoration: underline;">Status</span>* <span style="font-weight: bold; font-style: italic;">s</span>) {
  <span style="font-weight: bold;">if</span> (!iter-&gt;Valid()) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  <span style="font-weight: bold; text-decoration: underline;">ParsedInternalKey</span> <span style="font-weight: bold; font-style: italic;">parsed_key</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;iterator&#37324;&#38754;&#26159;internal key.&#35299;&#26512;&#20986;parsed internal key&#20986;&#26469;.</span>
  <span style="font-weight: bold;">if</span> (!ParseInternalKey(iter-&gt;key(), &amp;parsed_key)) {
    *s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"corrupted key for "</span>, user_key);
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27604;&#36739;user key&#20869;&#23481;&#26159;&#21542;&#19968;&#33268;.&#36825;&#37324;&#27809;&#26377;&#32771;&#34385;sequence number.</span>
  <span style="font-weight: bold;">if</span> (cmp-&gt;Compare(parsed_key.user_key, user_key) != 0) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#21028;&#26029;&#36825;&#20010;key&#26159;&#21542;&#26631;&#35760;&#21024;&#38500;.</span>
  <span style="font-weight: bold;">switch</span> (parsed_key.type) {
    <span style="font-weight: bold;">case</span> kTypeDeletion:
      *s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::NotFound(Slice());  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Use an empty error message for speed</span>
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold;">case</span> kTypeValue: {
      <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">v</span> = iter-&gt;value();
      value-&gt;assign(v.data(), v.size());
      <span style="font-weight: bold;">break</span>;
    }
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
}
</pre>
</div>
</div>
</li>

<li><a id="org57c779f"></a>UpdateStats<br />
<div class="outline-text-5" id="text-10-3-11-13">
<p>
根据stats来更新version内部状态.设置将要compaction文件以及对应的level是什么.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold;">UpdateStats</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">GetStats</span>&amp; <span style="font-weight: bold; font-style: italic;">stats</span>) {
  <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = stats.seek_file; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;stats&#37324;&#38754;&#26631;&#35760;&#20102;&#25968;&#25454;&#30340;&#35805;.</span>
  <span style="font-weight: bold;">if</span> (f != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    f-&gt;allowed_seeks--; <span style="font-weight: bold; font-style: italic;">//</span>
    <span style="font-weight: bold;">if</span> (f-&gt;allowed_seeks &lt;= 0 &amp;&amp; file_to_compact_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      file_to_compact_ = f;
      file_to_compact_level_ = stats.seek_file_level;
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
    }
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
}
</pre>
</div>
</div>
</li>

<li><a id="org2dad711"></a>GetOverlappingInputs<br />
<div class="outline-text-5" id="text-10-3-11-14">
<p>
得到某个level下面所有和[begin,end]有overlap的文件.语义不知道是否理解正确.因为代码里面有个地方没有太看懂.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Store in "*inputs" all files in "level" that overlap [begin,end]</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold;">GetOverlappingInputs</span>(
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">begin</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">end</span>,
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;* <span style="font-weight: bold; font-style: italic;">inputs</span>) {
  inputs-&gt;clear();
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">user_begin</span>, <span style="font-weight: bold; font-style: italic;">user_end</span>;
  <span style="font-weight: bold;">if</span> (begin != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    user_begin = begin-&gt;user_key();
  }
  <span style="font-weight: bold;">if</span> (end != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    user_end = end-&gt;user_key();
  }
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">user_cmp</span> = vset_-&gt;icmp_.user_comparator();
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; files_[level].size(); ) {
    <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = files_[level][i++];
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">file_start</span> = f-&gt;smallest.user_key();
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">file_limit</span> = f-&gt;largest.user_key();
    <span style="font-weight: bold;">if</span> (begin != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"f" is completely before specified range; skip it</span>
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (end != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"f" is completely after specified range; skip it</span>
    } <span style="font-weight: bold;">else</span> {
      inputs-&gt;push_back(f);
      <span style="font-weight: bold;">if</span> (level == 0) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">todo:&#23454;&#29616;&#19978;&#21487;&#33021;&#23384;&#22312;&#38382;&#39064;&#21543;.&#30475;&#19978;&#21435;&#23545;&#20110;level0&#30340;&#35805;&#20284;&#20046;&#22312;&#19981;&#26029;&#22320;&#36807;&#22823;&#33539;&#22260;.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Level-0 files may overlap each other.  So check if the newly</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">added file has expanded the range.  If so, restart search.</span>
        <span style="font-weight: bold;">if</span> (begin != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; 0) {
          user_begin = file_start;
          inputs-&gt;clear();
          i = 0;
        } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (end != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_end) &gt; 0) {
          user_end = file_limit;
          inputs-&gt;clear();
          i = 0;
        }
      }
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org974e319"></a>OverlapInLevel<br />
<div class="outline-text-5" id="text-10-3-11-15">
<p>
判断某个level里面是否有文件和[small,large]这个范围内容的key重叠
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold;">OverlapInLevel</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>,
                             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">smallest_user_key</span>,
                             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">largest_user_key</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(level&gt;0)&#30340;&#35805;&#34920;&#31034;&#27599;&#20010;&#25991;&#20214;&#27809;&#26377;&#37325;&#21472;&#30340;&#37096;&#20998;.</span>
  <span style="font-weight: bold;">return</span> SomeFileOverlapsRange(vset_-&gt;icmp_, (level &gt; 0), files_[level],
                               smallest_user_key, largest_user_key);
}
</pre>
</div>
</div>
</li>

<li><a id="orgf603b06"></a>PickLevelForMemTableOutput<br />
<div class="outline-text-5" id="text-10-3-11-16">
<p>
根据[small,large]这个范畴选择某个level来作为memtable的output.这个range应该就是memtable的range.
这个策略比较精巧。这个策略在常数部分定义注释里面给出来了。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">db/dbformat.h</span>

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;level0&#36807;&#20302;&#30340;&#35805;&#37027;&#20040;&#20250;&#36896;&#25104;&#36807;&#22810;compaction</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#26159;level0&#22810;&#39640;&#30340;&#35805;&#37027;&#20040;&#20250;&#28010;&#36153;&#30913;&#30424;&#31354;&#38388;&#22240;&#20026;key&#30340;&#37325;&#22797;.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Maximum level to which a new compacted memtable is pushed if it</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">does not create overlap.  We try to push to level 2 to avoid the</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">relatively expensive level 0=&gt;1 compactions and to avoid some</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">expensive manifest file operations.  We do not push all the way to</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the largest level since that can generate a lot of wasted disk</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">space if the same key space is being repeatedly overwritten.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kMaxMemCompactLevel</span> = 2;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">db/version_set.cc</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kTargetFileSize</span> = 2 * 1048576;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Maximum bytes of overlaps in grandparent (i.e., level+2) before we</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">stop building a single file in a level-&gt;level+1 compaction.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">kMaxGrandParentOverlapBytes</span> = 10 * kTargetFileSize;
</pre>
</div>

<p>
#=BEGIN<sub>SRC</sub> C++
int Version::PickLevelForMemTableOutput(
    const Slice&amp; smallest<sub>user</sub><sub>key</sub>,
    const Slice&amp; largest<sub>user</sub><sub>key</sub>) {
  int level = 0;
  // 首先判断和level0是否有overlap.如果有overlapd的话那么选择level0.
  if (!OverlapInLevel(0, &amp;smallest<sub>user</sub><sub>key</sub>, &amp;largest<sub>user</sub><sub>key</sub>)) {
    <i>/ Push to next level if there is no overlap in next level,
    /</i> and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest<sub>user</sub><sub>key</sub>, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest<sub>user</sub><sub>key</sub>, 0, static<sub>cast</sub>&lt;ValueType&gt;(0));
    std::vector&lt;FileMetaData*&gt; overlaps;
    while (level &lt; config::kMaxMemCompactLevel) {
      <i>/ 判断和其他level是否有overlap.如果存在overlap的那么也选择.
      /</i> &gt;0的level是不允许overlap的.
      if (OverlapInLevel(level + 1, &amp;smallest<sub>user</sub><sub>key</sub>, &amp;largest<sub>user</sub><sub>key</sub>)) {
        break;
      }
      <i>/ 如果没有overlap的话那么判断和grandparent level重叠文件.判断重叠文件大小.
      /</i> 这个策略没有太明白.
      <i>/ 关于这个策略估计可以从Compaction::IsTrivialMove的注释里面看到.这里应该是担心grand parent本身就存在很多overlap
      /</i> 如果放在level+1做compaction的话，会造成grand parent这个部分合并时间过长.
      <i>/ 从值上来看意思应该是存在overlap的文件数目不应该超过10个(假设每个overlap文件都是MaxSizeForLevel的).
  /</i> Avoid a move if there is lots of overlapping grandparent data.
   <i>/ Otherwise, the move could create a parent file that will require
  /</i> a very expensive merge later on.
      GetOverlappingInputs(level + 2, &amp;start, &amp;limit, &amp;overlaps);
      const int64<sub>t</sub> sum = TotalFileSize(overlaps);
      if (sum &gt; kMaxGrandParentOverlapBytes) {
        break;
      }
      level++;
    }
  }
  return level;
}
#+END<sub>SRC</sub>
</p>
</div>
</li>

<li><a id="org16e88d9"></a>DebugString<br />
<div class="outline-text-5" id="text-10-3-11-17">
<p>
DebugString作为Version的调试信息打印出来.我们可以稍微得到一点启发吧.尤其如果是自己调试的话.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold;">DebugString</span>() <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">r</span>;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">E.g.,</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">--- level 1 ---</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">17:123['a' .. 'd']</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">20:43['e' .. 'g']</span>
    r.append(<span style="font-style: italic;">"--- level "</span>);
    AppendNumberTo(&amp;r, level);
    r.append(<span style="font-style: italic;">" ---\n"</span>);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">files</span> = files_[level];
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; files.size(); i++) {
      r.push_back(<span style="font-style: italic;">' '</span>);
      AppendNumberTo(&amp;r, files[i]-&gt;number); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file_number</span>
      r.push_back(<span style="font-style: italic;">':'</span>);
      AppendNumberTo(&amp;r, files[i]-&gt;file_size); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file&#22823;&#23567;.</span>
      r.append(<span style="font-style: italic;">"["</span>);
      r.append(files[i]-&gt;smallest.DebugString()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#23567;&#21644;&#26368;&#22823;&#30340;key&#30340;&#25171;&#21360;.</span>
      r.append(<span style="font-style: italic;">" .. "</span>);
      r.append(files[i]-&gt;largest.DebugString());
      r.append(<span style="font-style: italic;">"]\n"</span>);
    }
  }
  <span style="font-weight: bold;">return</span> r;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org394f8a1" class="outline-4">
<h4 id="org394f8a1"><span class="section-number-4">10.3.12</span> VersionSet</h4>
<div class="outline-text-4" id="text-10-3-12">
<p>
db/version<sub>set.h</sub> VersionSet用来管理不同的Version并且应该维护了一些全局信息.还是首先看看结构
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">VersionSet</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>,
             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>* <span style="font-weight: bold; font-style: italic;">options</span>,
             <span style="font-weight: bold; text-decoration: underline;">TableCache</span>* <span style="font-weight: bold; font-style: italic;">table_cache</span>,
             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>*);
  ~<span style="font-weight: bold;">VersionSet</span>();
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">env_</span>;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">dbname_</span>;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">options_</span>;
  <span style="font-weight: bold; text-decoration: underline;">TableCache</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">table_cache_</span>;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span> <span style="font-weight: bold; font-style: italic;">icmp_</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">next_file_number_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#19968;&#20010;&#20998;&#37197;&#30340;file number</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">manifest_file_number_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">manifest file number.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">last_sequence_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#27425;&#25805;&#20316;&#30340;sequence.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;LogNumber&#21644;PrevLogNumber&#27880;&#37322;&#21487;&#20197;&#30475;&#20986;&#26469;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#21035;&#34920;&#31034;&#24403;&#21069;&#20351;&#29992;&#30340;log number&#20197;&#21450;&#20043;&#21069;&#20351;&#29992;&#30340;log number(&#24403;&#21069;&#27491;&#22312;&#34987;&#21387;&#32553;).</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">log_number_</span>; <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">prev_log_number_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0 or backing store for memtable being compacted</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Opened lazily</span>
  <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">descriptor_file_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">manifest&#25991;&#20214;</span>
  <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Writer</span>* <span style="font-weight: bold; font-style: italic;">descriptor_log_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">manifest&#20197;log&#24418;&#24335;&#25171;&#24320;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Version</span> <span style="font-weight: bold; font-style: italic;">dummy_versions_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Head of circular doubly-linked list of versions. // &#20026;&#20102;&#32452;&#32455;&#31216;&#20026;&#38142;&#34920;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">current_</span>;        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">== dummy_versions_.prev_ // &#24403;&#21069;version</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Per-level key at which the next compaction at that level should start.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Either an empty string, or a valid InternalKey.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#27599;&#23618;&#30340;&#35805;&#37117;&#20250;&#35774;&#32622;&#19968;&#20010;key.&#21482;&#26377;&gt;&#36825;&#23618;&#35774;&#32622;&#30340;key&#25165;&#20801;&#35768;&#36827;&#34892;compaction.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">compact_pointer_</span>[<span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010;level&#36827;&#34892;compaction&#20351;&#29992;&#30340;internal key</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">todo:&#20284;&#20046;&#27599;&#20010;level&#36827;&#34892;compaction&#37117;&#37197;&#19978;&#20102;&#19968;&#20010;internal key</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">DONE:&#35760;&#24405;&#27599;&#23618;&#30340;&#26368;&#22823;key.</span>
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org093bb83"></a>VersionSet<br />
<div class="outline-text-5" id="text-10-3-12-1">
<p>
首先看看构造函数和析构函数.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">VersionSet</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>,
                       <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>* <span style="font-weight: bold; font-style: italic;">options</span>,
                       <span style="font-weight: bold; text-decoration: underline;">TableCache</span>* <span style="font-weight: bold; font-style: italic;">table_cache</span>,
                       <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>* <span style="font-weight: bold; font-style: italic;">cmp</span>)
    : env_(options-&gt;env),
      dbname_(dbname),
      options_(options),
      table_cache_(table_cache),
      icmp_(*cmp),
      next_file_number_(2),
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#38754;&#36825;&#20123;&#23383;&#27573;&#37117;&#26159;&#36890;&#36807;Recover&#24674;&#22797;&#30340;.</span>
      manifest_file_number_(0),  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Filled by Recover()</span>
      last_sequence_(0),
      log_number_(0),
      prev_log_number_(0),
      descriptor_file_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      descriptor_log_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      dummy_versions_(<span style="font-weight: bold;">this</span>),
      current_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
  AppendVersion(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>(<span style="font-weight: bold;">this</span>)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28155;&#21152;&#19968;&#20010;&#24403;&#21069;version.</span>
}
<span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::~<span style="font-weight: bold;">VersionSet</span>() {
  current_-&gt;Unref();
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26512;&#26500;&#26102;&#20505;&#24517;&#39035;&#30830;&#20445;&#37324;&#38754;&#27809;&#26377;&#20219;&#20309;&#29256;&#26412;.</span>
  assert(dummy_versions_.next_ == &amp;dummy_versions_);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">List must be empty</span>
  <span style="font-weight: bold;">delete</span> descriptor_log_;
  <span style="font-weight: bold;">delete</span> descriptor_file_;
}
</pre>
</div>
</div>
</li>

<li><a id="orgbb6ff2b"></a>NeedsCompaction<br />
<div class="outline-text-5" id="text-10-3-12-2">
<p>
当前versionset是否需要触发compaction操作.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns true iff some level needs a compaction.</span>
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">NeedsCompaction</span>() <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span> = current_;
  <span style="font-weight: bold;">return</span> (v-&gt;compaction_score_ &gt;= 1) || (v-&gt;file_to_compact_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
}
</pre>
</div>
</div>
</li>

<li><a id="org3bce1c6"></a>AppendVersion<br />
<div class="outline-text-5" id="text-10-3-12-3">
<p>
添加version.非常简单修改引用计数挂载链表上.将version挂在version<sub>set下面的话可以使得</sub>
version<sub>set了解到哪些文件依然是被正在使用的</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">AppendVersion</span>(<span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Make "v" current</span>
  assert(v-&gt;refs_ == 0);
  assert(v != current_);
  <span style="font-weight: bold;">if</span> (current_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    current_-&gt;Unref();
  }
  current_ = v;
  v-&gt;Ref();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Append to linked list</span>
  v-&gt;prev_ = dummy_versions_.prev_;
  v-&gt;next_ = &amp;dummy_versions_;
  v-&gt;prev_-&gt;next_ = v;
  v-&gt;next_-&gt;prev_ = v;
}
</pre>
</div>
</div>
</li>

<li><a id="org261ef96"></a>NumLevelFiles<br />
<div class="outline-text-5" id="text-10-3-12-4">
<p>
得到某个level的文件数目.以current这个Version来计算的
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">NumLevelFiles</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>) <span style="font-weight: bold;">const</span> {
  assert(level &gt;= 0);
  assert(level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels);
  <span style="font-weight: bold;">return</span> current_-&gt;files_[level].size();
}
</pre>
</div>
</div>
</li>

<li><a id="orgbc404d5"></a>NumLevelBytes<br />
<div class="outline-text-5" id="text-10-3-12-5">
<p>
某个level的文件大小.以current这个Version来计算的.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">NumLevelBytes</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>) <span style="font-weight: bold;">const</span> {
  assert(level &gt;= 0);
  assert(level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels);
  <span style="font-weight: bold;">return</span> TotalFileSize(current_-&gt;files_[level]);
}
</pre>
</div>
</div>
</li>

<li><a id="orge7a4829"></a>TotalFileSize<br />
<div class="outline-text-5" id="text-10-3-12-6">
<p>
根据file meta data得到所有文件大小.非常简单因为里面有file<sub>size</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold;">TotalFileSize</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">files</span>) {
  <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">sum</span> = 0;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; files.size(); i++) {
    sum += files[i]-&gt;file_size;
  }
  <span style="font-weight: bold;">return</span> sum;
}
</pre>
</div>
</div>
</li>

<li><a id="orgd700220"></a>MarkFileNumberUsed<br />
<div class="outline-text-5" id="text-10-3-12-7">
<p>
标记当前使用了file<sub>number进度.number表示已经使用的进度,所以下次分配必须</sub>+1.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">MarkFileNumberUsed</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">number</span>) {
  <span style="font-weight: bold;">if</span> (next_file_number_ &lt;= number) {
    next_file_number_ = number + 1;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org6ccb559"></a>ApproximateOffsetOf<br />
<div class="outline-text-5" id="text-10-3-12-8">
<p>
判断这个key在数据库内部大致偏移是多少.从这个实现里面我们可以看到.对于level-0的文件并不是排序的
对于level&gt;0的文件都是按照range进行排序的。并且这个排序是按照smallest来进行排序的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">ApproximateOffsetOf</span>(<span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>&amp; <span style="font-weight: bold; font-style: italic;">ikey</span>) {
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">result</span> = 0;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">files</span> = v-&gt;files_[level];
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; files.size(); i++) {
      <span style="font-weight: bold;">if</span> (icmp_.Compare(files[i]-&gt;largest, ikey) &lt;= 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27604;largest key&#22823;&#30340;&#35805;&#37027;&#20040;&#36825;&#20010;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#20559;&#31227;&#38656;&#35201;&#31639;&#19978;&#25972;&#20010;&#25991;&#20214;.&#20294;&#26159;&#36825;&#37324;&#36824;&#21253;&#25324;&#20102;index block,meta block&#20197;&#21450;footer&#22823;&#23567;.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#21482;&#33021;&#22815;&#35828;&#26159;&#22823;&#33268;&#22823;&#23567;.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Entire file is before "ikey", so just add the file size</span>
        result += files[i]-&gt;file_size;
      } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (icmp_.Compare(files[i]-&gt;smallest, ikey) &gt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;smallest&#27604;&#24403;&#21069;key&#22823;&#30340;&#35805;&#37027;&#20040;&#21462;&#28040;.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Entire file is after "ikey", so ignore</span>
        <span style="font-weight: bold;">if</span> (level &gt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;&gt;0&#30340;level&#37027;&#20040;&#21487;&#20197;&#30452;&#25509;&#21462;&#28040;.&#22240;&#20026;&#36825;&#20010;&#37096;&#20998;&#30340;file&#37117;&#26159;&#25353;&#29031;smallest&#25490;&#24207;&#30340;.</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Files other than level 0 are sorted by meta-&gt;smallest, so</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">no further files in this level will contain data for</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"ikey".</span>
          <span style="font-weight: bold;">break</span>;
        }
      } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#23384;&#22312;&#20132;&#38598;&#30340;&#35805;&#37027;&#20040;&#37027;&#20040;&#21487;&#20197;&#26500;&#36896;&#20986;Table&#23545;&#35937;&#25214;&#21040;&#36825;&#20010;key&#22823;&#33268;&#20559;&#31227;.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"ikey" falls in the range for this table.  Add the</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">approximate offset of "ikey" within the table.</span>
        <span style="font-weight: bold; text-decoration: underline;">Table</span>* <span style="font-weight: bold; font-style: italic;">tableptr</span>;
        <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">iter</span> = table_cache_-&gt;NewIterator(
            ReadOptions(), files[i]-&gt;number, files[i]-&gt;file_size, &amp;tableptr);
        <span style="font-weight: bold;">if</span> (tableptr != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
          result += tableptr-&gt;ApproximateOffsetOf(ikey.Encode());
        }
        <span style="font-weight: bold;">delete</span> iter;
      }
    }
  }
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</li>

<li><a id="org7809156"></a>AddLiveFiles<br />
<div class="outline-text-5" id="text-10-3-12-9">
<p>
将version set里面所有version所持有的文件收集起来.非常简单:).
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">AddLiveFiles</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">set</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt;* <span style="font-weight: bold; font-style: italic;">live</span>) {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span> = dummy_versions_.next_;
       v != &amp;dummy_versions_;
       v = v-&gt;next_) {
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">files</span> = v-&gt;files_[level];
      <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; files.size(); i++) {
        live-&gt;insert(files[i]-&gt;number);
      }
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org9f70e19"></a>LevelSummary<br />
<div class="outline-text-5" id="text-10-3-12-10">
<p>
每层level的文件个数分别是多少.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">LevelSummary</span>(<span style="font-weight: bold; text-decoration: underline;">LevelSummaryStorage</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Update code if kNumLevels changes</span>
  assert(<span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels == 7);
  snprintf(scratch-&gt;buffer, <span style="font-weight: bold;">sizeof</span>(scratch-&gt;buffer),
           <span style="font-style: italic;">"files[ %d %d %d %d %d %d %d ]"</span>,
           <span style="font-weight: bold; text-decoration: underline;">int</span>(current_-&gt;files_[0].size()),
           <span style="font-weight: bold; text-decoration: underline;">int</span>(current_-&gt;files_[1].size()),
           <span style="font-weight: bold; text-decoration: underline;">int</span>(current_-&gt;files_[2].size()),
           <span style="font-weight: bold; text-decoration: underline;">int</span>(current_-&gt;files_[3].size()),
           <span style="font-weight: bold; text-decoration: underline;">int</span>(current_-&gt;files_[4].size()),
           <span style="font-weight: bold; text-decoration: underline;">int</span>(current_-&gt;files_[5].size()),
           <span style="font-weight: bold; text-decoration: underline;">int</span>(current_-&gt;files_[6].size()));
  <span style="font-weight: bold;">return</span> scratch-&gt;buffer;
}
</pre>
</div>
</div>
</li>

<li><a id="orgf292b4b"></a>WriteSnapshot<br />
<div class="outline-text-5" id="text-10-3-12-11">
<p>
将当前current version写入到磁盘记为log.方式是将内容copy到version edit对象里面去然后持久化.
过程还是非常简单吧:).
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">WriteSnapshot</span>(<span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Writer</span>* <span style="font-weight: bold; font-style: italic;">log</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO: Break up into multiple records to reduce memory usage on recovery?</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Save metadata</span>
  <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span> <span style="font-weight: bold; font-style: italic;">edit</span>;
  edit.SetComparatorName(icmp_.user_comparator()-&gt;Name());

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Save compaction pointers</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
    <span style="font-weight: bold;">if</span> (!compact_pointer_[level].empty()) {
      <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">key</span>;
      key.DecodeFrom(compact_pointer_[level]);
      edit.SetCompactPointer(level, key);
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Save files</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">files</span> = current_-&gt;files_[level];
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; files.size(); i++) {
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = files[i];
      edit.AddFile(level, f-&gt;number, f-&gt;file_size, f-&gt;smallest, f-&gt;largest);
    }
  }

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">record</span>;
  edit.EncodeTo(&amp;record);
  <span style="font-weight: bold;">return</span> log-&gt;AddRecord(record);
}
</pre>
</div>
</div>
</li>

<li><a id="org4ea2cfd"></a>Finalize<br />
<div class="outline-text-5" id="text-10-3-12-12">
<p>
所谓的Finalize的含义应该是，如果我们不希望修改version这个结构之后我们应该做的事情。可能叫做Finish会更好。
相当于针对这个version而言的话，最高一级的compaction level是什么，分数是多少.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">Finalize</span>(<span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Precomputed best level for next compaction</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">best_level</span> = -1;
  <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">best_score</span> = -1;

  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels-1; level++) {
    <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">score</span>;
    <span style="font-weight: bold;">if</span> (level == 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We treat level-0 specially by bounding the number of files</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">instead of number of bytes for two reasons:</span>
      <span style="font-weight: bold; font-style: italic;">//</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(1) With larger write-buffer sizes, it is nice not to do too</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">many level-0 compactions.</span>
      <span style="font-weight: bold; font-style: italic;">//</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(2) The files in level-0 are merged on every read and</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">therefore we wish to avoid too many files when the individual</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file size is small (perhaps because of a small write-buffer</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">setting, or very high compression ratios, or lots of</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">overwrites/deletions).</span>
      score = v-&gt;files_[level].size() /
          <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">double</span>&gt;(<span style="font-weight: bold; text-decoration: underline;">config</span>::kL0_CompactionTrigger);
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Compute the ratio of current size to size limit.</span>
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">level_bytes</span> = TotalFileSize(v-&gt;files_[level]);
      score = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">double</span>&gt;(level_bytes) / MaxBytesForLevel(level);
    }

    <span style="font-weight: bold;">if</span> (score &gt; best_score) {
      best_level = level;
      best_score = score;
    }
  }

  v-&gt;compaction_level_ = best_level;
  v-&gt;compaction_score_ = best_score;
}
</pre>
</div>
</div>
</li>

<li><a id="org4b970f0"></a>Recover<br />
<div class="outline-text-5" id="text-10-3-12-13">
<p>
从db<sub>impl.cc里面的DB</sub>::Open可以看到,这里的Recover并没有将剩余的version<sub>edit回放完成</sub>.
回放这个部分在LogAndApply里面完成.所以Recover可能只是恢复到以前某个状态.将当前的
CURRENT里面的manifest文件回放之后就得到最新的内容.然后根据里面的log信息回放后面的内容.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">Recover</span>() {
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">LogReporter</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Reader</span>::<span style="font-weight: bold; text-decoration: underline;">Reporter</span> {
    <span style="font-weight: bold; text-decoration: underline;">Status</span>* <span style="font-weight: bold; font-style: italic;">status</span>;
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Corruption</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">s</span>) {
      <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">this</span>-&gt;status-&gt;ok()) *<span style="font-weight: bold;">this</span>-&gt;status = s;
    }
  };

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462;&#24403;&#21069;current&#36825;&#20010;&#20869;&#23481;,&#24471;&#21040;&#26368;&#26032;&#30340;manifest&#25991;&#20214;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read "CURRENT" file, which contains a pointer to the current manifest file</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">current</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = ReadFileToString(env_, CurrentFileName(dbname_), &amp;current);
  <span style="font-weight: bold;">if</span> (!s.ok()) {
    <span style="font-weight: bold;">return</span> s;
  }
  <span style="font-weight: bold;">if</span> (current.empty() || current[current.size()-1] != <span style="font-style: italic;">'\n'</span>) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"CURRENT file does not end with newline"</span>);
  }
  current.resize(current.size() - 1);

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">dscname</span> = dbname_ + <span style="font-style: italic;">"/"</span> + current;
  <span style="font-weight: bold; text-decoration: underline;">SequentialFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>;
  s = env_-&gt;NewSequentialFile(dscname, &amp;file);
  <span style="font-weight: bold;">if</span> (!s.ok()) {
    <span style="font-weight: bold;">return</span> s;
  }

  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">have_log_number</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">have_prev_log_number</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">have_next_file</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">have_last_sequence</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">next_file</span> = 0;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">last_sequence</span> = 0;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">log_number</span> = 0;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">prev_log_number</span> = 0;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30456;&#24403;&#20110;&#20174;empty status&#26469;&#26500;&#24314;current version.</span>
  <span style="font-weight: bold; text-decoration: underline;">Builder</span> <span style="font-weight: bold; font-style: italic;">builder</span>(<span style="font-weight: bold;">this</span>, current_);

  {
    <span style="font-weight: bold; text-decoration: underline;">LogReporter</span> <span style="font-weight: bold; font-style: italic;">reporter</span>;
    reporter.status = &amp;s;
    <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Reader</span> <span style="font-weight: bold; font-style: italic;">reader</span>(file, &amp;reporter, <span style="font-weight: bold; text-decoration: underline;">true</span><span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">checksum*/</span>, 0<span style="font-weight: bold; font-style: italic;">/*</span><span style="font-weight: bold; font-style: italic;">initial_offset*/</span>);
    <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">record</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">scratch</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25353;&#29031;&#27599;&#26465;log&#20869;&#23481;&#35835;&#21462;.&#37324;&#38754;&#30340;&#20869;&#23481;&#37117;&#26159;version edit.</span>
    <span style="font-weight: bold;">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) {
      <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span> <span style="font-weight: bold; font-style: italic;">edit</span>;
      s = edit.DecodeFrom(record);
      <span style="font-weight: bold;">if</span> (s.ok()) {
        <span style="font-weight: bold;">if</span> (edit.has_comparator_ &amp;&amp;
            edit.comparator_ != icmp_.user_comparator()-&gt;Name()) {
          s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::InvalidArgument(
              edit.comparator_ + <span style="font-style: italic;">"does not match existing comparator "</span>,
              icmp_.user_comparator()-&gt;Name());
        }
      }

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30452;&#25509;apply&#19978;&#21435;.</span>
      <span style="font-weight: bold;">if</span> (s.ok()) {
        builder.Apply(&amp;edit);
      }

      <span style="font-weight: bold;">if</span> (edit.has_log_number_) {
        log_number = edit.log_number_;
        have_log_number = <span style="font-weight: bold; text-decoration: underline;">true</span>;
      }

      <span style="font-weight: bold;">if</span> (edit.has_prev_log_number_) {
        prev_log_number = edit.prev_log_number_;
        have_prev_log_number = <span style="font-weight: bold; text-decoration: underline;">true</span>;
      }

      <span style="font-weight: bold;">if</span> (edit.has_next_file_number_) {
        next_file = edit.next_file_number_;
        have_next_file = <span style="font-weight: bold; text-decoration: underline;">true</span>;
      }

      <span style="font-weight: bold;">if</span> (edit.has_last_sequence_) {
        last_sequence = edit.last_sequence_;
        have_last_sequence = <span style="font-weight: bold; text-decoration: underline;">true</span>;
      }
    }
  }
  <span style="font-weight: bold;">delete</span> file;
  file = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold;">if</span> (!have_next_file) {
      s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"no meta-nextfile entry in descriptor"</span>);
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (!have_log_number) {
      s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"no meta-lognumber entry in descriptor"</span>);
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (!have_last_sequence) {
      s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"no last-sequence-number entry in descriptor"</span>);
    }

    <span style="font-weight: bold;">if</span> (!have_prev_log_number) {
      prev_log_number = 0;
    }

    MarkFileNumberUsed(prev_log_number);
    MarkFileNumberUsed(log_number);
  }

  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>(<span style="font-weight: bold;">this</span>);
    builder.SaveTo(v);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Install recovered version</span>
    Finalize(v);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22686;&#21152;&#36825;&#20040;&#19968;&#20010;version&#20316;&#20026;&#24403;&#21069;current version.</span>
    AppendVersion(v);
    manifest_file_number_ = next_file;
    next_file_number_ = next_file + 1;
    last_sequence_ = last_sequence;
    log_number_ = log_number;
    prev_log_number_ = prev_log_number;
  }

  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="org4bd87a1"></a>LogAndApply<br />
<div class="outline-text-5" id="text-10-3-12-14">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">LogAndApply</span>(<span style="font-weight: bold; text-decoration: underline;">VersionEdit</span>* <span style="font-weight: bold; font-style: italic;">edit</span>, <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">Mutex</span>* <span style="font-weight: bold; font-style: italic;">mu</span>) {
  <span style="font-weight: bold;">if</span> (edit-&gt;has_log_number_) {
    assert(edit-&gt;log_number_ &gt;= log_number_);
    assert(edit-&gt;log_number_ &lt; next_file_number_);
  } <span style="font-weight: bold;">else</span> {
    edit-&gt;SetLogNumber(log_number_);
  }

  <span style="font-weight: bold;">if</span> (!edit-&gt;has_prev_log_number_) {
    edit-&gt;SetPrevLogNumber(prev_log_number_);
  }

  edit-&gt;SetNextFile(next_file_number_);
  edit-&gt;SetLastSequence(last_sequence_);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#36807;&#31243;&#24212;&#35813;&#26159;&#23558;edit&#30340;&#20462;&#25913;&#25918;&#22312;current_&#37324;&#38754;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23558;edit&#20316;&#29992;&#22312;current&#19978;&#38754;&#65292;&#23558;current_&#20445;&#23384;&#21040;v&#37324;&#38754;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23545;v&#36827;&#34892;finish.</span>
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>(<span style="font-weight: bold;">this</span>);
  {
    <span style="font-weight: bold; text-decoration: underline;">Builder</span> <span style="font-weight: bold; font-style: italic;">builder</span>(<span style="font-weight: bold;">this</span>, current_);
    builder.Apply(edit);
    builder.SaveTo(v);
  }
  Finalize(v);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Initialize new descriptor log file if necessary by creating</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a temporary file that contains a snapshot of the current version.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">new_manifest_file</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
  <span style="font-weight: bold;">if</span> (descriptor_log_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No reason to unlock *mu here since we only hit this path in the</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">first call to LogAndApply (when opening the database).</span>
    assert(descriptor_file_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);
    edit-&gt;SetNextFile(next_file_number_);
    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);
    <span style="font-weight: bold;">if</span> (s.ok()) {
      descriptor_log_ = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">log</span>::<span style="font-weight: bold; text-decoration: underline;">Writer</span>(descriptor_file_);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;current&#20570;snapshot&#20445;&#23384;&#22312;descriptor log&#37324;&#38754;.</span>
      s = WriteSnapshot(descriptor_log_);
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Unlock during expensive MANIFEST log write</span>
  {
    mu-&gt;Unlock();

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Write new record to MANIFEST log</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20010;&#20462;&#25913;&#20063;&#20445;&#23384;&#22312;log&#37324;&#38754;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29616;&#22312;&#27604;&#36739;&#25285;&#24515;&#26368;&#21518;&#30340;&#32467;&#26500;.&#20284;&#20046;&#29616;&#22312;snapshot&#20197;&#21450;log&#20869;&#23481;&#37117;&#28151;&#22312;&#19968;&#36215;&#20102;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20043;&#21069;&#22312;descriptor_log&#37324;&#38754;&#22635;&#20889;&#20102;current version&#20869;&#23481;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32780;&#36825;&#37324;&#36824;&#28155;&#21152;&#20102;edit&#22686;&#37327;&#20869;&#23481;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#26684;&#24335;&#29616;&#22312;&#30475;&#19978;&#21435;&#36824;&#22909;.&#21040;&#26102;&#20505;&#21487;&#33021;&#38656;&#35201;&#20027;&#35201;&#30475;&#30475;Recover&#20869;&#23481;.</span>
    <span style="font-weight: bold;">if</span> (s.ok()) {
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">record</span>;
      edit-&gt;EncodeTo(&amp;record);
      s = descriptor_log_-&gt;AddRecord(record);
      <span style="font-weight: bold;">if</span> (s.ok()) {
        s = descriptor_file_-&gt;Sync(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#25105;&#20204;&#38656;&#35201;&#20570;sync.</span>
      }
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we just created a new descriptor file, install it by writing a</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">new CURRENT file that points to it.</span>
    <span style="font-weight: bold;">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) {
      s = SetCurrentFile(env_, dbname_, manifest_file_number_);
    }

    mu-&gt;Lock();
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Install the new version</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20316;&#20026;&#24403;&#21069;current version&#23384;&#22312;.</span>
  <span style="font-weight: bold;">if</span> (s.ok()) {
    AppendVersion(v);
    log_number_ = edit-&gt;log_number_;
    prev_log_number_ = edit-&gt;prev_log_number_;
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">delete</span> v;
    <span style="font-weight: bold;">if</span> (!new_manifest_file.empty()) {
      <span style="font-weight: bold;">delete</span> descriptor_log_;
      <span style="font-weight: bold;">delete</span> descriptor_file_;
      descriptor_log_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
      descriptor_file_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
      env_-&gt;DeleteFile(new_manifest_file);
    }
  }

  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="org9a420ad"></a>GetRange<br />
<div class="outline-text-5" id="text-10-3-12-15">
<p>
得到input files里面的最大和最小key.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Stores the minimal range that covers all entries in inputs in</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">*smallest, *largest.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: inputs is not empty</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">GetRange</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">inputs</span>,
                          <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">smallest</span>,
                          <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">largest</span>) {
  assert(!inputs.empty());
  smallest-&gt;Clear();
  largest-&gt;Clear();
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; inputs.size(); i++) {
    <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = inputs[i];
    <span style="font-weight: bold;">if</span> (i == 0) {
      *smallest = f-&gt;smallest;
      *largest = f-&gt;largest;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold;">if</span> (icmp_.Compare(f-&gt;smallest, *smallest) &lt; 0) {
        *smallest = f-&gt;smallest;
      }
      <span style="font-weight: bold;">if</span> (icmp_.Compare(f-&gt;largest, *largest) &gt; 0) {
        *largest = f-&gt;largest;
      }
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org8e32feb"></a>PickCompaction<br />
<div class="outline-text-5" id="text-10-3-12-16">
<p>
选择一个Compaction来进行操作.对于选择Compaction应该比较具有策略性的。然后丢给DB去执行这个Compaction操作.
PickCompaction和CompactRange都是compaction行为.不过PickCompaction是自动触发的，而CompactRange
是用户自己手动触发的.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Compaction</span>* <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">PickCompaction</span>() {
  <span style="font-weight: bold; text-decoration: underline;">Compaction</span>* <span style="font-weight: bold; font-style: italic;">c</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We prefer compactions triggered by too much data in a level over  // the compactions triggered by seeks.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454;&#24403;&#21069;version&#30340;&#32479;&#35745;&#32467;&#26524;&#21028;&#26029;&#26159;&#21542;&#38656;&#35201;compaction.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">size_compaction</span> = (current_-&gt;compaction_score_ &gt;= 1);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">seek_compaction</span> = (current_-&gt;file_to_compact_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold;">if</span> (size_compaction) {
    level = current_-&gt;compaction_level_;
    assert(level &gt;= 0);
    assert(level+1 &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels);
    c = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span>(level);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Pick the first file that comes after compact_pointer_[level]</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; current_-&gt;files_[level].size(); i++) {
      <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = current_-&gt;files_[level][i];
      <span style="font-weight: bold;">if</span> (compact_pointer_[level].empty() ||
          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; 0) {
        c-&gt;inputs_[0].push_back(f);
        <span style="font-weight: bold;">break</span>;
      }
    }
    <span style="font-weight: bold;">if</span> (c-&gt;inputs_[0].empty()) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Wrap-around to the beginning of the key space</span>
      c-&gt;inputs_[0].push_back(current_-&gt;files_[level][0]);
    }
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (seek_compaction) {
    level = current_-&gt;file_to_compact_level_;
    c = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span>(level);
    c-&gt;inputs_[0].push_back(current_-&gt;file_to_compact_);
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29616;&#22312;&#24050;&#32463;&#36873;&#25321;&#22909;&#20102;&#19968;&#20010;&#25991;&#20214;&#26469;&#36827;&#34892;compaction.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#24403;&#21069;&#30340;version +ref count.</span>
  c-&gt;input_version_ = current_;
  c-&gt;input_version_-&gt;Ref();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Files in level 0 may overlap each other, so pick up all overlapping ones</span>
  <span style="font-weight: bold;">if</span> (level == 0) {
    <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">smallest</span>, <span style="font-weight: bold; font-style: italic;">largest</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#37322;&#20889;&#30340;&#38750;&#24120;&#28165;&#26970;&#20102;.</span>
    GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note that the next call will discard the file we placed in</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">c-&gt;inputs_[0] earlier and replace it with an overlapping set</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">which will include the picked file.</span>
    current_-&gt;GetOverlappingInputs(0, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[0]);
    assert(!c-&gt;inputs_[0].empty());
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36873;&#25321;&#20102;level&#30340;&#25991;&#20214;&#20043;&#21518;&#38656;&#35201;&#36873;&#25321;level+1&#30340;&#25991;&#20214;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25226;&#20854;&#20182;&#30340;input files&#23383;&#27573;&#22635;&#19978;.</span>
  SetupOtherInputs(c);

  <span style="font-weight: bold;">return</span> c;
}
</pre>
</div>
</div>
</li>

<li><a id="org86a1ace"></a>CompactRange<br />
<div class="outline-text-5" id="text-10-3-12-17">
<p>
DBImpl里面提供CompactRange打包成为一个Manual Compaction的请求提交到后端.然后判断
如果为Manual Compaction的话那么实际调用的还是VersionSet::CompactRange这个方法产生一个
Compaction对象真正进行执行.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Compaction</span>* <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">CompactRange</span>(
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">begin</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">end</span>) {
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt; <span style="font-weight: bold; font-style: italic;">inputs</span>;
  current_-&gt;GetOverlappingInputs(level, begin, end, &amp;inputs);
  <span style="font-weight: bold;">if</span> (inputs.empty()) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Avoid compacting too much in one shot in case the range is large.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21387;&#32553;&#33539;&#22260;&#30340;&#35805;&#21487;&#20197;&#25552;&#20132;&#22810;&#20010;input files&#20316;&#20026;&#24213;&#23618;level&#36755;&#20837;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#26159;&#36890;&#36807;&#25511;&#21046;&#22823;&#23567;&#26469;&#38480;&#21046;&#36755;&#20837;&#25991;&#20214;&#22810;&#23569;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">limit</span> = MaxFileSizeForLevel(level);
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">total</span> = 0;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; inputs.size(); i++) {
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">s</span> = inputs[i]-&gt;file_size;
    total += s;
    <span style="font-weight: bold;">if</span> (total &gt;= limit) {
      inputs.resize(i + 1);
      <span style="font-weight: bold;">break</span>;
    }
  }

  <span style="font-weight: bold; text-decoration: underline;">Compaction</span>* <span style="font-weight: bold; font-style: italic;">c</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span>(level);
  c-&gt;input_version_ = current_;
  c-&gt;input_version_-&gt;Ref();
  c-&gt;inputs_[0] = inputs;
  SetupOtherInputs(c);
  <span style="font-weight: bold;">return</span> c;
}
</pre>
</div>
</div>
</li>

<li><a id="org261d10f"></a>GetRange2<br />
<div class="outline-text-5" id="text-10-3-12-18">
<p>
得到input1和input2两个文件compaction之后的最小和最大key.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Stores the minimal range that covers all entries in inputs1 and inputs2</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">in *smallest, *largest.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: inputs is not empty</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">GetRange2</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">inputs1</span>,
                           <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">inputs2</span>,
                           <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">smallest</span>,
                           <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>* <span style="font-weight: bold; font-style: italic;">largest</span>) {
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt; <span style="font-weight: bold; font-style: italic;">all</span> = inputs1;
  all.insert(all.end(), inputs2.begin(), inputs2.end());
  GetRange(all, smallest, largest);
}
</pre>
</div>
</div>
</li>

<li><a id="org2cdcb68"></a>SetupOtherInputs<br />
<div class="outline-text-5" id="text-10-3-12-19">
<p>
将compaction的另外一层内容(input files)补齐.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">SetupOtherInputs</span>(<span style="font-weight: bold; text-decoration: underline;">Compaction</span>* <span style="font-weight: bold; font-style: italic;">c</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = c-&gt;level();
  <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">smallest</span>, <span style="font-weight: bold; font-style: italic;">largest</span>;
  GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;level+1&#37324;&#38754;&#26377;&#21738;&#20123;&#25991;&#20214;&#26159;&#23384;&#22312;&#37325;&#21472;&#30340;.</span>
  current_-&gt;GetOverlappingInputs(level+1, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[1]);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Get entire range covered by compaction</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24471;&#21040;&#25972;&#20010;compaction&#25152;&#35206;&#30422;&#30340;&#33539;&#22260;</span>
  <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">all_start</span>, <span style="font-weight: bold; font-style: italic;">all_limit</span>;
  GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">See if we can grow the number of inputs in "level" without</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">changing the number of "level+1" files we pick up.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35266;&#23519;&#26159;&#21542;&#21487;&#20197;&#25193;&#22823;level input files&#25968;&#37327;&#20294;&#26159;&#19981;&#36896;&#25104;level+1 input files&#25968;&#37327;&#21464;&#21270;.</span>
  <span style="font-weight: bold;">if</span> (!c-&gt;inputs_[1].empty()) {
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt; <span style="font-weight: bold; font-style: italic;">expanded0</span>;
    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);
    <span style="font-weight: bold;">if</span> (expanded0.size() &gt; c-&gt;inputs_[0].size()) {
      <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">new_start</span>, <span style="font-weight: bold; font-style: italic;">new_limit</span>;
      GetRange(expanded0, &amp;new_start, &amp;new_limit);
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt; <span style="font-weight: bold; font-style: italic;">expanded1</span>;
      current_-&gt;GetOverlappingInputs(level+1, &amp;new_start, &amp;new_limit,
                                     &amp;expanded1);
      <span style="font-weight: bold;">if</span> (expanded1.size() == c-&gt;inputs_[1].size()) {
        Log(options_-&gt;info_log,
            <span style="font-style: italic;">"Expanding@%d %d+%d to %d+%d\n"</span>,
            level,
            <span style="font-weight: bold; text-decoration: underline;">int</span>(c-&gt;inputs_[0].size()),
            <span style="font-weight: bold; text-decoration: underline;">int</span>(c-&gt;inputs_[1].size()),
            <span style="font-weight: bold; text-decoration: underline;">int</span>(expanded0.size()),
            <span style="font-weight: bold; text-decoration: underline;">int</span>(expanded1.size()));
        smallest = new_start;
        largest = new_limit;
        c-&gt;inputs_[0] = expanded0;
        c-&gt;inputs_[1] = expanded1;
        GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);
      }
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Compute the set of grandparent files that overlap this compaction</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(parent == level+1; grandparent == level+2)</span>
  <span style="font-weight: bold;">if</span> (level + 2 &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20551;&#35774;&#36825;&#20004;&#20010;&#21512;&#24182;&#20043;&#21518;,&#21644;level+2&#20250;&#26377;&#21738;&#20123;&#25991;&#20214;&#20986;&#29616;&#37325;&#21472;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20445;&#23384;&#22312;grandparents&#37324;&#38754;.</span>
    current_-&gt;GetOverlappingInputs(level + 2, &amp;all_start, &amp;all_limit,
                                   &amp;c-&gt;grandparents_);
  }

  <span style="font-weight: bold;">if</span> (<span style="font-weight: bold; text-decoration: underline;">false</span>) {
    Log(options_-&gt;info_log, <span style="font-style: italic;">"Compacting %d '%s' .. '%s'"</span>,
        level,
        smallest.DebugString().c_str(),
        largest.DebugString().c_str());
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Update the place where we will do the next compaction for this level.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We update this immediately instead of waiting for the VersionEdit</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to be applied so that if the compaction fails, we will try a different</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">key range next time.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20445;&#23384;&#21040;&#26412;&#23618;&#26368;&#22823;key.</span>
  compact_pointer_[level] = largest.Encode().ToString();
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;level&#30340;largest&#20445;&#23384;&#21040;edit&#37324;&#38754;.&#36825;&#20010;&#21487;&#33021;&#23545;&#20110;&#24674;&#22797;&#36215;&#26469;&#20043;&#21518;&#21487;&#33021;&#26377;&#29992;.</span>
  c-&gt;edit_.SetCompactPointer(level, largest);
}
</pre>
</div>
</div>
</li>

<li><a id="org6a98a4e"></a>MakeInputIterator<br />
<div class="outline-text-5" id="text-10-3-12-20">
<p>
针对Compaction而言我们可能需要读取多个文件设计的遍历器.底层应该是MergeIterator实现.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold;">MakeInputIterator</span>(<span style="font-weight: bold; text-decoration: underline;">Compaction</span>* <span style="font-weight: bold; font-style: italic;">c</span>) {
  <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span> <span style="font-weight: bold; font-style: italic;">options</span>;
  options.verify_checksums = options_-&gt;paranoid_checks;
  options.fill_cache = <span style="font-weight: bold; text-decoration: underline;">false</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Level-0 files have to be merged together.  For other levels,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we will make a concatenating iterator per level.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO(opt): use concatenating iterator for level-0 if there is no overlap</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&gt;0&#30340;level&#26469;&#35828;&#30340;&#35805;&#21487;&#20197;&#20351;&#29992;LevelFileNumIterator&#26469;&#24403;&#20570;&#36825;&#19968;&#23618;&#30340;iterator.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32780;&#23545;==0&#30340;level&#26469;&#35828;&#30340;&#35805;&#27599;&#19968;&#20010;&#25991;&#20214;&#20316;&#20026;&#19968;&#20010;iterator&#23384;&#22312;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">space</span> = (c-&gt;level() == 0 ? c-&gt;inputs_[0].size() + 1 : 2);
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>** <span style="font-weight: bold; font-style: italic;">list</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>*[<span style="font-weight: bold; text-decoration: underline;">space</span>];
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">num</span> = 0;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">which</span> = 0; which &lt; 2; which++) {
    <span style="font-weight: bold;">if</span> (!c-&gt;inputs_[which].empty()) {
      <span style="font-weight: bold;">if</span> (c-&gt;level() + which == 0) {
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">files</span> = c-&gt;inputs_[which];
        <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; files.size(); i++) {
          <span style="font-weight: bold; text-decoration: underline;">list</span>[num++] = table_cache_-&gt;NewIterator(
              options, files[i]-&gt;number, files[i]-&gt;file_size);
        }
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create concatenating iterator for the files from this level</span>
        <span style="font-weight: bold; text-decoration: underline;">list</span>[num++] = NewTwoLevelIterator(
            <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Version</span>::<span style="font-weight: bold; text-decoration: underline;">LevelFileNumIterator</span>(icmp_, &amp;c-&gt;inputs_[which]),
            &amp;GetFileIterator, table_cache_, options);
      }
    }
  }
  assert(num &lt;= space);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#20316;&#20026;&#19968;&#20010;merge iterator&#23384;&#22312;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">result</span> = NewMergingIterator(&amp;icmp_, list, num);
  <span style="font-weight: bold;">delete</span>[] list;
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org35cb214" class="outline-4">
<h4 id="org35cb214"><span class="section-number-4">10.3.13</span> VersionSetBuilder</h4>
<div class="outline-text-4" id="text-10-3-13">
<p>
db/version<sub>set.cc</sub> VersoionSetBuilder存在作用就是为了能够高效地做version edit对象的回放.
沃恩首先看看里面可能涉及到的结构.注意这里面我们没有修改base对应的version对象,只是在SaveTo
的时候可以将这些log全部作用到base这个对象,写到新的对象上面.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A helper class so we can efficiently apply a whole sequence</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of edits to a particular state without creating intermediate</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Versions that contain full copies of the intermediate state.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>::<span style="font-weight: bold; text-decoration: underline;">Builder</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Helper to sort by v-&gt;files_[file_number].smallest</span>
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">BySmallestKey</span> {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>* <span style="font-weight: bold; font-style: italic;">internal_comparator</span>;

    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">()</span>(<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f1</span>, <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f2</span>) <span style="font-weight: bold;">const</span> {
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">r</span> = internal_comparator-&gt;Compare(f1-&gt;smallest, f2-&gt;smallest);
      <span style="font-weight: bold;">if</span> (r != 0) {
        <span style="font-weight: bold;">return</span> (r &lt; 0);
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Break ties by file number</span>
        <span style="font-weight: bold;">return</span> (f1-&gt;number &lt; f2-&gt;number);
      }
    }
  };

  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">set</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*, <span style="font-weight: bold; text-decoration: underline;">BySmallestKey</span>&gt; <span style="font-weight: bold; text-decoration: underline;">FileSet</span>;
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">LevelState</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010;level&#38656;&#35201;&#22686;&#21152;&#21644;&#21024;&#38500;&#30340;&#25991;&#20214;.</span>
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">set</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt; <span style="font-weight: bold; font-style: italic;">deleted_files</span>;
    <span style="font-weight: bold; text-decoration: underline;">FileSet</span>* <span style="font-weight: bold; font-style: italic;">added_files</span>;
  };

  <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>* <span style="font-weight: bold; font-style: italic;">vset_</span>;
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">base_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38024;&#23545;&#26576;&#19968;&#20010;version&#36827;&#34892;&#30340;edit&#25805;&#20316;.</span>
  <span style="font-weight: bold; text-decoration: underline;">LevelState</span> <span style="font-weight: bold; font-style: italic;">levels_</span>[<span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels];
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org79e02f7"></a>VersionSetBuilder<br />
<div class="outline-text-5" id="text-10-3-13-1">
<p>
首先看看构造和析构函数.不是非常麻烦.对于析构函数的话将所有的add files refs&#x2013;.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Initialize a builder with the files from *base and other info from *vset</span>
<span style="font-weight: bold;">Builder</span>(<span style="font-weight: bold; text-decoration: underline;">VersionSet</span>* <span style="font-weight: bold; font-style: italic;">vset</span>, <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">base</span>)
    : vset_(vset),
      base_(base) {
  base_-&gt;Ref();
  <span style="font-weight: bold; text-decoration: underline;">BySmallestKey</span> <span style="font-weight: bold; font-style: italic;">cmp</span>;
  cmp.internal_comparator = &amp;vset_-&gt;icmp_;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
    levels_[level].added_files = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">FileSet</span>(cmp);
  }
}

~<span style="font-weight: bold;">Builder</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#25152;&#26377;&#30340;add files&#20840;&#37096;refs--.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#22312;SaveTo&#30340;&#26102;&#20505;&#20250;&#23558;FileMetaData&#36825;&#37096;&#20998;&#30340;ref&#36716;&#20041;&#21040;SaveTo&#30340;Version&#19978;&#38754;.</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FileSet</span>* <span style="font-weight: bold; font-style: italic;">added</span> = levels_[level].added_files;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt; <span style="font-weight: bold; font-style: italic;">to_unref</span>;
    to_unref.reserve(added-&gt;size());
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">FileSet</span>::<span style="font-weight: bold; text-decoration: underline;">const_iterator</span> <span style="font-weight: bold; font-style: italic;">it</span> = added-&gt;begin();
        it != added-&gt;end(); ++it) {
      to_unref.push_back(*it);
    }
    <span style="font-weight: bold;">delete</span> added;
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; to_unref.size(); i++) {
      <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = to_unref[i];
      f-&gt;refs--;
      <span style="font-weight: bold;">if</span> (f-&gt;refs &lt;= 0) {
        <span style="font-weight: bold;">delete</span> f;
      }
    }
  }
  base_-&gt;Unref();
}
</pre>
</div>
</div>
</li>

<li><a id="orgd99b28a"></a>Apply<br />
<div class="outline-text-5" id="text-10-3-13-2">
<p>
将edit这个log记录起来.可能会被调用多次.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Apply all of the edits in *edit to the current state.</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Apply</span>(<span style="font-weight: bold; text-decoration: underline;">VersionEdit</span>* <span style="font-weight: bold; font-style: italic;">edit</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Update compaction pointers</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; edit-&gt;compact_pointers_.size(); i++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = edit-&gt;compact_pointers_[i].first;
    vset_-&gt;compact_pointer_[level] =
        edit-&gt;compact_pointers_[i].second.Encode().ToString();
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Delete files</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span>::<span style="font-weight: bold; text-decoration: underline;">DeletedFileSet</span>&amp; <span style="font-weight: bold; font-style: italic;">del</span> = edit-&gt;deleted_files_;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">VersionEdit</span>::<span style="font-weight: bold; text-decoration: underline;">DeletedFileSet</span>::<span style="font-weight: bold; text-decoration: underline;">const_iterator</span> <span style="font-weight: bold; font-style: italic;">iter</span> = del.begin();
       iter != del.end();
       ++iter) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = iter-&gt;first;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">number</span> = iter-&gt;second;
    levels_[level].deleted_files.insert(number);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add new files</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; edit-&gt;new_files_.size(); i++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = edit-&gt;new_files_[i].first;
    <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>(edit-&gt;new_files_[i].second);
    f-&gt;refs = 1;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We arrange to automatically compact this file after</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a certain number of seeks.  Let's assume:</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">(1) One seek costs 10ms</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">(2) Writing or reading 1MB costs 10ms (100MB/s)</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">(3) A compaction of 1MB does 25MB of IO:</span>
    <span style="font-weight: bold; font-style: italic;">//         </span><span style="font-weight: bold; font-style: italic;">1MB read from this level</span>
    <span style="font-weight: bold; font-style: italic;">//         </span><span style="font-weight: bold; font-style: italic;">10-12MB read from next level (boundaries may be misaligned)</span>
    <span style="font-weight: bold; font-style: italic;">//         </span><span style="font-weight: bold; font-style: italic;">10-12MB written to next level</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This implies that 25 seeks cost the same as the compaction</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of 1MB of data.  I.e., one seek costs approximately the</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">same as the compaction of 40KB of data.  We are a little</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">conservative and allow approximately one seek for every 16KB</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of data before triggering a compaction.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;allow seek&#30340;&#38480;&#21046;,&#36229;&#36807;&#36825;&#20040;&#22810;&#30340;&#38480;&#21046;&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#20316;&#20026;&#28508;&#22312;&#30340;compaction&#25991;&#20214;.</span>
    f-&gt;allowed_seeks = (f-&gt;file_size / 16384);
    <span style="font-weight: bold;">if</span> (f-&gt;allowed_seeks &lt; 100) f-&gt;allowed_seeks = 100;

    levels_[level].deleted_files.erase(f-&gt;number);
    levels_[level].added_files-&gt;insert(f);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org468996e"></a>MaybeAddFile<br />
<div class="outline-text-5" id="text-10-3-13-3">
<p>
将f添加到新增加到对应level的文件列表尾部.需要确保没有overlap并且没有存在于标记删除文件集合中.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">MaybeAddFile</span>(<span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>, <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span>) {
  <span style="font-weight: bold;">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">File is deleted: do nothing</span>
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;* <span style="font-weight: bold; font-style: italic;">files</span> = &amp;v-&gt;files_[level];
    <span style="font-weight: bold;">if</span> (level &gt; 0 &amp;&amp; !files-&gt;empty()) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Must not overlap</span>
      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size()-1]-&gt;largest,
                                  f-&gt;smallest) &lt; 0);
    }
    f-&gt;refs++;
    files-&gt;push_back(f);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgfd9a3f7"></a>SaveTo<br />
<div class="outline-text-5" id="text-10-3-13-4">
<p>
当前通过edit修改后的状态保存到新的version里面.我们来仔细看看这个过程.将之前edit回放的内容
保存在v这个version里面来.典型使用方法非常简单.
</p>
<ul class="org-ul">
<li>首先构造builder对象</li>
<li>Apply使用某个edit.</li>
<li>SaveTo生成某个version.</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Save the current state in *v.</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SaveTo</span>(<span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">v</span>) {
  <span style="font-weight: bold; text-decoration: underline;">BySmallestKey</span> <span style="font-weight: bold; font-style: italic;">cmp</span>;
  cmp.internal_comparator = &amp;vset_-&gt;icmp_;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = 0; level &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; level++) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Merge the set of added files with the set of pre-existing files.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Drop any deleted files.  Store the result in *v.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">base_files</span> = base_-&gt;files_[level];
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;::<span style="font-weight: bold; text-decoration: underline;">const_iterator</span> <span style="font-weight: bold; font-style: italic;">base_iter</span> = base_files.begin();
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;::<span style="font-weight: bold; text-decoration: underline;">const_iterator</span> <span style="font-weight: bold; font-style: italic;">base_end</span> = base_files.end();
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">FileSet</span>* <span style="font-weight: bold; font-style: italic;">added</span> = levels_[level].added_files;
    v-&gt;files_[level].reserve(base_files.size() + added-&gt;size());
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#24517;&#39035;&#25353;&#29031;&#26368;&#23567;&#30340;key&#26469;&#36827;&#34892;&#25490;&#24207;.&#36825;&#37324;&#26159;&#23384;&#22312;&#39034;&#24207;&#38382;&#39064;&#30340;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#26159;&#23545;&#20110;level&gt;0&#30340;&#23618;&#26469;&#35828;&#37324;&#38754;&#30340;&#25991;&#20214;&#37117;&#26159;&#19981;&#37325;&#22797;&#30340;.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">FileSet</span>::<span style="font-weight: bold; text-decoration: underline;">const_iterator</span> <span style="font-weight: bold; font-style: italic;">added_iter</span> = added-&gt;begin();
         added_iter != added-&gt;end();
         ++added_iter) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add all smaller files listed in base_</span>
      <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;::<span style="font-weight: bold; text-decoration: underline;">const_iterator</span> <span style="font-weight: bold; font-style: italic;">bpos</span>
               = <span style="font-weight: bold; text-decoration: underline;">std</span>::upper_bound(base_iter, base_end, *added_iter, cmp);
           base_iter != bpos;
           ++base_iter) {
        MaybeAddFile(v, level, *base_iter);
      }

      MaybeAddFile(v, level, *added_iter);
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add remaining base files</span>
    <span style="font-weight: bold;">for</span> (; base_iter != base_end; ++base_iter) {
      MaybeAddFile(v, level, *base_iter);
    }
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgcd100b2" class="outline-4">
<h4 id="orgcd100b2"><span class="section-number-4">10.3.14</span> Compaction</h4>
<div class="outline-text-4" id="text-10-3-14">
<p>
db/version<sub>set.h</sub> Compaction包含的是进行compaction操作的信息.针对compaction对象通常是current version
所对应的文件。我们首先来看看Compaction结构.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A Compaction encapsulates information about a compaction.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span> {
 <span style="font-weight: bold;">public</span>:

  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38024;&#23545;&#21738;&#20010;level&#36827;&#34892;</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">max_output_file_size_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compaction&#20043;&#21518;&#21333;&#20010;&#25991;&#20214;&#30340;&#26368;&#22823;&#22823;&#23567;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Version</span>* <span style="font-weight: bold; font-style: italic;">input_version_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38024;&#23545;&#21738;&#20010;version&#36827;&#34892;&#25805;&#20316;.</span>
  <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span> <span style="font-weight: bold; font-style: italic;">edit_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24212;&#35813;&#26159;&#38024;&#23545;version&#25805;&#20316;&#20043;&#21518;&#30340;log&#20449;&#24687;.&#27604;&#22914;&#21024;&#38500;&#21738;&#20123;&#25991;&#20214;&#28155;&#21152;&#20102;&#21738;&#20123;&#25991;&#20214;&#31561;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Each compaction reads inputs from "level_" and "level_+1"</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt; <span style="font-weight: bold; font-style: italic;">inputs_</span>[2];      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The two sets of inputs. &#35201;&#36827;&#34892;compaction&#30340;&#25991;&#20214;&#26377;&#21738;&#20123;.</span>
  <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">1 &#24212;&#35813;&#23601;&#26159;parent level.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">State used to check for number of of overlapping grandparent files</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(parent == level_ + 1, grandparent == level_ + 2)</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt; <span style="font-weight: bold; font-style: italic;">grandparents_</span>;
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">grandparent_index_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Index in grandparent_starts_</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">seen_key_</span>;             <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Some output key has been seen</span>
  <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">overlapped_bytes_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Bytes of overlap between current output</span>
                              <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and grandparent files</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">State for implementing IsBaseLevelForKey</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">level_ptrs_ holds indices into input_version_-&gt;levels_: our state</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">is that we are positioned at one of the file ranges for each</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">higher level than the ones involved in this compaction (i.e. for</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">all L &gt;= level_ + 2).</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">level_ptrs_</span>[<span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels];
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org776d3af"></a>Compaction<br />
<div class="outline-text-5" id="text-10-3-14-1">
<p>
构造函数过程非常简单.析构函数的话也只是将input<sub>version</sub><sub>修改引用计数</sub>。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Compaction</span>::<span style="font-weight: bold;">Compaction</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>)
    : level_(level),
      max_output_file_size_(MaxFileSizeForLevel(level)), <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#20989;&#25968;&#21518;&#38754;&#20998;&#26512;.</span>
      input_version_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      grandparent_index_(0),
      seen_key_(<span style="font-weight: bold; text-decoration: underline;">false</span>),
      overlapped_bytes_(0) {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; i++) {
    level_ptrs_[i] = 0;
  }
}
<span style="font-weight: bold; text-decoration: underline;">Compaction</span>::~<span style="font-weight: bold;">Compaction</span>() {
  <span style="font-weight: bold;">if</span> (input_version_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    input_version_-&gt;Unref(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NOTICE:&#36825;&#20010;&#38750;&#24120;&#37325;&#35201;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36825;&#20010;compaction&#23436;&#25104;&#30340;&#35805;,&#37027;&#20040;version&#23601;&#20250;&#38144;&#27585;.</span>
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org5f90992"></a>MaxFileSizeForLevel<br />
<div class="outline-text-5" id="text-10-3-14-2">
<p>
每一层单个文件大小最大是多少.现在实现非常简单是一个固定值.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kTargetFileSize</span> = 2 * 1048576; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">2MB.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">MaxFileSizeForLevel</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>) {
  <span style="font-weight: bold;">return</span> kTargetFileSize;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We could vary per level to reduce number of files?</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org5525e56"></a>MaxBytesForLevel<br />
<div class="outline-text-5" id="text-10-3-14-3">
<p>
每一层文件所占用的字节数上限是多少.level0,1是10MB.以后每上一层*10.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold;">MaxBytesForLevel</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note: the result for level zero is not really used since we set</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the level-0 compaction threshold based on number of files.</span>
  <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">result</span> = 10 * 1048576.0;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Result for both level-0 and level-1</span>
  <span style="font-weight: bold;">while</span> (level &gt; 1) {
    result *= 10;
    level--;
  }
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</li>

<li><a id="orgf15fe2a"></a>IsTrivialMove<br />
<div class="outline-text-5" id="text-10-3-14-4">
<p>
这个compaction是否为简单的移动.需要满足3个条件
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span>::<span style="font-weight: bold;">IsTrivialMove</span>() <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Avoid a move if there is lots of overlapping grandparent data.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Otherwise, the move could create a parent file that will require</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a very expensive merge later on.</span>
  <span style="font-weight: bold;">return</span> (num_input_files(0) == 1 &amp;&amp; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">level 1&#20010;&#25991;&#20214;</span>
          num_input_files(1) == 0 &amp;&amp; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">level+1 &#27809;&#26377;&#25991;&#20214;</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">grandparent level&#23384;&#22312;overlap&#30340;&#25991;&#20214;&#22823;&#23567;&#27809;&#26377;&#36807;&#22823;.</span>
          TotalFileSize(grandparents_) &lt;= kMaxGrandParentOverlapBytes);
}
</pre>
</div>
</div>
</li>

<li><a id="org6de8c62"></a>AddInputDeletions<br />
<div class="outline-text-5" id="text-10-3-14-5">
<p>
通知这次操作做了文件的删除.将这些可以删除的文件填写到edit里面.做好compaction之后的话，
那么inputs<sub>里面的文件基本上就没有用途就可以被删除了</sub>。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span>::<span style="font-weight: bold;">AddInputDeletions</span>(<span style="font-weight: bold; text-decoration: underline;">VersionEdit</span>* <span style="font-weight: bold; font-style: italic;">edit</span>) {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">which</span> = 0; which &lt; 2; which++) {
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; inputs_[which].size(); i++) {
      edit-&gt;DeleteFile(level_ + which, inputs_[which][i]-&gt;number);
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org9c470cf"></a>IsBaseLevelForKey<br />
<div class="outline-text-5" id="text-10-3-14-6">
<p>
在db<sub>impl.cc里面的DoCompactionWork里面调用了.具体策略实现没有太仔细分析.判断某个key在高层是否还存在</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span>::<span style="font-weight: bold;">IsBaseLevelForKey</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">user_key</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Maybe use binary search to find right entry instead of linear search?</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">user_cmp</span> = input_version_-&gt;vset_-&gt;icmp_.user_comparator();
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">lvl</span> = level_ + 2; lvl &lt; <span style="font-weight: bold; text-decoration: underline;">config</span>::kNumLevels; lvl++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>*&gt;&amp; <span style="font-weight: bold; font-style: italic;">files</span> = input_version_-&gt;files_[lvl];
    <span style="font-weight: bold;">for</span> (; level_ptrs_[lvl] &lt; files.size(); ) {
      <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">f</span> = files[level_ptrs_[lvl]];
      <span style="font-weight: bold;">if</span> (user_cmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= 0) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We've advanced far enough</span>
        <span style="font-weight: bold;">if</span> (user_cmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= 0) {
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Key falls in this file's range, so definitely not base level</span>
          <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
        }
        <span style="font-weight: bold;">break</span>;
      }
      level_ptrs_[lvl]++;
    }
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
}
</pre>
</div>
</div>
</li>

<li><a id="org4241f86"></a>ShouldStopBefore<br />
<div class="outline-text-5" id="text-10-3-14-7">
<p>
在db<sub>impl.cc里面的DoCompactionWork里面调用了.作用是判断这个key的话是否应该停止然后</sub>
重新开辟一个新的文件用于compaction的输出.这是一个策略,大致应该是希望这个key如果
和grandparent level重合不要过多.更具体的策略方面不太清楚.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span>::<span style="font-weight: bold;">ShouldStopBefore</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">internal_key</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Scan to find earliest grandparent file that contains key.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>* <span style="font-weight: bold; font-style: italic;">icmp</span> = &amp;input_version_-&gt;vset_-&gt;icmp_;
  <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">grandparent_index_</span> &lt; grandparents_.size() &amp;&amp;
      icmp-&gt;Compare(internal_key,
                    <span style="font-weight: bold; text-decoration: underline;">grandparents_</span>[grandparent_index_]-&gt;largest.Encode()) &gt; 0) {
    <span style="font-weight: bold;">if</span> (seen_key_) {
      overlapped_bytes_ += grandparents_[grandparent_index_]-&gt;file_size;
    }
    grandparent_index_++;
  }
  seen_key_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;

  <span style="font-weight: bold;">if</span> (overlapped_bytes_ &gt; kMaxGrandParentOverlapBytes) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Too much overlap for current output; start new output</span>
    overlapped_bytes_ = 0;
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org2aefa10"></a>ReleaseInputs<br />
<div class="outline-text-5" id="text-10-3-14-8">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Compaction</span>::<span style="font-weight: bold;">ReleaseInputs</span>() {
  <span style="font-weight: bold;">if</span> (input_version_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    input_version_-&gt;Unref();
    input_version_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org4b69d84" class="outline-4">
<h4 id="org4b69d84"><span class="section-number-4">10.3.15</span> CompactionState</h4>
<div class="outline-text-4" id="text-10-3-15">
<p>
db/db<sub>impl.cc</sub> CompactionState里面记录的是在这次Compaction时候保存的状态.Compaction只是
保存了本次compaction操作所需要的信息，但是没有保存过程状态.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">DBImpl</span>::<span style="font-weight: bold; text-decoration: underline;">CompactionState</span> {
  <span style="font-weight: bold; text-decoration: underline;">Compaction</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">compaction</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26412;&#27425;compaction&#25152;&#38656;&#35201;&#36827;&#34892;&#30340;&#25805;&#20316;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Sequence numbers &lt; smallest_snapshot are not significant since we</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">will never have to service a snapshot below smallest_snapshot.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Therefore if we have seen a sequence number S &lt;= smallest_snapshot,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we can drop all entries for the same key with sequence numbers &lt; S.</span>
  <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">smallest_snapshot</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#26377;&#25928;&#30340;sequence number&#26159;&#22810;&#23569;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Files produced by compaction</span>
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Output</span> {
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">number</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36755;&#20986;&#25991;&#20214;number.</span>
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_size</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36755;&#20986;&#25991;&#20214;&#22823;&#23567;</span>
    <span style="font-weight: bold; text-decoration: underline;">InternalKey</span> <span style="font-weight: bold; font-style: italic;">smallest</span>, <span style="font-weight: bold; font-style: italic;">largest</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36755;&#20986;&#25991;&#20214;size.</span>
  };
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Output</span>&gt; <span style="font-weight: bold; font-style: italic;">outputs</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">State kept for output being generated</span>
  <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">outfile</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#36755;&#20986;&#25991;&#20214;&#20197;&#21450;table_builder.</span>
  <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>* <span style="font-weight: bold; font-style: italic;">builder</span>;

  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">total_bytes</span>;

  <span style="font-weight: bold; text-decoration: underline;">Output</span>* <span style="font-weight: bold;">current_output</span>() { <span style="font-weight: bold;">return</span> &amp;outputs[outputs.size()-1]; }

  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">CompactionState</span>(<span style="font-weight: bold; text-decoration: underline;">Compaction</span>* <span style="font-weight: bold; font-style: italic;">c</span>)
      : compaction(c),
        outfile(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
        builder(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
        total_bytes(0) {
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f99d7e" class="outline-4">
<h4 id="org7f99d7e"><span class="section-number-4">10.3.16</span> VersionEdit</h4>
<div class="outline-text-4" id="text-10-3-16">
<p>
db/version<sub>edit.h</sub> 阅读完DBImpl::NewDB的话就会发现VersionEdit里面存储的是整个数据库的元信息.
元信息序列化之后作为log写入到Manifest文件里面去。CURRENT文件里面存放的就是当前Manifest文件.
我们首先看看VersionEdit的结构以及里面的字段。个人觉得VersionEdit本身是非常简单的，但是需要了解各个字段含义。
</p>

<p>
:阅读完Compaction之后，觉得这个结构更多的含义应该是针对Version进行Compaction这个过程，对于
Version造成了哪些变动，比如增加或者是删除啦哪些文件，下一个file number以及sequence是什么。将这些
内容记录到log(manifest)里面这样启动的时候就可以进行恢复。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">VersionEdit</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">private:</span>
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">friend</span> <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">VersionSet</span>;

  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">set</span>&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">pair</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>, <span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt; &gt; <span style="font-weight: bold; text-decoration: underline;">DeletedFileSet</span>;

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">comparator_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27604;&#36739;&#22120;&#30340;&#21517;&#23383;.&#36825;&#26679;&#21487;&#20197;&#38450;&#27490;&#25105;comparator&#30340;&#21464;&#21160;&#36896;&#25104;db&#30340;&#36923;&#36753;&#25439;&#22351;.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">log_number_</span>; <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">prev_log_number_</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">next_file_number_</span>;
  <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">last_sequence_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19978;&#27425;&#25805;&#20316;&#23436;&#25104;&#20043;&#21518;&#30340;&#24207;&#21015;&#21495;.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">has_comparator_</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">has_log_number_</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">has_prev_log_number_</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">has_next_file_number_</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">has_last_sequence_</span>;

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">pair</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>, InternalKey&gt; &gt; <span style="font-weight: bold; font-style: italic;">compact_pointers_</span>;
  <span style="font-weight: bold; text-decoration: underline;">DeletedFileSet</span> <span style="font-weight: bold; font-style: italic;">deleted_files_</span>;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt; <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">pair</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>, FileMetaData&gt; &gt; <span style="font-weight: bold; font-style: italic;">new_files_</span>;
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgc2faebf"></a>SetCompactPoint<br />
<div class="outline-text-5" id="text-10-3-16-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SetCompactPointer</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  compact_pointers_.push_back(<span style="font-weight: bold; text-decoration: underline;">std</span>::make_pair(level, key));
}
</pre>
</div>
</div>
</li>

<li><a id="orgc6153f6"></a>AddFile<br />
<div class="outline-text-5" id="text-10-3-16-2">
<p>
相当于告诉db系统新增加了这么一个文件以及这个文件里面的信息是什么.这样可以方便db操作.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">AddFile</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>, <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file</span>,
             <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_size</span>,
             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>&amp; <span style="font-weight: bold; font-style: italic;">smallest</span>,
             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKey</span>&amp; <span style="font-weight: bold; font-style: italic;">largest</span>) {
  <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span> <span style="font-weight: bold; font-style: italic;">f</span>;
  f.number = file;
  f.file_size = file_size;
  f.smallest = smallest;
  f.largest = largest;
  new_files_.push_back(<span style="font-weight: bold; text-decoration: underline;">std</span>::make_pair(level, f));
}
</pre>
</div>
</div>
</li>

<li><a id="org22b377b"></a>DeleteFile<br />
<div class="outline-text-5" id="text-10-3-16-3">
<p>
告诉db系统删除了这个文件.删除并没有操作new<sub>files数组.而是放进了一个set</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Delete the specified "file" from the specified "level".</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">DeleteFile</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span>, <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file</span>) {
  deleted_files_.insert(<span style="font-weight: bold; text-decoration: underline;">std</span>::make_pair(level, file));
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgca70630" class="outline-4">
<h4 id="orgca70630"><span class="section-number-4">10.3.17</span> ByteWiseComparatorImpl</h4>
<div class="outline-text-4" id="text-10-3-17">
<p>
util/comparator.cc 对于Compare实现使用slice对象的compare实现。我们着重看看上面两个接口实现
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">FindShortestSeparator</span>(
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">start</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">limit</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Find length of common prefix</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">min_length</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::min(start-&gt;size(), limit.size());
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">diff_index</span> = 0;
  <span style="font-weight: bold;">while</span> ((diff_index &lt; min_length) &amp;&amp;
         ((*start)[diff_index] == limit[diff_index])) {
    diff_index++;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23454;&#29616;&#19978;&#20165;&#20165;&#26159;&#23545;&#20110;&#31532;&#19968;&#20010;&#19981;&#21516;&#30340;&#23383;&#31526;&#23581;&#35797;+1</span>
  <span style="font-weight: bold;">if</span> (diff_index &gt;= min_length) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Do not shorten if one string is a prefix of the other</span>
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; text-decoration: underline;">uint8_t</span> <span style="font-weight: bold; font-style: italic;">diff_byte</span> = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint8_t</span>&gt;((*start)[diff_index]);
    <span style="font-weight: bold;">if</span> (diff_byte &lt; <span style="font-weight: bold;">static_cast</span>&lt;uint8_t&gt;(0xff) &amp;&amp;
        diff_byte + 1 &lt; <span style="font-weight: bold;">static_cast</span>&lt;uint8_t&gt;(limit[diff_index])) {
      (*start)[diff_index]++;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">+1</span>
      start-&gt;resize(diff_index + 1); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#20462;&#25913;&#38271;&#24230;</span>
      assert(Compare(*start, limit) &lt; 0);
    }
  }
}

<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">FindShortSuccessor</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Find first character that can be incremented</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span> = key-&gt;size();
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint8_t</span> <span style="font-weight: bold; font-style: italic;">byte</span> = (*key)[i];
    <span style="font-weight: bold;">if</span> (byte != <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint8_t</span>&gt;(0xff)) {
      (*key)[i] = byte + 1; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">+1</span>
      key-&gt;resize(i+1); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#25913;&#38271;&#24230;</span>
      <span style="font-weight: bold;">return</span>;
    }
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">*key is a run of 0xffs.  Leave it alone.</span>
}
</pre>
</div>
<p>
还算是比较直白吧.
</p>
</div>
</div>

<div id="outline-container-org2b79be4" class="outline-4">
<h4 id="org2b79be4"><span class="section-number-4">10.3.18</span> SnapshotImpl</h4>
<div class="outline-text-4" id="text-10-3-18">
<p>
db/snapshot.h Snapshot实现非常简单，就是一个双向链表的节点，然后挂在一个双向链表上面。
每一个Snapshot实现都附带一个seq number.对于Snapshot最重要的应该是在上面的操作吧.
我们可以猜想对于每次插入的key都会带上一个seq number.这样如果对snapshot操作的话读取的话，
那么只需要读取seq number以下的内容即可了。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Snapshots are kept in a doubly-linked list in the DB.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Each SnapshotImpl corresponds to a particular sequence number.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Snapshot</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">number_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">const after creation</span>

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">friend</span> <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">SnapshotList</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">SnapshotImpl is kept in a doubly-linked circular list</span>
  <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>* <span style="font-weight: bold; font-style: italic;">prev_</span>;
  <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>* <span style="font-weight: bold; font-style: italic;">next_</span>;

  <span style="font-weight: bold; text-decoration: underline;">SnapshotList</span>* <span style="font-weight: bold; font-style: italic;">list_</span>;                 <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">just for sanity checks</span>
};

<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">SnapshotList</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">SnapshotList</span>() {
    list_.prev_ = &amp;list_;
    list_.next_ = &amp;list_;
  }

  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">empty</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> list_.next_ == &amp;list_; }
  <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>* <span style="font-weight: bold;">oldest</span>() <span style="font-weight: bold;">const</span> { assert(!empty()); <span style="font-weight: bold;">return</span> list_.next_; }
  <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>* <span style="font-weight: bold;">newest</span>() <span style="font-weight: bold;">const</span> { assert(!empty()); <span style="font-weight: bold;">return</span> list_.prev_; }

  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>* <span style="font-weight: bold;">New</span>(<span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">seq</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197;&#19968;&#20010;snapshot&#23454;&#20363;</span>
    <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>* <span style="font-weight: bold; font-style: italic;">s</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>;
    s-&gt;number_ = seq;
    s-&gt;list_ = <span style="font-weight: bold;">this</span>;
    s-&gt;next_ = &amp;list_;
    s-&gt;prev_ = list_.prev_;
    s-&gt;prev_-&gt;next_ = s;
    s-&gt;next_-&gt;prev_ = s;
    <span style="font-weight: bold;">return</span> s;
  }

  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Delete</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span>* <span style="font-weight: bold; font-style: italic;">s</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20010;snapshot&#20174;&#38142;&#20013;&#21024;&#38500;</span>
    assert(s-&gt;list_ == <span style="font-weight: bold;">this</span>);
    s-&gt;prev_-&gt;next_ = s-&gt;next_;
    s-&gt;next_-&gt;prev_ = s-&gt;prev_;
    <span style="font-weight: bold;">delete</span> s;
  }

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Dummy head of doubly-linked list of snapshots</span>
  <span style="font-weight: bold; text-decoration: underline;">SnapshotImpl</span> <span style="font-weight: bold; font-style: italic;">list_</span>;
};
</pre>
</div>

<p>
这里SequenceNumber的实现是一个在db/dbformat.h里面定义了
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcecbafd" class="outline-3">
<h3 id="orgcecbafd"><span class="section-number-3">10.4</span> Posix</h3>
<div class="outline-text-3" id="text-10-4">
</div>
<div id="outline-container-org3795cc2" class="outline-4">
<h4 id="org3795cc2"><span class="section-number-4">10.4.1</span> PosixEnv</h4>
<div class="outline-text-4" id="text-10-4-1">
<p>
util/env<sub>posix.cc</sub> PosixEnv是Env接口的实现。PosixEnv的大部分实现都相当直接.不过这里还是把代码贴上了，主要是方便在一些细小的地方进行注记。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">PosixEnv</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Env</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">PosixEnv</span>();
  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">PosixEnv</span>() {
    fprintf(stderr, <span style="font-style: italic;">"Destroying Env::Default()\n"</span>);
    exit(1);
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NewSequentialFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>,
                                   <span style="font-weight: bold; text-decoration: underline;">SequentialFile</span>** <span style="font-weight: bold; font-style: italic;">result</span>) {
    <span style="font-weight: bold; text-decoration: underline;">FILE</span>* <span style="font-weight: bold; font-style: italic;">f</span> = fopen(fname.c_str(), <span style="font-style: italic;">"r"</span>);
    <span style="font-weight: bold;">if</span> (f == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      *result = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
      <span style="font-weight: bold;">return</span> IOError(fname, errno);
    } <span style="font-weight: bold;">else</span> {
      *result = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">PosixSequentialFile</span>(fname, f);
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
    }
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NewRandomAccessFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>,
                                     <span style="font-weight: bold; text-decoration: underline;">RandomAccessFile</span>** <span style="font-weight: bold; font-style: italic;">result</span>) {
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = open(fname.c_str(), O_RDONLY);
    <span style="font-weight: bold;">if</span> (fd &lt; 0) {
      *result = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
      <span style="font-weight: bold;">return</span> IOError(fname, errno);
    }
    *result = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">PosixRandomAccessFile</span>(fname, fd);
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NewWritableFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>,
                                 <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>** <span style="font-weight: bold; font-style: italic;">result</span>) {
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = open(fname.c_str(), O_CREAT | O_RDWR | O_TRUNC, 0644);
    <span style="font-weight: bold;">if</span> (fd &lt; 0) {
      *result = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
      s = IOError(fname, errno);
    } <span style="font-weight: bold;">else</span> {
      *result = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">PosixMmapFile</span>(fname, fd, page_size_);
    }
    <span style="font-weight: bold;">return</span> s;
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">FileExists</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>) {
    <span style="font-weight: bold;">return</span> access(fname.c_str(), F_OK) == 0;
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">GetChildren</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dir</span>,
                             <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&gt;* <span style="font-weight: bold; font-style: italic;">result</span>) {
    result-&gt;clear();
    <span style="font-weight: bold; text-decoration: underline;">DIR</span>* <span style="font-weight: bold; font-style: italic;">d</span> = opendir(dir.c_str());
    <span style="font-weight: bold;">if</span> (d == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      <span style="font-weight: bold;">return</span> IOError(dir, errno);
    }
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">dirent</span>* <span style="font-weight: bold; font-style: italic;">entry</span>;
    <span style="font-weight: bold;">while</span> ((entry = readdir(d)) != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      result-&gt;push_back(entry-&gt;d_name);
    }
    closedir(d);
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">DeleteFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>) {
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">result</span>;
    <span style="font-weight: bold;">if</span> (unlink(fname.c_str()) != 0) {
      result = IOError(fname, errno);
    }
    <span style="font-weight: bold;">return</span> result;
  };

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">CreateDir</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">name</span>) {
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">result</span>;
    <span style="font-weight: bold;">if</span> (mkdir(name.c_str(), 0755) != 0) {
      result = IOError(name, errno);
    }
    <span style="font-weight: bold;">return</span> result;
  };

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">DeleteDir</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">name</span>) {
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">result</span>;
    <span style="font-weight: bold;">if</span> (rmdir(name.c_str()) != 0) {
      result = IOError(name, errno);
    }
    <span style="font-weight: bold;">return</span> result;
  };

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">GetFileSize</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>, <span style="font-weight: bold; text-decoration: underline;">uint64_t</span>* <span style="font-weight: bold; font-style: italic;">size</span>) {
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">stat</span> <span style="font-weight: bold; font-style: italic;">sbuf</span>;
    <span style="font-weight: bold;">if</span> (<span style="font-weight: bold; font-style: italic;">stat</span>(fname.c_str(), &amp;sbuf) != 0) {
      *size = 0;
      s = IOError(fname, errno);
    } <span style="font-weight: bold;">else</span> {
      *size = sbuf.st_size;
    }
    <span style="font-weight: bold;">return</span> s;
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">RenameFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">src</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) {
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">result</span>;
    <span style="font-weight: bold;">if</span> (rename(src.c_str(), target.c_str()) != 0) {
      result = IOError(src, errno);
    }
    <span style="font-weight: bold;">return</span> result;
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">LockFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>, <span style="font-weight: bold; text-decoration: underline;">FileLock</span>** <span style="font-weight: bold; font-style: italic;">lock</span>) {
    *lock = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">result</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span> = open(fname.c_str(), O_RDWR | O_CREAT, 0644); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#19968;&#20010;&#25991;&#20214;&#34920;&#31034;&#38145;&#20303;.</span>
    <span style="font-weight: bold;">if</span> (fd &lt; 0) {
      result = IOError(fname, errno);
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (LockOrUnlock(fd, <span style="font-weight: bold; text-decoration: underline;">true</span>) == -1) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#20250;&#22312;&#21518;&#38754;&#20180;&#32454;&#30475;&#30475;.true&#34920;&#31034;lock.</span>
      result = IOError(<span style="font-style: italic;">"lock "</span> + fname, errno);
      close(fd);
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; text-decoration: underline;">PosixFileLock</span>* <span style="font-weight: bold; font-style: italic;">my_lock</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">PosixFileLock</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#19968;&#20010;PosixFileLock&#23545;&#35937;</span>
      my_lock-&gt;fd_ = fd; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26631;&#35760;fd.</span>
      *lock = my_lock;
    }
    <span style="font-weight: bold;">return</span> result;
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">UnlockFile</span>(<span style="font-weight: bold; text-decoration: underline;">FileLock</span>* <span style="font-weight: bold; font-style: italic;">lock</span>) {
    <span style="font-weight: bold; text-decoration: underline;">PosixFileLock</span>* <span style="font-weight: bold; font-style: italic;">my_lock</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">PosixFileLock</span>*&gt;(lock);
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">result</span>;
    <span style="font-weight: bold;">if</span> (LockOrUnlock(my_lock-&gt;fd_, <span style="font-weight: bold; text-decoration: underline;">false</span>) == -1) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">false&#34920;&#31034;unlock</span>
      result = IOError(<span style="font-style: italic;">"unlock"</span>, errno);
    }
    close(my_lock-&gt;fd_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20851;&#38381;&#23545;&#24212;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;.</span>
    <span style="font-weight: bold;">delete</span> my_lock;
    <span style="font-weight: bold;">return</span> result;
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Schedule</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">function</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>*), <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>);

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">StartThread</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">function</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>), <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>);

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">GetTestDirectory</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">result</span>) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">env</span> = getenv(<span style="font-style: italic;">"TEST_TMPDIR"</span>);
    <span style="font-weight: bold;">if</span> (env &amp;&amp; env[0] != <span style="font-style: italic;">'\0'</span>) {
      *result = env;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[100];
      snprintf(buf, <span style="font-weight: bold;">sizeof</span>(buf), <span style="font-style: italic;">"/tmp/leveldbtest-%d"</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>(<span style="font-weight: bold; font-style: italic;">geteuid</span>()));
      *result = buf;
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Directory may already exist</span>
    CreateDir(*result);
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
  }

  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">gettid</span>() {
    <span style="font-weight: bold; text-decoration: underline;">pthread_t</span> <span style="font-weight: bold; font-style: italic;">tid</span> = pthread_self();
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">thread_id</span> = 0;
    memcpy(&amp;thread_id, &amp;tid, <span style="font-weight: bold; text-decoration: underline;">std</span>::min(<span style="font-weight: bold;">sizeof</span>(thread_id), <span style="font-weight: bold;">sizeof</span>(tid)));
    <span style="font-weight: bold;">return</span> thread_id;
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">NewLogger</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>, <span style="font-weight: bold; text-decoration: underline;">Logger</span>** <span style="font-weight: bold; font-style: italic;">result</span>) {
    <span style="font-weight: bold; text-decoration: underline;">FILE</span>* <span style="font-weight: bold; font-style: italic;">f</span> = fopen(fname.c_str(), <span style="font-style: italic;">"w"</span>);
    <span style="font-weight: bold;">if</span> (f == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      *result = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
      <span style="font-weight: bold;">return</span> IOError(fname, errno);
    } <span style="font-weight: bold;">else</span> {
      *result = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">PosixLogger</span>(f, &amp;<span style="font-weight: bold; text-decoration: underline;">PosixEnv</span>::gettid); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Logger.&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;.</span>
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
    }
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">NowMicros</span>() {
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">timeval</span> <span style="font-weight: bold; font-style: italic;">tv</span>;
    gettimeofday(&amp;tv, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt;(tv.tv_sec) * 1000000 + tv.tv_usec;
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SleepForMicroseconds</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">micros</span>) {
    usleep(micros);
  }

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">PthreadCall</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">label</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">result</span>) {
    <span style="font-weight: bold;">if</span> (result != 0) {
      fprintf(stderr, <span style="font-style: italic;">"pthread %s: %s\n"</span>, label, strerror(result));
      exit(1);
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29468;&#24819;DB&#21518;&#38754;&#26377;&#19968;&#20010;&#32447;&#31243;&#23436;&#25104;&#19968;&#20123;&#20107;&#24773;&#36890;&#36807;queue&#26469;&#36827;&#34892;&#36890;&#30693;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">BGThread() is the body of the background thread</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">BGThread</span>();
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">BGThreadWrapper</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>) {
    <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">PosixEnv</span>*&gt;(arg)-&gt;BGThread();
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }

  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">page_size_</span>;
  <span style="font-weight: bold; text-decoration: underline;">pthread_mutex_t</span> <span style="font-weight: bold; font-style: italic;">mu_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">queue&#30340;&#38145;&#21644;&#26465;&#20214;&#21464;&#37327;</span>
  <span style="font-weight: bold; text-decoration: underline;">pthread_cond_t</span> <span style="font-weight: bold; font-style: italic;">bgsignal_</span>;
  <span style="font-weight: bold; text-decoration: underline;">pthread_t</span> <span style="font-weight: bold; font-style: italic;">bgthread_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">background thread identity.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">started_bgthread_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bg thread&#26159;&#21542;&#21551;&#21160;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Entry per Schedule() call</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">background item&#36824;&#26159;&#27604;&#36739;&#36890;&#29992;&#30340;,function+arg.</span>
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">BGItem</span> { <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>; <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">function</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>*); };
  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">deque</span>&lt;<span style="font-weight: bold; text-decoration: underline;">BGItem</span>&gt; <span style="font-weight: bold; text-decoration: underline;">BGQueue</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Background queue&#38431;&#21015;.</span>
  <span style="font-weight: bold; text-decoration: underline;">BGQueue</span> <span style="font-weight: bold; font-style: italic;">queue_</span>;
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org950a9d2"></a>LockOrUnlock<br />
<div class="outline-text-5" id="text-10-4-1-1">
<p>
将fd设置成写锁.lock表示是加锁还是解锁.这里flock不需要保留空间只是传引用即可,对于内部调用仅仅是修改了fd的一个标记吧.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">LockOrUnlock</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>, <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">lock</span>) {
  errno = 0;
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">flock</span> <span style="font-weight: bold; font-style: italic;">f</span>;
  memset(&amp;f, 0, <span style="font-weight: bold;">sizeof</span>(f));
  f.l_type = (lock ? F_WRLCK : F_UNLCK);
  f.l_whence = SEEK_SET;
  f.l_start = 0;
  f.l_len = 0;        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Lock/unlock entire file</span>
  <span style="font-weight: bold;">return</span> fcntl(fd, F_SETLK, &amp;f);
}
</pre>
</div>
</div>
</li>

<li><a id="org5f82660"></a>Schedule<br />
<div class="outline-text-5" id="text-10-4-1-2">
<p>
Schedule语义就是将一个function+arg丢到background里面运行.background线程是惰性初始化的.
注意background只有一个执行线程，需要考虑工作是否会阻塞住。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">PosixEnv</span>::<span style="font-weight: bold;">Schedule</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">function</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>*), <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>) {
  PthreadCall(<span style="font-style: italic;">"lock"</span>, pthread_mutex_lock(&amp;mu_));

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Start background thread if necessary</span>
  <span style="font-weight: bold;">if</span> (!started_bgthread_) {
    started_bgthread_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
    PthreadCall( <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#32447;&#31243;.</span>
        <span style="font-style: italic;">"create thread"</span>,
        pthread_create(&amp;bgthread_, <span style="font-weight: bold; text-decoration: underline;">NULL</span>,  &amp;<span style="font-weight: bold; text-decoration: underline;">PosixEnv</span>::BGThreadWrapper, <span style="font-weight: bold;">this</span>));
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If the queue is currently empty, the background thread may currently be</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">waiting.</span>
  <span style="font-weight: bold;">if</span> (queue_.empty()) {
    PthreadCall(<span style="font-style: italic;">"signal"</span>, pthread_cond_signal(&amp;bgsignal_)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38431;&#21015;&#36890;&#30693;</span>
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add to priority queue</span>
  queue_.push_back(BGItem()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#38431;&#21015;&#20869;&#37096;&#21152;&#20837;&#23545;&#35937;.</span>
  queue_.back().function = function;
  queue_.back().arg = arg;

  PthreadCall(<span style="font-style: italic;">"unlock"</span>, pthread_mutex_unlock(&amp;mu_));
}
</pre>
</div>

<p>
其中BGThreadWrapper非常简单调用BGThread函数执行
</p>
<div class="org-src-container">
<pre class="src src-C++">  <span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">BGThreadWrapper</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>) {
    <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">PosixEnv</span>*&gt;(arg)-&gt;BGThread();
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">PosixEnv</span>::<span style="font-weight: bold;">BGThread</span>() {
  <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">true</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Wait until there is an item that is ready to run</span>
    PthreadCall(<span style="font-style: italic;">"lock"</span>, pthread_mutex_lock(&amp;mu_));
    <span style="font-weight: bold;">while</span> (queue_.empty()) {
      PthreadCall(<span style="font-style: italic;">"wait"</span>, pthread_cond_wait(&amp;bgsignal_, &amp;mu_));
    }

    <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">function</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>*) = queue_.front().function; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#32447;&#31243;&#20869;&#37096;&#25191;&#34892;&#20989;&#25968;.</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span> = queue_.front().arg;
    queue_.pop_front();

    PthreadCall(<span style="font-style: italic;">"unlock"</span>, pthread_mutex_unlock(&amp;mu_));
    (*function)(arg);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org091efea"></a>StartThread<br />
<div class="outline-text-5" id="text-10-4-1-3">
<p>
启动一个线程.但是似乎有限制没有能力进行join.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">PosixEnv</span>::<span style="font-weight: bold;">StartThread</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">function</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>), <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>) {
  <span style="font-weight: bold; text-decoration: underline;">pthread_t</span> <span style="font-weight: bold; font-style: italic;">t</span>;
  <span style="font-weight: bold; text-decoration: underline;">StartThreadState</span>* <span style="font-weight: bold; font-style: italic;">state</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">StartThreadState</span>;
  state-&gt;user_function = function;
  state-&gt;arg = arg;
  PthreadCall(<span style="font-style: italic;">"start thread"</span>,
              pthread_create(&amp;t, <span style="font-weight: bold; text-decoration: underline;">NULL</span>,  &amp;StartThreadWrapper, state));
}
</pre>
</div>
</div>
</li>

<li><a id="orgb6b8614"></a>Default<br />
<div class="outline-text-5" id="text-10-4-1-4">
<p>
Default是为了获得Env的一个实例.为了防止多个线程产生多个Env实例.使用pthread<sub>once来产生</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">pthread_once_t</span> <span style="font-weight: bold; font-style: italic;">once</span> = PTHREAD_ONCE_INIT;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold; font-style: italic;">default_env</span>;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">InitDefaultEnv</span>() { default_env = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">PosixEnv</span>; }

<span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold; text-decoration: underline;">Env</span>::<span style="font-weight: bold;">Default</span>() {
  pthread_once(&amp;once, InitDefaultEnv);
  <span style="font-weight: bold;">return</span> default_env;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgffaaa64" class="outline-4">
<h4 id="orgffaaa64"><span class="section-number-4">10.4.2</span> PosixFileLock</h4>
<div class="outline-text-4" id="text-10-4-2">
<p>
util/env<sub>posix.cc</sub> PosixFilLock是FileLock的实现。基本上PosixFileLock没有任何内容，里面只需要维护fd即可。然后在LockOrUnlock里面操作fd即可以加锁解锁
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">PosixFileLock</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">FileLock</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orged86c78" class="outline-4">
<h4 id="orged86c78"><span class="section-number-4">10.4.3</span> PosixLogger</h4>
<div class="outline-text-4" id="text-10-4-3">
<p>
util/posix<sub>logger.h</sub> PosixLogger是Logger的实现。我们主要看看logger打印了哪些信息，并且稍微看看如果我们写logger的话大致应该需要考虑什么问题
PosixLogger持有了FILE*对象以及gettid的函数指针.只有一个方法Logv
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Logv</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">format</span>, <span style="font-weight: bold; text-decoration: underline;">va_list</span> <span style="font-weight: bold; font-style: italic;">ap</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">thread_id</span> = (*gettid_)();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We try twice: the first time with a fixed-size stack allocated buffer,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and the second time with a much larger dynamically allocated buffer.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#22320;&#26041;&#20540;&#24471;&#23398;&#20064;&#19968;&#19979;.&#31532;&#19968;&#27425;&#20351;&#29992;stack&#20998;&#37197;&#20869;&#23384;&#65292;&#31532;&#20108;&#27425;&#20351;&#29992;heap&#20998;&#37197;&#20869;&#23384;.</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buffer</span>[500];
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">iter</span> = 0; iter &lt; 2; iter++) {
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">base</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">bufsize</span>;
    <span style="font-weight: bold;">if</span> (iter == 0) {
      bufsize = <span style="font-weight: bold;">sizeof</span>(buffer);
      base = buffer;
    } <span style="font-weight: bold;">else</span> {
      bufsize = 30000;
      base = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[bufsize];
    }
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">p</span> = base;
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">limit</span> = base + bufsize;

    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">timeval</span> <span style="font-weight: bold; font-style: italic;">now_tv</span>;
    gettimeofday(&amp;now_tv, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">time_t</span> <span style="font-weight: bold; font-style: italic;">seconds</span> = now_tv.tv_sec;
    <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">tm</span> <span style="font-weight: bold; font-style: italic;">t</span>;
    localtime_r(&amp;seconds, &amp;t); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26412;&#22320;&#26102;&#38388;+microseconds &#32447;&#31243;&#21495; &#33258;&#23450;&#20041;&#26684;&#24335;.</span>
    p += snprintf(p, limit - p,
                  <span style="font-style: italic;">"%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx "</span>,
                  t.tm_year + 1900,
                  t.tm_mon + 1,
                  t.tm_mday,
                  t.tm_hour,
                  t.tm_min,
                  t.tm_sec,
                  <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;(now_tv.tv_usec),
                  <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">long</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span>&gt;(thread_id));

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Print the message</span>
    <span style="font-weight: bold;">if</span> (p &lt; limit) {
      <span style="font-weight: bold; text-decoration: underline;">va_list</span> <span style="font-weight: bold; font-style: italic;">backup_ap</span>;
      va_copy(backup_ap, ap);
      p += vsnprintf(p, limit - p, format, backup_ap);
      va_end(backup_ap);
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Truncate to available space if necessary</span>
    <span style="font-weight: bold;">if</span> (p &gt;= limit) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36229;&#36807;&#30340;&#35805;&#24182;&#19988;&#26159;stack&#20998;&#37197;&#37027;&#20040;&#37325;&#26032;&#19968;&#36718;.</span>
      <span style="font-weight: bold;">if</span> (iter == 0) {
        <span style="font-weight: bold;">continue</span>;       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Try again with larger buffer</span>
      } <span style="font-weight: bold;">else</span> {
        p = limit - 1; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31532;&#20108;&#36718;&#30340;&#35805;&#36827;&#34892;&#25130;&#26029;.</span>
      }
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add newline if necessary</span>
    <span style="font-weight: bold;">if</span> (p == base || p[-1] != <span style="font-style: italic;">'\n'</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30830;&#20445;&#23384;&#22312;&#25442;&#34892;.</span>
      *p++ = <span style="font-style: italic;">'\n'</span>;
    }

    assert(p &lt;= limit);
    fwrite(base, 1, p - base, file_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20889;&#20837;&#25991;&#20214;&#24182;&#19988;&#36825;&#37324;&#27880;&#24847;&#38656;&#35201;flush.</span>
    fflush(file_);
    <span style="font-weight: bold;">if</span> (base != buffer) {
      <span style="font-weight: bold;">delete</span>[] base;
    }
    <span style="font-weight: bold;">break</span>;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b52769" class="outline-4">
<h4 id="org1b52769"><span class="section-number-4">10.4.4</span> PosixRandomAccessFile</h4>
<div class="outline-text-4" id="text-10-4-4">
<p>
util/env<sub>posix.cc</sub> PosixRandomAccessFile是RandomAccessFile的实现。对于随机读取的话使用pread应该就可以了.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Read</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">offset</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">result</span>,
                    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
  <span style="font-weight: bold; text-decoration: underline;">ssize_t</span> <span style="font-weight: bold; font-style: italic;">r</span> = pread(fd_, scratch, n, <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">off_t</span>&gt;(offset));
  *result = Slice(scratch, (r &lt; 0) ? 0 : r);
  <span style="font-weight: bold;">if</span> (r &lt; 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">An error: return a non-ok status</span>
    s = IOError(filename_, errno);
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1469338" class="outline-4">
<h4 id="org1469338"><span class="section-number-4">10.4.5</span> PosixSequentialFile</h4>
<div class="outline-text-4" id="text-10-4-5">
<p>
util/env<sub>posix.cc</sub> PosixSequentialFile是SequentialFile的实现。内部实现的持有FILE*指针.猜想对于顺序访问而言的话，缓存还是会非常有效果的
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Read</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">result</span>, <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">r</span> = fread_unlocked(scratch, 1, n, file_);
  *result = Slice(scratch, r);
  <span style="font-weight: bold;">if</span> (r &lt; n) {
    <span style="font-weight: bold;">if</span> (feof(file_)) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We leave status as ok if we hit the end of the file</span>
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A partial read with an error: return a non-ok status</span>
      s = IOError(filename_, errno);
    }
  }
  <span style="font-weight: bold;">return</span> s;
}

<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Skip</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  <span style="font-weight: bold;">if</span> (fseek(file_, n, SEEK_CUR)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;&#24403;&#21069;&#36339;&#36807;n&#20010;&#23383;&#33410;.</span>
    <span style="font-weight: bold;">return</span> IOError(filename_, errno);
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
}
</pre>
</div>
<p>
fread<sub>unlocked表示内部不会存在多个线程来读取这个文件.可以在一定程度上提高性能</sub>.
</p>
</div>
</div>

<div id="outline-container-orgf9a808c" class="outline-4">
<h4 id="orgf9a808c"><span class="section-number-4">10.4.6</span> PosixMmapFile</h4>
<div class="outline-text-4" id="text-10-4-6">
<p>
util/env<sub>posix.cc</sub> PosixMmapFile是为了实现WritableFile的.内部使用mmap来实现的文件追加写和同步方式.还是比较精巧的，值得仔细看看
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">PosixMmapFile</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">fname</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fd</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">page_size</span>)
    : filename_(fname),
      fd_(fd),
      page_size_(page_size),
      map_size_(Roundup(65536, page_size)), <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">65536 roundup to pagesize&#20316;&#20026;&#19968;&#20010;mmap&#30340;&#22823;&#23567;.</span>
      base_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>), <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mmap&#20986;&#26469;&#30340;base,dst(&#24403;&#21069;&#21487;&#29992;&#22320;&#22336;),limit(&#32467;&#26463;&#22320;&#22336;)</span>
      limit_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      dst_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
      last_sync_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>), <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#36733;&#36827;&#34892;sync&#30340;&#36215;&#22987;&#22320;&#22336;</span>
      file_offset_(0), <span style="font-weight: bold; font-style: italic;">//</span>
      pending_sync_(<span style="font-weight: bold; text-decoration: underline;">false</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21542;&#23384;&#22312;pending sync&#30913;&#30424;&#20869;&#23481;.&#21542;&#21017;&#38656;&#35201;&#35843;&#29992;fdatasync</span>
  assert((page_size &amp; (page_size - 1)) == 0);
}


~<span style="font-weight: bold;">PosixMmapFile</span>() {
  <span style="font-weight: bold;">if</span> (fd_ &gt;= 0) {
    <span style="font-weight: bold; text-decoration: underline;">PosixMmapFile</span>::Close();
  }
}

<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Append</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">data</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23581;&#35797;&#22686;&#21152;&#25968;&#25454;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">src</span> = data.data();
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">left</span> = data.size();
  <span style="font-weight: bold;">while</span> (left &gt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36824;&#26377;&#37096;&#20998;&#25968;&#25454;&#27809;&#26377;&#20889;&#20837;.</span>
    assert(base_ &lt;= dst_);
    assert(dst_ &lt;= limit_);
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">avail</span> = limit_ - dst_;
    <span style="font-weight: bold;">if</span> (avail == 0) {
      <span style="font-weight: bold;">if</span> (!UnmapCurrentRegion() || <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">unmap&#24403;&#21069;&#30340;&#21306;&#22495;&#24182;&#19988;&#20998;&#37197;&#26032;&#30340;&#21306;&#22495;.</span>
          !MapNewRegion()) {
        <span style="font-weight: bold;">return</span> IOError(filename_, errno);
      }
    }

    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span> = (left &lt;= avail) ? left : avail;
    memcpy(dst_, src, n);
    dst_ += n;
    src += n;
    left -= n;
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
}

<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Close</span>() {
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">unused</span> = limit_ - dst_;
  <span style="font-weight: bold;">if</span> (!UnmapCurrentRegion()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#21097;&#20313;&#30340;&#37096;&#20998;unmap&#25481;</span>
    s = IOError(filename_, errno);
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (unused &gt; 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Trim the extra space at the end of the file</span>
    <span style="font-weight: bold;">if</span> (ftruncate(fd_, file_offset_ - unused) &lt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21516;&#26102;&#38656;&#35201;truncate&#22810;mmap&#30340;&#37096;&#20998;.</span>
      s = IOError(filename_, errno);
    }
  }

  <span style="font-weight: bold;">if</span> (close(fd_) &lt; 0) {
    <span style="font-weight: bold;">if</span> (s.ok()) {
      s = IOError(filename_, errno);
    }
  }

  fd_ = -1;
  base_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  limit_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold;">return</span> s;
}

<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Flush</span>() {
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
}

<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">Sync</span>() {
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;

  <span style="font-weight: bold;">if</span> (pending_sync_) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#23384;&#22312;&#38656;&#35201;sync&#30340;&#37096;&#20998;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Some unmapped data was not synced</span>
    pending_sync_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
    <span style="font-weight: bold;">if</span> (fdatasync(fd_) &lt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20010;&#37096;&#20998;data sync.</span>
      s = IOError(filename_, errno);
    }
  }

  <span style="font-weight: bold;">if</span> (dst_ &gt; last_sync_) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#20869;&#23384;&#37096;&#20998;&#36827;&#34892;sync.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Find the beginnings of the pages that contain the first and last</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bytes to be synced.</span>
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">p1</span> = TruncateToPageBoundary(last_sync_ - base_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21487;&#33021;&#20250;&#22810;msync&#37096;&#20998;&#20294;&#26159;&#27809;&#26377;&#20851;&#31995;.</span>
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">p2</span> = TruncateToPageBoundary(dst_ - base_ - 1);
    last_sync_ = dst_;
    <span style="font-weight: bold;">if</span> (msync(base_ + p1, p2 - p1 + page_size_, MS_SYNC) &lt; 0) {
      s = IOError(filename_, errno);
    }
  }

  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org91f6c40"></a>Roundup<br />
<div class="outline-text-5" id="text-10-4-6-1">
<p>
Roundup非常简单.使用时候就是希望mapsize作为pagesize的整数倍存在.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Roundup x to a multiple of y</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">Roundup</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">y</span>) {
  <span style="font-weight: bold;">return</span> ((x + y - 1) / y) * y;
}
</pre>
</div>
</div>
</li>

<li><a id="org78ff85c"></a>TruncateToPageBoundar<br />
<div class="outline-text-5" id="text-10-4-6-2">
<p>
我们需要记住这个函数的语境，是将s的长度截断到pagesize整数倍，这样可以让msync刷新确保正确。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">TruncateToPageBoundary</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">s</span>) {
  s -= (s &amp; (page_size_ - 1));
  assert((s % page_size_) == 0);
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="orgdbf44c4"></a>UnmapCurrentRegion<br />
<div class="outline-text-5" id="text-10-4-6-3">
<p>
解除当前的内存映射。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">UnmapCurrentRegion</span>() {
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">result</span> = <span style="font-weight: bold; text-decoration: underline;">true</span>;
  <span style="font-weight: bold;">if</span> (base_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold;">if</span> (last_sync_ &lt; limit_) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19978;&#19968;&#27425;&#27809;&#20869;&#23384;&#26144;&#23556;&#23436;&#25104;&#30340;&#35805;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Defer syncing this data until next Sync() call, if any</span>
      pending_sync_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
    }
    <span style="font-weight: bold;">if</span> (munmap(base_, limit_ - base_) != 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35299;&#38500;&#20869;&#23384;&#26144;&#23556;.</span>
      result = <span style="font-weight: bold; text-decoration: underline;">false</span>;
    }
    file_offset_ += limit_ - base_; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;fileoffset&#26377;&#22810;&#23569;.</span>
    base_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    limit_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    last_sync_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    dst_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Increase the amount we map the next time, but capped at 1MB</span>
    <span style="font-weight: bold;">if</span> (map_size_ &lt; (1&lt;&lt;20)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#27425;mapsize&#38656;&#35201;&#32763;&#20493;.</span>
      map_size_ *= 2;
    }
  }
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</li>

<li><a id="orgf222e1c"></a>MapNewRegion<br />
<div class="outline-text-5" id="text-10-4-6-4">
<p>
使用mmap分配一块新的内存然后用于后续的写文件
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">MapNewRegion</span>() {
  assert(base_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold;">if</span> (ftruncate(fd_, file_offset_ + map_size_) &lt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;&#36825;&#27425;&#25105;&#20204;&#25171;&#31639;&#21482;&#20889;file_offset+map_size&#36825;&#20040;&#22823;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#20197;&#22810;&#20313;&#30340;&#37096;&#20998;&#25105;&#20204;&#21487;&#20197;&#25130;&#26029;.</span>
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span> = mmap(<span style="font-weight: bold; text-decoration: underline;">NULL</span>, map_size_, PROT_READ | PROT_WRITE, MAP_SHARED,
                   fd_, file_offset_);
  <span style="font-weight: bold;">if</span> (ptr == MAP_FAILED) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  base_ = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(ptr);
  limit_ = base_ + map_size_;
  dst_ = base_;
  last_sync_ = base_;
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
}
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org792448f" class="outline-3">
<h3 id="org792448f"><span class="section-number-3">10.5</span> Cache</h3>
<div class="outline-text-3" id="text-10-5">
</div>
<div id="outline-container-orga1266be" class="outline-4">
<h4 id="orga1266be"><span class="section-number-4">10.5.1</span> ShardedLRUCache</h4>
<div class="outline-text-4" id="text-10-5-1">
<p>
util/cache.cc 所谓Shard意思非常简单，就是将所有的请求进行load-balance.首先看看字段.里面使用到了LRUCache.LRUCache后面会讲到
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kNumShardBits</span> = 4;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kNumShards</span> = 1 &lt;&lt; kNumShardBits;

<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">ShardedLRUCache</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Cache</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">LRUCache</span> <span style="font-weight: bold; font-style: italic;">shard_</span>[kNumShards];
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">Mutex</span> <span style="font-weight: bold; font-style: italic;">id_mutex_</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">last_id_</span>;
};
</pre>
</div>
<p>
可以看到有16个slot.对于load-balance策略也非常简单.取hash结果的高位.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">Shard</span>(<span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">hash</span>) {
  <span style="font-weight: bold;">return</span> hash &gt;&gt; (32 - kNumShardBits);
}
</pre>
</div>
<p>
对于Shard而言的话，capacity也需要进行均分:)
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">ShardedLRUCache</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">capacity</span>)
    : last_id_(0) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">per_shard</span> = (capacity + (kNumShards - 1)) / kNumShards;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">s</span> = 0; s &lt; kNumShards; s++) {
    shard_[s].SetCapacity(per_shard);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf531f9d" class="outline-4">
<h4 id="orgf531f9d"><span class="section-number-4">10.5.2</span> LRUCache</h4>
<div class="outline-text-4" id="text-10-5-2">
<p>
util/cache.cc LRUCache实现就是按照LRU来实现的.LRUCache每一个item是一个LRUHandle，而LRUHandle管理是放在HandleTable里面管理的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A single shard of sharded cache.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">LRUCache</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">LRUCache</span>();
  ~<span style="font-weight: bold;">LRUCache</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Separate from constructor so caller can easily make an array of LRUCache</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SetCapacity</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">capacity</span>) { capacity_ = capacity; }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Like Cache methods, but with an extra "hash" parameter.</span>
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold;">Insert</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">hash</span>,
                        <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">charge</span>,
                        <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">deleter</span>)(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>));
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold;">Lookup</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">hash</span>);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Release</span>(<span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">handle</span>);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Erase</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">hash</span>);

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">LRU_Remove</span>(<span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">e</span>);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">LRU_Append</span>(<span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">e</span>);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Unref</span>(<span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">e</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Initialized before use.</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">capacity_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">usage_&#30340;&#26368;&#22823;&#20540;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mutex_ protects the following state.</span>
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">Mutex</span> <span style="font-weight: bold; font-style: italic;">mutex_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#22810;&#32447;&#31243;&#26377;&#25928;</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">usage_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#20351;&#29992;&#22823;&#23567;.+=Insert&#21442;&#25968;&#30340;charge.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">last_id_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;ShardedLRUCache&#37324;&#38754;&#20351;&#29992;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Dummy head of LRU list.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lru.prev is newest entry, lru.next is oldest entry.</span>
  <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span> <span style="font-weight: bold; font-style: italic;">lru_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">LRU&#38142;.</span>

  <span style="font-weight: bold; text-decoration: underline;">HandleTable</span> <span style="font-weight: bold; font-style: italic;">table_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">LRUHandle&#30340;&#31649;&#29702;&#23545;&#35937;&#34920;(hashtable).</span>
};
</pre>
</div>
<p>
对于LRU<sub>Remove</sub>/LRU<sub>Append非常简单.这里稍微着重看看Insert</sub>/Loopup/Release/Erase的实现.
</p>
</div>

<ol class="org-ol">
<li><a id="org7bd6644"></a>Insert<br />
<div class="outline-text-5" id="text-10-5-2-1">
<p>
Insert的工作就是创建一个LRUHandle对象加入hashtable以及LRU队列里面.注意这里的引用计数
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; text-decoration: underline;">LRUCache</span>::<span style="font-weight: bold;">Insert</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">hash</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">charge</span>,
    <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">deleter</span>)(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>)) {
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);

  <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">e</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>*&gt;(
      malloc(<span style="font-weight: bold;">sizeof</span>(LRUHandle)-1 + key.size()));
  e-&gt;value = value; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">value.</span>
  e-&gt;deleter = deleter; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21024;&#38500;&#20989;&#25968;</span>
  e-&gt;charge = charge; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21344;&#29992;&#22823;&#23567;</span>
  e-&gt;key_length = key.size(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">key</span>
  e-&gt;hash = hash; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">hash</span>
  e-&gt;refs = 2;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">One from LRUCache, one for the returned handle</span>
  memcpy(e-&gt;key_data, key.data(), key.size());
  LRU_Append(e); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21152;&#20837;LRU&#38431;&#21015;</span>
  usage_ += charge; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#21344;&#29992;&#37327;</span>

  <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">old</span> = table_.Insert(e);
  <span style="font-weight: bold;">if</span> (old != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28120;&#27760;&#20986;&#30340;&#20869;&#23481;.</span>
    LRU_Remove(old);
    Unref(old);
  }

  <span style="font-weight: bold;">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) {
    <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">old</span> = lru_.next;
    LRU_Remove(old);
    table_.Remove(old-&gt;key(), old-&gt;hash);
    Unref(old);
  }

  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>*&gt;(e);
}
</pre>
</div>
</div>
</li>

<li><a id="orgf587166"></a>Lookup<br />
<div class="outline-text-5" id="text-10-5-2-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; text-decoration: underline;">LRUCache</span>::<span style="font-weight: bold;">Lookup</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">hash</span>) {
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">e</span> = table_.Lookup(key, hash); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25214;&#21040;&#23545;&#35937;</span>
  <span style="font-weight: bold;">if</span> (e != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    e-&gt;refs++; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38656;&#35201;&#20462;&#25913;&#24341;&#29992;&#35745;&#25968;.</span>
    LRU_Remove(e); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#25913;&#19968;&#19979;LRU&#29366;&#24577;.</span>
    LRU_Append(e);
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>*&gt;(e);
}
</pre>
</div>
</div>
</li>

<li><a id="orgf455a43"></a>Release<br />
<div class="outline-text-5" id="text-10-5-2-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">LRUCache</span>::<span style="font-weight: bold;">Release</span>(<span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">handle</span>) {
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  Unref(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>*&gt;(handle)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20943;&#23569;&#24341;&#29992;&#35745;&#25968;</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgb29757f"></a>Erase<br />
<div class="outline-text-5" id="text-10-5-2-4">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">LRUCache</span>::<span style="font-weight: bold;">Erase</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">hash</span>) {
  MutexLock <span style="font-weight: bold; text-decoration: underline;">l</span>(&amp;<span style="font-weight: bold; font-style: italic;">mutex_</span>);
  <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">e</span> = table_.Remove(key, hash); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;table&#37324;&#38754;remove&#20986;&#26469;</span>
  <span style="font-weight: bold;">if</span> (e != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    LRU_Remove(e); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;LRU&#38431;&#21015;&#37324;&#38754;&#31227;&#38500;&#20986;&#26469;</span>
    Unref(e); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">--&#24341;&#29992;&#35745;&#25968;.</span>
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org6968e56" class="outline-4">
<h4 id="org6968e56"><span class="section-number-4">10.5.3</span> LRUHandle</h4>
<div class="outline-text-4" id="text-10-5-3">
<p>
util/cache.cc LRUHandle是LRUCache的管理对象，我们主要就是为了看看里面的结构.LRUHandle一方面在LRU队列里面需要维护指针，
一方面在hashtable(HandleTable下面会讲到)需要维护指针.同时存在于LRU队列和HashTable里面.但是引用计数以LRU队列为准
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">An entry is a variable length heap-allocated structure.  Entries</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">are kept in a circular doubly linked list ordered by access time.</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span> {
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>;
  <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">deleter</span>)(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp;, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>);
  <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">next_hash</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;hash table&#30340;&#21333;&#21521;&#38142;&#34920;.</span>
  <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">next</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">LRU&#38431;&#21015;&#25152;&#38656;&#35201;&#30340;&#25351;&#38024;.</span>
  <span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>* <span style="font-weight: bold; font-style: italic;">prev</span>;
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">charge</span>;      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO(opt): Only allow uint32_t? // &#21344;&#29992;cache&#22823;&#23567;</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">key_length</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">refs</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24341;&#29992;&#35745;&#25968;.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">hash</span>;      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Hash of key(); used for fast sharding and comparisons // &#21487;&#33021;&#38656;&#35201;&#36827;&#34892;rehash.</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">key_data</span>[1];   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Beginning of key</span>

  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">key</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For cheaper lookups, we allow a temporary Handle object</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to store a pointer to a key in "value".</span>
    <span style="font-weight: bold;">if</span> (next == <span style="font-weight: bold;">this</span>) {
      <span style="font-weight: bold;">return</span> *(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Slice</span>*&gt;(value));
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold;">return</span> Slice(key_data, key_length);
    }
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org039f443" class="outline-4">
<h4 id="org039f443"><span class="section-number-4">10.5.4</span> HandleTable</h4>
<div class="outline-text-4" id="text-10-5-4">
<p>
util/cache.cc HandleTable实现非常简单，就是一个可扩展的hashtable.没有必要值得仔细分析。HandleTable主要就是用来管理
LRUHandle所管理的cache对象的。触发resize的操作是element &gt;= length.这里可以看看length的分配方式
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">new_length</span> = 4;
<span style="font-weight: bold;">while</span> (new_length &lt; elems_) {
  new_length *= 2;
}
</pre>
</div>
<p>
length肯定是2<sup>n.计算slot的方式就是</sup>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">LRUHandle</span>** <span style="font-weight: bold; font-style: italic;">ptr</span> = &amp;list_[hash &amp; (length_ - 1)];
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf5a1157" class="outline-3">
<h3 id="orgf5a1157"><span class="section-number-3">10.6</span> Batch</h3>
<div class="outline-text-3" id="text-10-6">
</div>
<div id="outline-container-org9ddf9ec" class="outline-4">
<h4 id="org9ddf9ec"><span class="section-number-4">10.6.1</span> WriteBatch</h4>
<div class="outline-text-4" id="text-10-6-1">
<p>
db/write<sub>batch.cc</sub> db/write<sub>batch</sub><sub>internal.h</sub> WriteBatch可以认为就是一个小型的数据记录仓库.
write<sub>batch</sub><sub>internal.h里面是一些write</sub><sub>batch里面可能使用到的静态函数</sub>，将选择将声明放在这个头文件里面而不是放在include/leveldb/write<sub>batch.h里面</sub>.
之前有一段注释表明WriteBatch内部二进制组织方式.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">WriteBatch::rep_ :=</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">sequence: fixed64</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">count: fixed32</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">data: record[count]</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">record :=</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">kTypeValue varstring varstring         |</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">kTypeDeletion varstring</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">varstring :=</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">len: varint32</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">data: uint8[len]</span>
</pre>
</div>
<ul class="org-ul">
<li>sequence fixed64</li>
<li>记录长度 fixed32(因为这个写入是多次的,所以存放fixed比较容易修改)</li>
<li>每条记录有头部表示数据还是删除.对于数据就是kv,对于删除只是存放k</li>
<li>kv的话都是varint32 + data</li>
</ul>
<p>
这里rep<sub>的类型是std</sub>::stirng.
</p>
</div>

<ol class="org-ol">
<li><a id="orgc03ebb8"></a>Count<br />
<div class="outline-text-5" id="text-10-6-1-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::<span style="font-weight: bold;">Count</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>* <span style="font-weight: bold; font-style: italic;">b</span>) {
  <span style="font-weight: bold;">return</span> DecodeFixed32(b-&gt;rep_.data() + 8);
}

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::<span style="font-weight: bold;">SetCount</span>(<span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>* <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  EncodeFixed32(&amp;b-&gt;rep_[8], n);
}
</pre>
</div>
</div>
</li>

<li><a id="orgbfd24cb"></a>Sequence<br />
<div class="outline-text-5" id="text-10-6-1-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::<span style="font-weight: bold;">Sequence</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>* <span style="font-weight: bold; font-style: italic;">b</span>) {
  <span style="font-weight: bold;">return</span> SequenceNumber(DecodeFixed64(b-&gt;rep_.data()));
}

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::<span style="font-weight: bold;">SetSequence</span>(<span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>* <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">seq</span>) {
  EncodeFixed64(&amp;b-&gt;rep_[0], seq);
}
</pre>
</div>
</div>
</li>

<li><a id="org5c930a7"></a>Contents<br />
<div class="outline-text-5" id="text-10-6-1-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30452;&#25509;&#35774;&#32622;WriteBatch&#20869;&#23481;.&#19981;&#36807;&#25105;&#35273;&#24471;&#24212;&#35813;&#27809;&#26377;&#22826;&#22810;&#29992;&#36884;&#21543;.</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::<span style="font-weight: bold;">SetContents</span>(<span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>* <span style="font-weight: bold; font-style: italic;">b</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">contents</span>) {
  assert(contents.size() &gt;= 12);
  b-&gt;rep_.assign(contents.data(), contents.size());
}
</pre>
</div>
</div>
</li>

<li><a id="org4445df2"></a>Clear<br />
<div class="outline-text-5" id="text-10-6-1-4">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>::<span style="font-weight: bold;">Clear</span>() {
  rep_.clear();
  rep_.resize(12); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22836;&#37096;&#24517;&#28982;&#23384;&#25918;12&#20010;&#23383;&#33410;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgf91821c"></a>Put<br />
<div class="outline-text-5" id="text-10-6-1-5">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>::<span style="font-weight: bold;">Put</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::SetCount(<span style="font-weight: bold;">this</span>, <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::Count(<span style="font-weight: bold;">this</span>) + 1);
  rep_.push_back(<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>&gt;(kTypeValue)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20165;&#20165;&#26159;value&#31867;&#22411;&#25805;&#20316;</span>
  PutLengthPrefixedSlice(&amp;rep_, key); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25918;&#20837;k,v.&#20043;&#21069;&#37117;&#23384;&#25918;&#20102;&#38271;&#24230;.</span>
  PutLengthPrefixedSlice(&amp;rep_, value);
}
</pre>
</div>
</div>
</li>

<li><a id="orgfbe8d15"></a>Delete<br />
<div class="outline-text-5" id="text-10-6-1-6">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>::<span style="font-weight: bold;">Delete</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::SetCount(<span style="font-weight: bold;">this</span>, <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::Count(<span style="font-weight: bold;">this</span>) + 1);
  rep_.push_back(<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>&gt;(kTypeDeletion)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20165;&#20165;&#26159;delete&#31867;&#22411;&#25805;&#20316;</span>
  PutLengthPrefixedSlice(&amp;rep_, key); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20165;&#20165;&#26159;&#23384;&#25918;key.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org49e286f"></a>InsertInto<br />
<div class="outline-text-5" id="text-10-6-1-7">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;WriteBatch&#20869;&#23481;&#20840;&#37096;&#25554;&#20837;&#21040;MemTable&#37324;&#38754;&#21435;.&#35843;&#29992;Iterate&#25509;&#21475;.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">MemTableInserter&#20250;&#22312;&#21518;&#38754;&#35762;&#35299;&#21040;.&#36825;&#20010;&#21487;&#20197;&#29992;&#20110;&#23558;WriteBatch&#25552;&#20132;.</span>
<span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::<span style="font-weight: bold;">InsertInto</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>* <span style="font-weight: bold; font-style: italic;">b</span>,
                                      <span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">memtable</span>) {
  <span style="font-weight: bold; text-decoration: underline;">MemTableInserter</span> <span style="font-weight: bold; font-style: italic;">inserter</span>;
  inserter.sequence_ = <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::Sequence(b);
  inserter.mem_ = memtable;
  <span style="font-weight: bold;">return</span> b-&gt;Iterate(&amp;inserter);
}
</pre>
</div>
</div>
</li>

<li><a id="org5ab6a49"></a>Iterate<br />
<div class="outline-text-5" id="text-10-6-1-8">
<p>
遍历内容存放到handler对象里面.要求handler有Put和Delete实现.这个实现在后面MemTableInserter有.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>::<span style="font-weight: bold;">Iterate</span>(<span style="font-weight: bold; text-decoration: underline;">Handler</span>* <span style="font-weight: bold; font-style: italic;">handler</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">input</span>(rep_);
  <span style="font-weight: bold;">if</span> (input.size() &lt; 12) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"malformed WriteBatch (too small)"</span>);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24573;&#30053;&#20043;&#21069;&#30340;12&#20010;&#23383;&#33410;.</span>
  input.remove_prefix(12);
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; font-style: italic;">value</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">found</span> = 0; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">found&#24212;&#35813;&#26159;&#29992;&#26469;&#36827;&#34892;&#26657;&#39564;&#30340;.</span>
  <span style="font-weight: bold;">while</span> (!input.empty()) {
    found++;
    <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">tag</span> = input[0];
    input.remove_prefix(1);
    <span style="font-weight: bold;">switch</span> (tag) {
      <span style="font-weight: bold;">case</span> kTypeValue: <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;kv&#25968;&#25454;&#30340;&#35805;.</span>
        <span style="font-weight: bold;">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;key) &amp;&amp;
            GetLengthPrefixedSlice(&amp;input, &amp;value)) {
          handler-&gt;Put(key, value); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992;handler-&gt;Put&#25509;&#21475;.</span>
        } <span style="font-weight: bold;">else</span> {
          <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"bad WriteBatch Put"</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#35748;&#20026;&#25968;&#25454;&#25439;&#22351;.</span>
        }
        <span style="font-weight: bold;">break</span>;
      <span style="font-weight: bold;">case</span> kTypeDeletion: <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;delete&#25805;&#20316;&#30340;&#35805;.</span>
        <span style="font-weight: bold;">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;key)) {
          handler-&gt;Delete(key); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#35843;&#29992;Delete&#25509;&#21475;</span>
        } <span style="font-weight: bold;">else</span> {
          <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"bad WriteBatch Delete"</span>);
        }
        <span style="font-weight: bold;">break</span>;
      <span style="font-weight: bold;">default</span>: <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#40664;&#35748;&#20026;&#25968;&#25454;&#25439;&#22351;.</span>
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"unknown WriteBatch tag"</span>);
    }
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26657;&#39564;&#19968;&#19979;&#20010;&#25968;&#26159;&#21542;&#27491;&#30830;.</span>
  <span style="font-weight: bold;">if</span> (found != <span style="font-weight: bold; text-decoration: underline;">WriteBatchInternal</span>::Count(<span style="font-weight: bold;">this</span>)) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"WriteBatch has wrong count"</span>);
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org2ff2f8f" class="outline-4">
<h4 id="org2ff2f8f"><span class="section-number-4">10.6.2</span> MemTable</h4>
<div class="outline-text-4" id="text-10-6-2">
<p>
db/memtable.cc MemTable应该算是leveldb里面的table一种.只不过所有的内容都是存放在内存里面的。我们首先看看字段和数据结构.
</p>

<p>
(#note: 阅读MemTable必须和WriteBatch的数据结构分开，这里非常容易弄混。WriteBatch是一个连续字节流的表示，是将所有的请求
序列化称为连续的字节流，而MemTable是将每一对kv做成一个连续字节流放入SkipList里面去.如果不分清楚的话这里非常容易搞混).
</p>
</div>

<ol class="org-ol">
<li><a id="org161ea82"></a>MemTable<br />
<div class="outline-text-5" id="text-10-6-2-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MemTable</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">MemTables are reference counted.  The initial reference count</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">is zero and the caller must call Ref() at least once.</span>
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">MemTable</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>&amp; <span style="font-weight: bold; font-style: italic;">comparator</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Increase reference count.</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Ref</span>() { ++refs_; } <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23384;&#22312;&#24341;&#29992;&#35745;&#25968;&#24182;&#19988;&#19968;&#24320;&#22987;==0.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Drop reference count.  Delete if no more references exist.</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Unref</span>() {
    --refs_;
    assert(refs_ &gt;= 0);
    <span style="font-weight: bold;">if</span> (refs_ &lt;= 0) {
      <span style="font-weight: bold;">delete</span> <span style="font-weight: bold;">this</span>;
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns an estimate of the number of bytes of data in use by this</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">data structure.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: external synchronization to prevent simultaneous</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">operations on the same MemTable.</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">ApproximateMemoryUsage</span>(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992;arena&#30340;MemoryUsage.&#22240;&#20026;&#36825;&#37324;&#38754;&#25152;&#26377;&#30340;&#20869;&#23384;&#37117;&#26159;&#20174;arena&#37324;&#38754;&#20998;&#37197;&#30340;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return an iterator that yields the contents of the memtable.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The caller must ensure that the underlying MemTable remains live</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">while the returned iterator is live.  The keys returned by this</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">iterator are internal keys encoded by AppendInternalKey in the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">db/format.{h,cc} module.</span>
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewIterator</span>(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20135;&#29983;&#26032;&#30340;&#36845;&#20195;&#22120;.&#25509;&#19979;&#26469;&#25105;&#20204;&#20250;&#30475;&#30475;&#36845;&#20195;&#22120;&#26159;&#22914;&#20309;&#23454;&#29616;&#30340;&#12290;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add an entry into memtable that maps key to value at the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">specified sequence number and with the specified type.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Typically value will be empty if type==kTypeDeletion.</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Add</span>(<span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">seq</span>, <span style="font-weight: bold; text-decoration: underline;">ValueType</span> <span style="font-weight: bold; font-style: italic;">type</span>,
           <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>,
           <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If memtable contains a value for key, store it in *value and return true.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If memtable contains a deletion for key, store a NotFound() error</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">in *status and return true.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Else, return false.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Get</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">LookupKey</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">value</span>, <span style="font-weight: bold; text-decoration: underline;">Status</span>* <span style="font-weight: bold; font-style: italic;">s</span>);

 <span style="font-weight: bold;">private</span>:
  ~<span style="font-weight: bold;">MemTable</span>();  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Private since only Unref() should be used to delete it</span>

  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">KeyComparator</span> {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span> <span style="font-weight: bold; font-style: italic;">comparator</span>;
    <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">KeyComparator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>&amp; <span style="font-weight: bold; font-style: italic;">c</span>) : comparator(c) { }
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">operator</span><span style="font-weight: bold;">()</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">b</span>) <span style="font-weight: bold;">const</span>;
  };
  <span style="font-weight: bold;">friend</span> <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MemTableIterator</span>;
  <span style="font-weight: bold;">friend</span> <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MemTableBackwardIterator</span>;

  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*, <span style="font-weight: bold; text-decoration: underline;">KeyComparator</span>&gt; <span style="font-weight: bold; text-decoration: underline;">Table</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24213;&#23618;Table&#32467;&#26500;&#26159;&#20351;&#29992;SkipList&#23384;&#20648;&#30340;.</span>

  <span style="font-weight: bold; text-decoration: underline;">KeyComparator</span> <span style="font-weight: bold; font-style: italic;">comparator_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">k&#27604;&#36739;&#22120;.</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">refs_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ref.</span>
  <span style="font-weight: bold; text-decoration: underline;">Arena</span> <span style="font-weight: bold; font-style: italic;">arena_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20869;&#23384;&#20998;&#37197;</span>
  <span style="font-weight: bold; text-decoration: underline;">Table</span> <span style="font-weight: bold; font-style: italic;">table_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">table</span>
};
</pre>
</div>
</div>
</li>

<li><a id="org221116d"></a>Compare<br />
<div class="outline-text-5" id="text-10-6-2-2">
<p>
这里KeyComparator的话因为考虑到key是length-prefixed的.底层使用InternalKeyComparator处理的就是
后面我们会看看InternalKeyComparator的实现.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">MemTable</span>::<span style="font-weight: bold; text-decoration: underline;">KeyComparator</span>::<span style="font-weight: bold;">operator</span><span style="font-weight: bold;">()</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">aptr</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">bptr</span>)
    <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Internal keys are encoded as length-prefixed strings.</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">a</span> = GetLengthPrefixedSlice(aptr);
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">b</span> = GetLengthPrefixedSlice(bptr);
  <span style="font-weight: bold;">return</span> comparator.Compare(a, b); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#35843;&#29992;&#24213;&#23618;&#30340;</span>
  <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">InternalKeyComparator.&#27880;&#24847;&#36825;&#37324;&#30340;aptr,bptr&#21253;&#25324;&#20102;&#21518;&#38754;&#38468;&#21152;&#30340;8&#23383;&#33410;&#20449;&#24687;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org2f29538"></a>Add<br />
<div class="outline-text-5" id="text-10-6-2-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">MemTable</span>::<span style="font-weight: bold;">Add</span>(<span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">s</span>, <span style="font-weight: bold; text-decoration: underline;">ValueType</span> <span style="font-weight: bold; font-style: italic;">type</span>,
                   <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>,
                   <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Format of an entry is concatenation of:</span>
  <span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">key_size     : varint32 of internal_key.size()</span>
  <span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">key bytes    : char[internal_key.size()]</span>
  <span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">value_size   : varint32 of value.size()</span>
  <span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">value bytes  : char[value.size()]</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">key_size</span> = key.size();
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">val_size</span> = value.size();
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">internal_key_size</span> = key_size + 8; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">internal key size +8.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">encoded_len</span> =
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#30340;key size&#21253;&#25324;&#20102;8&#23383;&#33410;&#30340;&#38468;&#21152;&#20449;&#24687;.</span>
      VarintLength(internal_key_size) + internal_key_size +
      VarintLength(val_size) + val_size;
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">buf</span> = arena_.Allocate(encoded_len);
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">p</span> = EncodeVarint32(buf, internal_key_size);
  memcpy(p, key.data(), key_size);
  p += key_size;
  EncodeFixed64(p, (s &lt;&lt; 8) | type); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#23601;&#26159;8&#20010;&#23383;&#33410;&#20195;&#34920;&#30340;&#21547;&#20041;.(seq &lt;&lt; 8) | type.</span>
  p += 8;
  p = EncodeVarint32(p, val_size);
  memcpy(p, value.data(), val_size);
  assert((p + val_size) - buf == encoded_len);
  table_.Insert(buf); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23558;&#36825;&#20010;key&#25554;&#20837;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgf849591"></a>Get<br />
<div class="outline-text-5" id="text-10-6-2-4">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#20351;&#29992;&#36845;&#20195;&#22120;&#26597;&#25214;&#23545;&#24212;&#30340;&#20869;&#23481;.&#26684;&#24335;&#30340;&#35805;&#21487;&#20197;&#21442;&#32771;Add&#30340;&#37324;&#38754;&#30340;&#23454;&#29616;</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">key_size + key_data + (seq &lt;&lt; 8) | type(8 bytes) + val_size + val_data.</span>
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">MemTable</span>::<span style="font-weight: bold;">Get</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">LookupKey</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">value</span>, <span style="font-weight: bold; text-decoration: underline;">Status</span>* <span style="font-weight: bold; font-style: italic;">s</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">memkey</span> = key.memtable_key();
  <span style="font-weight: bold; text-decoration: underline;">Table</span>::Iterator <span style="font-weight: bold; text-decoration: underline;">iter</span>(&amp;<span style="font-weight: bold; font-style: italic;">table_</span>);
  iter.Seek(memkey.data());
  <span style="font-weight: bold;">if</span> (iter.Valid()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">entry format is:</span>
    <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">klength  varint32</span>
    <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">userkey  char[klength]</span>
    <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">tag      uint64</span>
    <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">vlength  varint32</span>
    <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">value    char[vlength]</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Check that it belongs to same user key.  We do not check the</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sequence number since the Seek() call above should have skipped</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">all entries with overly large sequence numbers.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">entry</span> = iter.key();
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">key_length</span>;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">key_ptr</span> = GetVarint32Ptr(entry, entry+5, &amp;key_length);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#20351;&#29992;&#24213;&#23618;&#30340;comparator&#26469;&#36827;&#34892;&#27604;&#36739;.</span>
    <span style="font-weight: bold;">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(
            Slice(key_ptr, key_length - 8),
            key.user_key()) == 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Correct user key</span>
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">tag</span> = DecodeFixed64(key_ptr + key_length - 8);
      <span style="font-weight: bold;">switch</span> (<span style="font-weight: bold;">static_cast</span>&lt;ValueType&gt;(tag &amp; 0xff)) {
        <span style="font-weight: bold;">case</span> kTypeValue: {
          <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">v</span> = GetLengthPrefixedSlice(key_ptr + key_length);
          value-&gt;assign(v.data(), v.size());
          <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
        }
        <span style="font-weight: bold;">case</span> kTypeDeletion:
          *s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::NotFound(Slice());
          <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
      }
    }
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org2a52f7b" class="outline-4">
<h4 id="org2a52f7b"><span class="section-number-4">10.6.3</span> MemTableInserter</h4>
<div class="outline-text-4" id="text-10-6-3">
<p>
db/write<sub>batch.cc</sub> MemTableInserter作为WriteBatch::Handler实现,基本上可以认为是操作MemTable的代理类.
具体代码非常简单，实现部分可能需要看MemTable.这个后面会讲解
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MemTableInserter</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">WriteBatch</span>::<span style="font-weight: bold; text-decoration: underline;">Handler</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; text-decoration: underline;">SequenceNumber</span> <span style="font-weight: bold; font-style: italic;">sequence_</span>;
  <span style="font-weight: bold; text-decoration: underline;">MemTable</span>* <span style="font-weight: bold; font-style: italic;">mem_</span>;

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Put</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>) {
    mem_-&gt;Add(sequence_, kTypeValue, key, value);
    sequence_++; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#36825;&#37324;sequence_&#22312;++.&#34429;&#28982;&#19981;&#22826;&#28165;&#26970;&#36825;&#37324;sequence&#26377;&#20160;&#20040;&#29992;&#36884;.</span>
  }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Delete</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
    mem_-&gt;Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }
};
</pre>
</div>
<p>
至于sequence的初始值，在WriteBatchInternal::InsertInto里面是WriteBatch本身的Sequence作为初始值的。
</p>
</div>
</div>

<div id="outline-container-org24cd068" class="outline-4">
<h4 id="org24cd068"><span class="section-number-4">10.6.4</span> MemtableIterator</h4>
<div class="outline-text-4" id="text-10-6-4">
<p>
db/memtable.cc MemtableIterator实现非常简单，就是之前Table::Iterator的封装.后面我们会着重看看SkipList的实现.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*, KeyComparator&gt; <span style="font-weight: bold; text-decoration: underline;">Table</span>;
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MemTableIterator</span>: <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">MemTableIterator</span>(<span style="font-weight: bold; text-decoration: underline;">MemTable</span>::<span style="font-weight: bold; text-decoration: underline;">Table</span>* <span style="font-weight: bold; font-style: italic;">table</span>) : iter_(table) { }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Valid</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> iter_.Valid(); }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">k</span>) { iter_.Seek(EncodeKey(&amp;tmp_, k)); }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToFirst</span>() { iter_.SeekToFirst(); }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToLast</span>() { iter_.SeekToLast(); }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Next</span>() { iter_.Next(); }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Prev</span>() { iter_.Prev(); }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">key</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> GetLengthPrefixedSlice(iter_.key()); }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">value</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">key_slice</span> = GetLengthPrefixedSlice(iter_.key());
    <span style="font-weight: bold;">return</span> GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
  }

  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">status</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK(); }

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">MemTable</span>::<span style="font-weight: bold; text-decoration: underline;">Table</span>::<span style="font-weight: bold; text-decoration: underline;">Iterator</span> <span style="font-weight: bold; font-style: italic;">iter_</span>;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">tmp_</span>;       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For passing to EncodeKey</span>
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org793814e" class="outline-3">
<h3 id="org793814e"><span class="section-number-3">10.7</span> Log</h3>
<div class="outline-text-3" id="text-10-7">
</div>
<div id="outline-container-org822af64" class="outline-4">
<h4 id="org822af64"><span class="section-number-4">10.7.1</span> LogFormat</h4>
<div class="outline-text-4" id="text-10-7-1">
<p>
db/log<sub>format.h</sub> 里面规定的是db log格式上面的一些常量和信息.内容非常少，但是可以给予我们一点启发
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">enum</span> <span style="font-weight: bold; text-decoration: underline;">RecordType</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">record&#31867;&#22411;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Zero is reserved for preallocated files</span>
  <span style="font-weight: bold; font-style: italic;">kZeroType</span> = 0,

  <span style="font-weight: bold; font-style: italic;">kFullType</span> = 1,

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For fragments</span>
  <span style="font-weight: bold; font-style: italic;">kFirstType</span> = 2,
  <span style="font-weight: bold; font-style: italic;">kMiddleType</span> = 3,
  <span style="font-weight: bold; font-style: italic;">kLastType</span> = 4
};
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kMaxRecordType</span> = kLastType;

<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kBlockSize</span> = 32768; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#20010;block&#22823;&#23567;.</span>

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Header is checksum (4 bytes), type (1 byte), length (2 bytes).</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;EmitPhysicalRecord&#21487;&#20197;&#30475;&#21040;&#65292;&#23454;&#38469;&#23433;&#25490;&#26159;checksum,length,type.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kHeaderSize</span> = 4 + 1 + 2; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#20010;block&#30340;header&#26159;&#24590;&#20040;&#23433;&#25490;&#30340;.</span>
</pre>
</div>

<p>
下面LogWriter以及LogReader里面给出这个格式的实现，代码里面可以看出具体的实现。
但是幸运的是在level的文档里面也有这个format的说明。
</p>
<pre class="example">
The log file contents are a sequence of 32KB blocks.  The only
exception is that the tail of the file may contain a partial block.

Each block consists of a sequence of records:
   block := record* trailer?
   record :=
checksum: uint32// crc32c of type and data[]
length: uint16
type: uint8// One of FULL, FIRST, MIDDLE, LAST
data: uint8[length]

A record never starts within the last six bytes of a block (since it
won't fit).  Any leftover bytes here form the trailer, which must
consist entirely of zero bytes and must be skipped by readers.

Aside: if exactly seven bytes are left in the current block, and a new
non-zero length record is added, the writer must emit a FIRST record
(which contains zero bytes of user data) to fill up the trailing seven
bytes of the block and then emit all of the user data in subsequent
blocks.

More types may be added in the future.  Some Readers may skip record
types they do not understand, others may report that some data was
skipped.

FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4

The FULL record contains the contents of an entire user record.

FIRST, MIDDLE, LAST are types used for user records that have been
split into multiple fragments (typically because of block boundaries).
FIRST is the type of the first fragment of a user record, LAST is the
type of the last fragment of a user record, and MID is the type of all
interior fragments of a user record.

Example: consider a sequence of user records:
   A: length 1000
   B: length 97270
   C: length 8000
A will be stored as a FULL record in the first block.

B will be split into three fragments: first fragment occupies the rest
of the first block, second fragment occupies the entirety of the
second block, and the third fragment occupies a prefix of the third
block.  This will leave six bytes free in the third block, which will
be left empty as the trailer.

C will be stored as a FULL record in the fourth block.

===================

Some benefits over the recordio format:

(1) We do not need any heuristics for resyncing - just go to next
block boundary and scan.  If there is a corruption, skip to the next
block.  As a side-benefit, we do not get confused when part of the
contents of one log file are embedded as a record inside another log
file.

(2) Splitting at approximate boundaries (e.g., for mapreduce) is
simple: find the next block boundary and skip records until we
hit a FULL or FIRST record.

(3) We do not need extra buffering for large records.

Some downsides compared to recordio format:

(1) No packing of tiny records.  This could be fixed by adding a new
record type, so it is a shortcoming of the current implementation,
not necessarily the format.

(2) No compression.  Again, this could be fixed by adding new record types.
</pre>
</div>
</div>

<div id="outline-container-org914ad08" class="outline-4">
<h4 id="org914ad08"><span class="section-number-4">10.7.2</span> LogWriter</h4>
<div class="outline-text-4" id="text-10-7-2">
<p>
db/log<sub>writer.h</sub> db log writer.这里我们需要结合前面的LogFormatter一起看看.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Writer</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create a writer that will append data to "*dest".</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"*dest" must be initially empty.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"*dest" must remain live while this Writer is in use.</span>
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">Writer</span>(<span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">dest</span>);
  ~<span style="font-weight: bold;">Writer</span>();

  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">AddRecord</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">slice</span>);

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">dest_</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">block_offset_</span>;       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Current offset in block.&#22312;&#24403;&#21069;block&#30340;&#20301;&#32622;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">crc32c values for all supported record types.  These are</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pre-computed to reduce the overhead of computing the crc of the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">record type stored in the header.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">type_crc_</span>[kMaxRecordType + 1]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21508;&#31181;&#31867;&#22411;&#30340;crc32c.</span>

  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">EmitPhysicalRecord</span>(<span style="font-weight: bold; text-decoration: underline;">RecordType</span> <span style="font-weight: bold; font-style: italic;">type</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">length</span>);
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org3ccdd39"></a>Writer<br />
<div class="outline-text-5" id="text-10-7-2-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Writer</span>::<span style="font-weight: bold;">Writer</span>(<span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">dest</span>)
    : dest_(dest),
      block_offset_(0) {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt;= kMaxRecordType; i++) {
    <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">t</span> = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>&gt;(i); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38024;&#23545;&#31867;&#22411;&#35745;&#31639;&#30340;CRC32C.</span>
    type_crc_[i] = <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Value(&amp;t, 1);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orga5a0a15"></a>AddRecord<br />
<div class="outline-text-5" id="text-10-7-2-2">
<p>
我们这里看看每条Log到底是怎么写入的.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">Writer</span>::<span style="font-weight: bold;">AddRecord</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">slice</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ptr</span> = slice.data();
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">left</span> = slice.size();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fragment the record if necessary and emit it.  Note that if slice</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">is empty, we still want to iterate once to emit a single</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">zero-length record</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;Slice&#21097;&#20313;&#38271;&#24230;&#20026;0&#30340;&#35805;&#37027;&#20040;&#20381;&#28982;&#38656;&#35201;&#36755;&#20986;&#19968;&#26465;&#35760;&#24405;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">begin</span> = <span style="font-weight: bold; text-decoration: underline;">true</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#20026;&#22836;&#37096;.</span>
  <span style="font-weight: bold;">do</span> {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">leftover</span> = kBlockSize - block_offset_; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;block&#21097;&#20313;&#22810;&#23569;&#20869;&#23481;.</span>
    assert(leftover &gt;= 0);
    <span style="font-weight: bold;">if</span> (leftover &lt; kHeaderSize) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#36275;&#20197;&#23384;&#25918;&#19979;Header.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Switch to a new block</span>
      <span style="font-weight: bold;">if</span> (leftover &gt; 0) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fill the trailer (literal below relies on kHeaderSize being 7)</span>
        assert(kHeaderSize == 7);
        dest_-&gt;Append(Slice(<span style="font-style: italic;">"\x00\x00\x00\x00\x00\x00"</span>, leftover)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21097;&#20313;&#30340;&#37096;&#20998;&#22635;&#20805;0x00.</span>
      }
      block_offset_ = 0; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29616;&#22312;blcok_offset==0&#37325;&#26032;&#24320;&#36767;&#20102;&#19968;&#22359;&#20869;&#23481;.</span>
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Invariant: we never leave &lt; kHeaderSize bytes in a block.</span>
    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= 0);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#21097;&#20313;&#22810;&#23569;&#20869;&#23481;.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">avail</span> = kBlockSize - block_offset_ - kHeaderSize;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">fragment_length</span> = (left &lt; avail) ? left : avail;

    <span style="font-weight: bold; text-decoration: underline;">RecordType</span> <span style="font-weight: bold; font-style: italic;">type</span>;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">end</span> = (left == fragment_length); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#26159;&#21542;&#20026;&#35760;&#24405;&#30340;&#23614;&#37096;.</span>
    <span style="font-weight: bold;">if</span> (begin &amp;&amp; end) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#23436;&#20840;&#35760;&#24405;&#37027;&#20040;FullType.</span>
      type = kFullType;
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (begin) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#21482;&#26159;&#24320;&#22836;,FirstType.</span>
      type = kFirstType;
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (end) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19981;&#26159;&#24320;&#22836;&#20294;&#26159;&#32467;&#23614;LastType.</span>
      type = kLastType;
    } <span style="font-weight: bold;">else</span> {
      type = kMiddleType; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;MiddleType.</span>
    }

    s = EmitPhysicalRecord(type, ptr, fragment_length); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20010;&#37096;&#20998;&#36755;&#20986;.</span>
    ptr += fragment_length;
    left -= fragment_length;
    begin = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  } <span style="font-weight: bold;">while</span> (s.ok() &amp;&amp; left &gt; 0);
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="orgb3ec00d"></a>EmitPhysicalRecord<br />
<div class="outline-text-5" id="text-10-7-2-3">
<p>
我们在上面AddRecord里面看到了调用EmitPhysicalRecord.我们这里看看实现.参考在LogFormatter里面的注释.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">Writer</span>::<span style="font-weight: bold;">EmitPhysicalRecord</span>(<span style="font-weight: bold; text-decoration: underline;">RecordType</span> <span style="font-weight: bold; font-style: italic;">t</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  assert(n &lt;= 0xffff);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Must fit in two bytes</span>
  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Format the header</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[kHeaderSize];
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#23384;&#22312;&#24046;&#21035;&#65292;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#34920;&#31034;type.</span>
  buf[4] = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>&gt;(n &amp; 0xff); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20302;&#20301;.</span>
  buf[5] = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>&gt;(n &gt;&gt; 8); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39640;&#20301;.&#36825;&#26679;&#21487;&#20197;&#23567;&#31471;&#26041;&#24335;&#35835;&#21462;.</span>
  buf[6] = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>&gt;(t);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Compute the crc of the record type and the payload.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">crc</span> = <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Extend(type_crc_[t], ptr, n); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38024;&#23545;ptr&#36827;&#34892;CRC32&#21152;&#23494;.</span>
  crc = <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Mask(crc);                 <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Adjust for storage</span>
  EncodeFixed32(buf, crc); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23384;&#25918;&#22312;header&#37096;&#20998;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Write the header and the payload</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = dest_-&gt;Append(Slice(buf, kHeaderSize)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#20889;&#20837;Header&#37096;&#20998;.</span>
  <span style="font-weight: bold;">if</span> (s.ok()) {
    s = dest_-&gt;Append(Slice(ptr, n)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#36861;&#21152;&#25968;&#25454;&#37096;&#20998;.</span>
    <span style="font-weight: bold;">if</span> (s.ok()) {
      s = dest_-&gt;Flush();
    }
  }
  block_offset_ += kHeaderSize + n;
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org06a49f4" class="outline-4">
<h4 id="org06a49f4"><span class="section-number-4">10.7.3</span> LogReader</h4>
<div class="outline-text-4" id="text-10-7-3">
<p>
db/log<sub>reader.h</sub> db log reader.这里我们需要结合前面的LogReader以及LogFormatter一起看看.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Reader</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Interface for reporting errors.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27719;&#25253;&#38169;&#35823;&#25509;&#21475;.</span>
  <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Reporter</span> {
   <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">Reporter</span>();

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Some corruption was detected.  "size" is the approximate number</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of bytes dropped due to the corruption.</span>
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Corruption</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">status</span>) = 0;
  };

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create a reader that will return log records from "*file".</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"*file" must remain live while this Reader is in use.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If "reporter" is non-NULL, it is notified whenever some data is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">dropped due to a detected corruption.  "*reporter" must remain</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">live while this Reader is in use.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If "checksum" is true, verify checksums if available.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The Reader will start reading at the first record located at physical</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">position &gt;= initial_offset within the file.</span>
  <span style="font-weight: bold;">Reader</span>(<span style="font-weight: bold; text-decoration: underline;">SequentialFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>, <span style="font-weight: bold; text-decoration: underline;">Reporter</span>* <span style="font-weight: bold; font-style: italic;">reporter</span>, <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">checksum</span>,
         <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">initial_offset</span>);

  ~<span style="font-weight: bold;">Reader</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read the next record into *record.  Returns true if read</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">successfully, false if we hit end of the input.  May use</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"*scratch" as temporary storage.  The contents filled in *record</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">will only be valid until the next mutating operation on this</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">reader or the next mutation to *scratch.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">ReadRecord</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">record</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns the physical offset of the last record returned by ReadRecord.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Undefined before the first call to ReadRecord.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">LastRecordOffset</span>();

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">SequentialFile</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">file_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39034;&#24207;&#35835;&#21462;&#25991;&#20214;&#23545;&#35937;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Reporter</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">reporter_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25253;&#21578;&#38169;&#35823;&#23545;&#35937;.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">checksum_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26816;&#26597;CRC32C.</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">backing_store_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block buffer.</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">buffer_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">record buffer.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#34920;&#31034;&#19978;&#27425;&#35835;&#21462;block&#26159;&#21542;&#21040;&#36798;&#23614;&#37096;.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">eof_</span>;   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Last Read() indicated EOF by returning &lt; kBlockSize</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Offset of the last record returned by ReadRecord.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">last_record_offset_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19978;&#27425;ReadRecord&#23436;&#25104;&#20043;&#21518;&#30340;&#25991;&#20214;&#20559;&#31227;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Offset of the first location past the end of buffer_.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">end_of_buffer_offset_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462;&#21040;buffer_&#20043;&#21518;&#39034;&#24207;&#25991;&#20214;&#20559;&#31227;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Offset at which to start looking for the first record to return</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">initial_offset_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#21270;&#35835;&#21462;&#30340;offset.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Extend record types with the following special values</span>
  <span style="font-weight: bold;">enum</span> {
    <span style="font-weight: bold; font-style: italic;">kEof</span> = kMaxRecordType + 1,
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returned whenever we find an invalid physical record.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Currently there are three situations in which this happens:</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">* The record has an invalid CRC (ReadPhysicalRecord reports a drop)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">* The record is a 0-length record (No drop is reported)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">* The record is below constructor's initial_offset (No drop is reported)</span>
    <span style="font-weight: bold; font-style: italic;">kBadRecord</span> = kMaxRecordType + 2
  };

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Skips all blocks that are completely before "initial_offset_".</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns true on success. Handles reporting.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">SkipToInitialBlock</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return type, or one of the preceding special values</span>
  <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">ReadPhysicalRecord</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">result</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Reports dropped bytes to the reporter.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">buffer_ must be updated to remove the dropped bytes prior to invocation.</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ReportCorruption</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">reason</span>);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ReportDrop</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">reason</span>);
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org6c1162d"></a>Reader<br />
<div class="outline-text-5" id="text-10-7-3-1">
<p>
构造函数非常简单，注意这里开辟的backing<sub>store</sub>_，可以猜想到这个backing<sub>store是读取block内容临时开辟</sub>.
对于这些字段的含义可能第一眼看上去不太明白，这个分析代码应该可以看到每个字段的含义。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Reader</span>::<span style="font-weight: bold;">Reader</span>(<span style="font-weight: bold; text-decoration: underline;">SequentialFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>, <span style="font-weight: bold; text-decoration: underline;">Reporter</span>* <span style="font-weight: bold; font-style: italic;">reporter</span>, <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">checksum</span>,
               <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">initial_offset</span>)
    : file_(file),
      reporter_(reporter),
      checksum_(checksum),
      backing_store_(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[kBlockSize]),
      buffer_(),
      eof_(<span style="font-weight: bold; text-decoration: underline;">false</span>),
      last_record_offset_(0),
      end_of_buffer_offset_(0),
      initial_offset_(initial_offset) {
}
</pre>
</div>
</div>
</li>

<li><a id="orgfb409a8"></a>ReadPhysicalRecord<br />
<div class="outline-text-5" id="text-10-7-3-2">
<p>
从文件里面读取一个物理块大小出来kBlockSize.并且解析内容存放在bakcing<sub>store</sub><sub>里面</sub>，同时返回type.
这里很多细节都没有仔细看,只是理解大致的意思.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">Reader</span>::<span style="font-weight: bold;">ReadPhysicalRecord</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">result</span>) {
  <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">true</span>) {
    <span style="font-weight: bold;">if</span> (buffer_.size() &lt; kHeaderSize) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#20043;&#21069;&#35835;&#21462;&#30340;&#20869;&#23481;&#19981;&#22815;kHeaderSize&#22823;&#23567;&#30340;&#35805;.</span>
      <span style="font-weight: bold;">if</span> (!eof_) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19978;&#27425;&#35835;&#21462;&#27809;&#26377;&#21040;&#26411;&#23614;&#30340;&#35805;&#65292;&#37027;&#20040;&#35748;&#20026;&#19978;&#27425;&#35835;&#21462;&#26080;&#25928;&#65292;&#30452;&#25509;&#24573;&#30053;.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Last read was a full read, so this is a trailer to skip</span>
        buffer_.clear();
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24573;&#30053;&#20043;&#21518;&#37325;&#26032;&#35835;&#21462;&#19968;&#22359;.</span>
        <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status</span> = file_-&gt;Read(kBlockSize, &amp;buffer_, backing_store_);
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#27491;&#35835;&#21462;&#20559;&#31227;.&#24403;&#21069;&#35835;&#21462;&#20559;&#31227;.</span>
        end_of_buffer_offset_ += buffer_.size();
        <span style="font-weight: bold;">if</span> (!status.ok()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#35835;&#21462;&#22833;&#36133;&#30340;&#35805;.</span>
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
          <span style="font-weight: bold;">return</span> kEof;
        } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (buffer_.size() &lt; kBlockSize) {
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25104;&#21151;&#20294;&#26159;&#24050;&#32463;&#36798;&#21040;&#32467;&#23614;&#20102;.eof_=true</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37325;&#26032;&#21028;&#26029;&#35835;&#21462;&#30340;&#26159;&#21542;&#20026;&#27491;&#30830;&#30340;&#35760;&#24405;.</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#27491;&#30830;&#35835;&#21462;&#30340;&#35805;(&lt;kHeaderSize).&#20250;&#36827;&#20837;&#19979;&#38754;&#37027;&#20010;&#38169;&#35823;&#36923;&#36753;.</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#36827;&#20837;&#27491;&#24120;&#36923;&#36753;.</span>
          eof_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
        }
        <span style="font-weight: bold;">continue</span>;
      } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (buffer_.size() == 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#26159;&#30830;&#23454;&#27809;&#26377;&#20219;&#20309;&#35760;&#24405;&#23384;&#22312;&#20102;.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">End of file</span>
        <span style="font-weight: bold;">return</span> kEof;
      } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25991;&#20214;&#26411;&#23614;&#35835;&#21462;&#22833;&#36133;(&#25130;&#26029;)</span>
        <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">drop_size</span> = buffer_.size();
        buffer_.clear();
        ReportCorruption(drop_size, <span style="font-style: italic;">"truncated record at end of file"</span>);
        <span style="font-weight: bold;">return</span> kEof;
      }
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20551;&#35774;&#21040;&#36825;&#37324;&#30340;&#35805;&#25105;&#20204;&#37117;&#24050;&#32463;&#35835;&#21462;&#20102;&#19968;&#20010;&#23436;&#25972;&#30340;block&#20102;.&#25105;&#20204;&#39318;&#20808;&#35299;&#26512;&#22836;&#37096;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Parse the header</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">header</span> = buffer_.data();
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">a</span> = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint32_t</span>&gt;(header[4]) &amp; 0xff;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">b</span> = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint32_t</span>&gt;(header[5]) &amp; 0xff;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">type</span> = header[6]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454;&#31867;&#22411;&#21644;&#38271;&#24230;.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">length</span> = a | (b &lt;&lt; 8);
    <span style="font-weight: bold;">if</span> (kHeaderSize + length &gt; buffer_.size()) {
      <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">drop_size</span> = buffer_.size();
      buffer_.clear();
      ReportCorruption(drop_size, <span style="font-style: italic;">"bad record length"</span>);
      <span style="font-weight: bold;">return</span> kBadRecord;
    }

    <span style="font-weight: bold;">if</span> (type == kZeroType &amp;&amp; length == 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Skip zero length record without reporting any drops since</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">such records are produced by the mmap based writing code in</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">env_posix.cc that preallocates file regions.</span>
      buffer_.clear();
      <span style="font-weight: bold;">return</span> kBadRecord;
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26816;&#26597;crc&#26657;&#39564;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Check crc</span>
    <span style="font-weight: bold;">if</span> (checksum_) {
      <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">expected_crc</span> = <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Unmask(DecodeFixed32(header));
      <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">actual_crc</span> = <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Value(header + 6, 1 + length); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20570;crc32c&#38656;&#35201;&#21253;&#21547;type&#23383;&#27573;.</span>
      <span style="font-weight: bold;">if</span> (actual_crc != expected_crc) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Drop the rest of the buffer since "length" itself may have</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">been corrupted and if we trust it, we could find some</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">fragment of a real log record that just happens to look</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">like a valid log record.</span>
        <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">drop_size</span> = buffer_.size();
        buffer_.clear();
        ReportCorruption(drop_size, <span style="font-style: italic;">"checksum mismatch"</span>);
        <span style="font-weight: bold;">return</span> kBadRecord;
      }
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;buffer_&#36825;&#37324;&#20570;&#19968;&#20010;&#26657;&#39564;.</span>
    buffer_.remove_prefix(kHeaderSize + length);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Skip physical record that started before initial_offset_</span>
    <span style="font-weight: bold;">if</span> (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length &lt;
        initial_offset_) {
      result-&gt;clear();
      <span style="font-weight: bold;">return</span> kBadRecord;
    }

    *result = Slice(header + kHeaderSize, length);
    <span style="font-weight: bold;">return</span> type;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org50fe9bc"></a>ReadRecord<br />
<div class="outline-text-5" id="text-10-7-3-3">
<p>
ReadRecord读取的是一条逻辑记录.底层调用ReadPhysicalRecord将多条物理记录结合起来.实话说里面具体逻辑没有看懂，
但是大致意思算是明白了。对于FullType来说的话record里面使用backing<sub>store内存</sub>，而对于First/Middle/Last来说的话
里面使用的是scratch分配的内存.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">Reader</span>::<span style="font-weight: bold;">ReadRecord</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">record</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">scratch</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36824;&#27809;&#26377;&#36339;&#36807;initial offset&#30340;&#35805;</span>
  <span style="font-weight: bold;">if</span> (last_record_offset_ &lt; initial_offset_) {
    <span style="font-weight: bold;">if</span> (!SkipToInitialBlock()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#20989;&#25968;&#21518;&#38754;&#20250;&#20998;&#26512;.</span>
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
    }
  }

  scratch-&gt;clear(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;scratch&#20197;&#21450;record&#28165;&#31354;</span>
  record-&gt;clear(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#29468;&#38169;&#30340;&#35805;&#65292;&#37027;&#20040;record&#37324;&#38754;&#31649;&#29702;&#30340;&#26159;scratch&#30340;&#20869;&#23384;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#26159;&#20043;&#21518;&#20250;&#21457;&#29616;&#20854;&#23454;record&#37324;&#38754;&#20063;&#21487;&#33021;&#21547;&#26377;backing_store&#30340;&#20869;&#23481;.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">in_fragmented_record</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Record offset of the logical record that we're reading</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0 is a dummy value to make compilers happy</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">prospective_record_offset</span> = 0;

  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">fragment</span>;
  <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">true</span>) {
    <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">physical_record_offset</span> = end_of_buffer_offset_ - buffer_.size();
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">record_type</span> = ReadPhysicalRecord(&amp;fragment); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462;&#19968;&#20010;block.</span>
    <span style="font-weight: bold;">switch</span> (record_type) {
      <span style="font-weight: bold;">case</span> kFullType:
        <span style="font-weight: bold;">if</span> (in_fragmented_record) {
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Handle bug in earlier versions of log::Writer where</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">it could emit an empty kFirstType record at the tail end</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of a block followed by a kFullType or kFirstType record</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">at the beginning of the next block.</span>
          <span style="font-weight: bold;">if</span> (scratch-&gt;empty()) {
            in_fragmented_record = <span style="font-weight: bold; text-decoration: underline;">false</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24573;&#30053;&#36825;&#31181;&#38169;&#35823;.&#21487;&#33021;&#26159;&#32771;&#34385;&#20860;&#23481;.</span>
          } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462;&#21040;FullType&#20294;&#26159;&#21364;&#26377;fragmented&#30340;&#34920;&#31034;.</span>
            ReportCorruption(scratch-&gt;size(), <span style="font-style: italic;">"partial record without end(1)"</span>);
          }
        }
        prospective_record_offset = physical_record_offset;
        scratch-&gt;clear();
        *record = fragment; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30452;&#25509;&#32473;record.&#36825;&#37324;record&#25345;&#26377;backing_store&#25968;&#25454;.</span>
        last_record_offset_ = prospective_record_offset;
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;

      <span style="font-weight: bold;">case</span> kFirstType:
        <span style="font-weight: bold;">if</span> (in_fragmented_record) {
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Handle bug in earlier versions of log::Writer where</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">it could emit an empty kFirstType record at the tail end</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of a block followed by a kFullType or kFirstType record</span>
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">at the beginning of the next block.</span>
          <span style="font-weight: bold;">if</span> (scratch-&gt;empty()) {
            in_fragmented_record = <span style="font-weight: bold; text-decoration: underline;">false</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24573;&#30053;&#36825;&#31181;&#38169;&#35823;,&#21487;&#33021;&#26159;&#32771;&#34385;&#20860;&#23481;.</span>
          } <span style="font-weight: bold;">else</span> {
            ReportCorruption(scratch-&gt;size(), <span style="font-style: italic;">"partial record without end(2)"</span>);
          }
        }
        prospective_record_offset = physical_record_offset;
        scratch-&gt;assign(fragment.data(), fragment.size());
        in_fragmented_record = <span style="font-weight: bold; text-decoration: underline;">true</span>;
        <span style="font-weight: bold;">break</span>;

      <span style="font-weight: bold;">case</span> kMiddleType:
        <span style="font-weight: bold;">if</span> (!in_fragmented_record) {
          ReportCorruption(fragment.size(),
                           <span style="font-style: italic;">"missing start of fragmented record(1)"</span>);
        } <span style="font-weight: bold;">else</span> {
          scratch-&gt;append(fragment.data(), fragment.size());
        }
        <span style="font-weight: bold;">break</span>;

      <span style="font-weight: bold;">case</span> kLastType:
        <span style="font-weight: bold;">if</span> (!in_fragmented_record) {
          ReportCorruption(fragment.size(),
                           <span style="font-style: italic;">"missing start of fragmented record(2)"</span>);
        } <span style="font-weight: bold;">else</span> {
          scratch-&gt;append(fragment.data(), fragment.size());
          *record = Slice(*scratch);
          last_record_offset_ = prospective_record_offset;
          <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
        }
        <span style="font-weight: bold;">break</span>;

      <span style="font-weight: bold;">case</span> kEof:
        <span style="font-weight: bold;">if</span> (in_fragmented_record) {
          ReportCorruption(scratch-&gt;size(), <span style="font-style: italic;">"partial record without end(3)"</span>);
          scratch-&gt;clear();
        }
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;

      <span style="font-weight: bold;">case</span> kBadRecord:
        <span style="font-weight: bold;">if</span> (in_fragmented_record) {
          ReportCorruption(scratch-&gt;size(), <span style="font-style: italic;">"error in middle of record"</span>);
          in_fragmented_record = <span style="font-weight: bold; text-decoration: underline;">false</span>;
          scratch-&gt;clear();
        }
        <span style="font-weight: bold;">break</span>;

      <span style="font-weight: bold;">default</span>: {
        <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[40];
        snprintf(buf, <span style="font-weight: bold;">sizeof</span>(buf), <span style="font-style: italic;">"unknown record type %u"</span>, record_type);
        ReportCorruption(
            (fragment.size() + (in_fragmented_record ? scratch-&gt;size() : 0)),
            buf);
        in_fragmented_record = <span style="font-weight: bold; text-decoration: underline;">false</span>;
        scratch-&gt;clear();
        <span style="font-weight: bold;">break</span>;
      }
    }
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
}
</pre>
</div>
</div>
</li>

<li><a id="orgc0995a5"></a>SkipToInitialBlock<br />
<div class="outline-text-5" id="text-10-7-3-4">
<p>
跳过开头的部分.实际上只是跳过按照kBlockSize整数块部分。这个部分不需要用户主动调用.在ReadRecord里面调用.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">Reader</span>::<span style="font-weight: bold;">SkipToInitialBlock</span>() {
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">offset_in_block</span> = initial_offset_ % kBlockSize;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">block_start_location</span> = initial_offset_ - offset_in_block;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Don't search a block if we'd be in the trailer</span>
  <span style="font-weight: bold;">if</span> (offset_in_block &gt; kBlockSize - 6) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#19981;&#22826;&#26126;&#30333;&#26159;&#20160;&#20040;&#24847;&#24605;.&#20026;&#20160;&#20040;&#26159;6.</span>
    offset_in_block = 0;
    block_start_location += kBlockSize;
  }

  end_of_buffer_offset_ = block_start_location;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Skip to start of first block that can contain the initial record</span>
  <span style="font-weight: bold;">if</span> (block_start_location &gt; 0) {
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">skip_status</span> = file_-&gt;Skip(block_start_location);
    <span style="font-weight: bold;">if</span> (!skip_status.ok()) {
      ReportDrop(block_start_location, skip_status); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#38754;&#20250;&#20998;&#26512;.</span>
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
    }
  }

  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
}
</pre>
</div>
</div>
</li>

<li><a id="org27b9537"></a>ReportDrop<br />
<div class="outline-text-5" id="text-10-7-3-5">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Reader</span>::<span style="font-weight: bold;">ReportDrop</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">reason</span>) {
  <span style="font-weight: bold;">if</span> (reporter_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp;
      end_of_buffer_offset_ - buffer_.size() - bytes &gt;= initial_offset_) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#21518;&#38754;&#36825;&#20010;&#26465;&#20214;&#27809;&#26377;&#30475;&#25026;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24212;&#35813;&#26159;&#21028;&#26029;&#22914;&#26524;&#36824;&#27809;&#26377;&#24320;&#22987;&#35835;&#30340;&#35805;&#37027;&#20040;&#19981;&#20250;&#25253;&#21578;&#38169;&#35823;.</span>
    reporter_-&gt;Corruption(bytes, reason);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org339752a"></a>ReportCorruption<br />
<div class="outline-text-5" id="text-10-7-3-6">
<p>
这个过程非常简单就是调用ReportDrop.然后使用Status::Corruption封装.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Reader</span>::<span style="font-weight: bold;">ReportCorruption</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">reason</span>) {
  ReportDrop(bytes, <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(reason));
}
</pre>
</div>
</div>
</li>

<li><a id="orgced8f23"></a>LastRecordOffset<br />
<div class="outline-text-5" id="text-10-7-3-7">
<p>
上次调用ReadRecord之后的文件偏移是多少
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; text-decoration: underline;">Reader</span>::<span style="font-weight: bold;">LastRecordOffset</span>() {
  <span style="font-weight: bold;">return</span> last_record_offset_;
}
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org2c95e77" class="outline-3">
<h3 id="org2c95e77"><span class="section-number-3">10.8</span> Table</h3>
<div class="outline-text-3" id="text-10-8">
</div>
<div id="outline-container-org4e49a78" class="outline-4">
<h4 id="org4e49a78"><span class="section-number-4">10.8.1</span> TableFormat</h4>
<div class="outline-text-4" id="text-10-8-1">
<p>
我们在分析后面的接口之前最好首先看看table文件的组织格式是怎么样的。这些table都是排好序的所以查询特别快。
对于这些table通常称为sstable(sorted string table).关于table格式在leveldb/doc/table<sub>format.txt里面有说明</sub>.
本质上我们可认为sstable是一个二级索引文件.首先读取footer.得到metaindex block和index block位置.然后读取index block
或者是metaindex block(上面存在排序k进行二分查找)，然后读取data block(k排序然后进行二分查找).
</p>
<pre class="example">
File format
===========

  &lt;beginning_of_file&gt;
  [data block 1]
  [data block 2]
  ...
  [data block N]
  [meta block 1]
  ...
  [meta block K]
  [metaindex block]
  [index block]
  [Footer]        (fixed size; starts at file_size - sizeof(Footer))
  &lt;end_of_file&gt;

The file contains internal pointers.  Each such pointer is called
a BlockHandle and contains the following information:
offset:    varint64
size:    varint64

(1) The sequence of key/value pairs in the file are stored in sorted
order and partitioned into a sequence of data blocks.  These blocks
come one after another at the beginning of the file.  Each data block
is formatted according to the code in block_builder.cc, and then
optionally compressed.

(2) After the data blocks we store a bunch of meta blocks.  The
supported meta block types are described below.  More meta block types
may be added in the future.  Each meta block is again formatted using
block_builder.cc and then optionally compressed.

(3) A "metaindex" block.  It contains one entry for every other meta
block where the key is the name of the meta block and the value is a
BlockHandle pointing to that meta block.

(4) An "index" block.  This block contains one entry per data block,
where the key is a string &gt;= last key in that data block and before
the first key in the successive data block.  The value is the
BlockHandle for the data block.

(6) At the very end of the file is a fixed length footer that contains
the BlockHandle of the metaindex and index blocks as well as a magic number.
       metaindex_handle:       char[p];    // Block handle for metaindex
index_handle:       char[q];    // Block handle for index
padding:       char[40-p-q]; // 0 bytes to make fixed length
       // (40==2*BlockHandle::kMaxEncodedLength)
magic:       fixed64;    // == 0xdb4775248b80fb57

"stats" Meta Block
------------------

This meta block contains a bunch of stats.  The key is the name
of the statistic.  The value contains the statistic.
TODO(postrelease): record following stats.
  data size
  index size
  key size (uncompressed)
  value size (uncompressed)
  number of entries
  number of data blocks
</pre>
</div>
</div>

<div id="outline-container-orgfb5cfdb" class="outline-4">
<h4 id="orgfb5cfdb"><span class="section-number-4">10.8.2</span> BuildTable</h4>
<div class="outline-text-4" id="text-10-8-2">
<p>
db/builder.h BuildTable过程非常简单就是构造一个sstable.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">BuildTable</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>,
                  <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold; font-style: italic;">env</span>,
                  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                  <span style="font-weight: bold; text-decoration: underline;">TableCache</span>* <span style="font-weight: bold; font-style: italic;">table_cache</span>,
                  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">iter</span>,
                  <span style="font-weight: bold; text-decoration: underline;">FileMetaData</span>* <span style="font-weight: bold; font-style: italic;">meta</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span>;
  meta-&gt;file_size = 0;
  iter-&gt;SeekToFirst();

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">fname</span> = TableFileName(dbname, meta-&gt;number); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;number&#36825;&#20010;&#23383;&#27573;&#21547;&#20041;.</span>
  <span style="font-weight: bold;">if</span> (iter-&gt;Valid()) {
    <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>;
    s = env-&gt;NewWritableFile(fname, &amp;file); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#26032;&#30340;&#25991;&#20214;.</span>
    <span style="font-weight: bold;">if</span> (!s.ok()) {
      <span style="font-weight: bold;">return</span> s;
    }

    <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>* <span style="font-weight: bold; font-style: italic;">builder</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>(options, file);
    meta-&gt;smallest.DecodeFrom(iter-&gt;key()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36941;&#21382;iter&#37324;&#38754;&#30340;&#23545;&#35937;.&#36825;&#37324;&#20250;&#35760;&#24405;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#23567;&#21644;&#26368;&#22823;&#30340;key&#35760;&#24405;&#22312;meta&#37324;&#38754;.</span>
    <span style="font-weight: bold;">for</span> (; iter-&gt;Valid(); iter-&gt;Next()) {
      <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">key</span> = iter-&gt;key();
      meta-&gt;largest.DecodeFrom(key);
      builder-&gt;Add(key, iter-&gt;value());
    }

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Finish and check for builder errors</span>
    <span style="font-weight: bold;">if</span> (s.ok()) {
      s = builder-&gt;Finish(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20889;&#20837;index&#20197;&#21450;footer&#37096;&#20998;.</span>
      <span style="font-weight: bold;">if</span> (s.ok()) {
        meta-&gt;file_size = builder-&gt;FileSize();
        assert(meta-&gt;file_size &gt; 0);
      }
    } <span style="font-weight: bold;">else</span> {
      builder-&gt;Abandon();
    }
    <span style="font-weight: bold;">delete</span> builder;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Finish and check for file errors</span>
    <span style="font-weight: bold;">if</span> (s.ok()) {
      s = file-&gt;Sync();
    }
    <span style="font-weight: bold;">if</span> (s.ok()) {
      s = file-&gt;Close();
    }
    <span style="font-weight: bold;">delete</span> file;
    file = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20250;&#23558;&#36825;&#20010;sstable&#21152;&#20837;&#21040;TableCache&#37324;&#38754;.</span>
    <span style="font-weight: bold;">if</span> (s.ok()) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Verify that the table is usable</span>
      <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">it</span> = table_cache-&gt;NewIterator(ReadOptions(),
                                              meta-&gt;number,
                                              meta-&gt;file_size);
      s = it-&gt;status();
      <span style="font-weight: bold;">delete</span> it;
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Check for input iterator errors</span>
  <span style="font-weight: bold;">if</span> (!iter-&gt;status().ok()) {
    s = iter-&gt;status();
  }

  <span style="font-weight: bold;">if</span> (s.ok() &amp;&amp; meta-&gt;file_size &gt; 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Keep it</span>
  } <span style="font-weight: bold;">else</span> {
    env-&gt;DeleteFile(fname);
  }
  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd0e2d95" class="outline-4">
<h4 id="orgd0e2d95"><span class="section-number-4">10.8.3</span> TableCache</h4>
<div class="outline-text-4" id="text-10-8-3">
<p>
db/table<sub>cache.cc</sub> TableCache的工作非常简单，就是针对Table对象以及Table::Iterator对象进行cache.
这样底层的话可以防止过多的文件打开。了解这个功能之后代码就非常好阅读了。我们首先看看TableCache结构.
对于Cache的key使用uint64<sub>t</sub> file<sub>number来进行标记</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">TableCache</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">TableCache</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>* <span style="font-weight: bold; font-style: italic;">options</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">entries</span>);
  ~<span style="font-weight: bold;">TableCache</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return an iterator for the specified file number (the corresponding</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file length must be exactly "file_size" bytes).  If "tableptr" is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">non-NULL, also sets "*tableptr" to point to the Table object</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">underlying the returned iterator, or NULL if no Table object underlies</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the returned iterator.  The returned "*tableptr" object is owned by</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the cache and should not be deleted, and is valid for as long as the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">returned iterator is live.</span>
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                        <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_number</span>,
                        <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_size</span>,
                        <span style="font-weight: bold; text-decoration: underline;">Table</span>** <span style="font-weight: bold; font-style: italic;">tableptr</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Evict any entry for the specified file number</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Evict</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_number</span>);

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">Env</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">env_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24213;&#23618;env</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">dbname_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25171;&#24320;db&#21517;&#31216;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>* <span style="font-weight: bold; font-style: italic;">options_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25171;&#24320;options.</span>
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>* <span style="font-weight: bold; font-style: italic;">cache_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Cache&#23545;&#35937;.</span>
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org1c2968c"></a>TableCache<br />
<div class="outline-text-5" id="text-10-8-3-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">TableCache</span>::<span style="font-weight: bold;">TableCache</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">dbname</span>,
                       <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>* <span style="font-weight: bold; font-style: italic;">options</span>,
                       <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">entries</span>)
    : env_(options-&gt;env),
      dbname_(dbname),
      options_(options),
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">entries&#34920;&#31034;Cache&#30340;capacity.</span>
      cache_(NewLRUCache(entries)) {
}

<span style="font-weight: bold; text-decoration: underline;">TableCache</span>::~<span style="font-weight: bold;">TableCache</span>() {
  <span style="font-weight: bold;">delete</span> cache_;
}
</pre>
</div>
</div>
</li>

<li><a id="org0e59792"></a>Evict<br />
<div class="outline-text-5" id="text-10-8-3-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TableCache</span>::<span style="font-weight: bold;">Evict</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_number</span>) {
  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[<span style="font-weight: bold;">sizeof</span>(file_number)];
  EncodeFixed64(buf, file_number);
  cache_-&gt;Erase(Slice(buf, <span style="font-weight: bold;">sizeof</span>(buf)));
}
</pre>
</div>
</div>
</li>

<li><a id="orgd708e3b"></a>NewIterator<br />
<div class="outline-text-5" id="text-10-8-3-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">TableAndFile</span> {
  <span style="font-weight: bold; text-decoration: underline;">RandomAccessFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;file&#21644;table&#32465;&#23450;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Table</span>* <span style="font-weight: bold; font-style: italic;">table</span>;
};

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">DeleteEntry</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">TableAndFile</span>* <span style="font-weight: bold; font-style: italic;">tf</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">TableAndFile</span>*&gt;(value);
  <span style="font-weight: bold;">delete</span> tf-&gt;table;
  <span style="font-weight: bold;">delete</span> tf-&gt;file;
  <span style="font-weight: bold;">delete</span> tf;
}

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">UnrefEntry</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg1</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg2</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>* <span style="font-weight: bold; font-style: italic;">cache</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Cache</span>*&gt;(arg1);
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">h</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>*&gt;(arg2);
  cache-&gt;Release(h);
}

<span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; text-decoration: underline;">TableCache</span>::<span style="font-weight: bold;">NewIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                                  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_number</span>,
                                  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">file_size</span>,
                                  <span style="font-weight: bold; text-decoration: underline;">Table</span>** <span style="font-weight: bold; font-style: italic;">tableptr</span>) {
  <span style="font-weight: bold;">if</span> (tableptr != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    *tableptr = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }

  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[<span style="font-weight: bold;">sizeof</span>(file_number)];
  EncodeFixed64(buf, file_number); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454;file_number&#20316;&#20026;key&#26597;&#35810;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">key</span>(buf, <span style="font-weight: bold;">sizeof</span>(buf));
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">handle</span> = cache_-&gt;Lookup(key); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#22312;cache&#37324;&#38754;&#26597;&#25214;.</span>
  <span style="font-weight: bold;">if</span> (handle == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">fname</span> = TableFileName(dbname_, file_number);
    <span style="font-weight: bold; text-decoration: underline;">RandomAccessFile</span>* <span style="font-weight: bold; font-style: italic;">file</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    <span style="font-weight: bold; text-decoration: underline;">Table</span>* <span style="font-weight: bold; font-style: italic;">table</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = env_-&gt;NewRandomAccessFile(fname, &amp;file);
    <span style="font-weight: bold;">if</span> (s.ok()) {
      s = <span style="font-weight: bold; text-decoration: underline;">Table</span>::Open(*options_, file, file_size, &amp;table);
    }

    <span style="font-weight: bold;">if</span> (!s.ok()) {
      assert(table == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
      <span style="font-weight: bold;">delete</span> file;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We do not cache error results so that if the error is transient,</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">or somebody repairs the file, we recover automatically.</span>
      <span style="font-weight: bold;">return</span> NewErrorIterator(s);
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#19968;&#20010;cache item</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;charge=1&#37027;&#20040;capacity&#23601;&#34920;&#31034;&#20010;&#25968;.</span>
    <span style="font-weight: bold; text-decoration: underline;">TableAndFile</span>* <span style="font-weight: bold; font-style: italic;">tf</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">TableAndFile</span>;
    tf-&gt;file = file;
    tf-&gt;table = table;
    handle = cache_-&gt;Insert(key, tf, 1, &amp;DeleteEntry);
  }

  <span style="font-weight: bold; text-decoration: underline;">Table</span>* <span style="font-weight: bold; font-style: italic;">table</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">TableAndFile</span>*&gt;(cache_-&gt;Value(handle))-&gt;table;
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">result</span> = table-&gt;NewIterator(options);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;cleanup&#20989;&#25968;&#26159;&#20943;&#23569;&#24341;&#29992;&#35745;&#25968;.</span>
  result-&gt;RegisterCleanup(&amp;UnrefEntry, cache_, handle);
  <span style="font-weight: bold;">if</span> (tableptr != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    *tableptr = table;
  }
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org1bfe238" class="outline-4">
<h4 id="org1bfe238"><span class="section-number-4">10.8.4</span> Table</h4>
<div class="outline-text-4" id="text-10-8-4">
<p>
table/table.cc 这个接口在include/leveldb/table.h里面已经给出了.我们这里就是看看具体实现.
</p>
</div>

<ol class="org-ol">
<li><a id="orgec8dbd0"></a>Rep<br />
<div class="outline-text-5" id="text-10-8-4-1">
<p>
Rep是Table内部的数据结构.这样实现了之后那么头文件里面可以不包含任何实现了.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Table</span>::<span style="font-weight: bold; text-decoration: underline;">Rep</span> {
  ~<span style="font-weight: bold;">Rep</span>() {
    <span style="font-weight: bold;">delete</span> index_block;
  }

  <span style="font-weight: bold; text-decoration: underline;">Options</span> <span style="font-weight: bold; font-style: italic;">options</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status</span>;
  <span style="font-weight: bold; text-decoration: underline;">RandomAccessFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">cache_id</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">todo:&#22312;BlockReader&#37324;&#38754;&#20316;&#20026;cache key&#30340;&#19968;&#37096;&#20998;&#23384;&#22312;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38382;&#39064;&#26159;&#36825;&#20010;cache_id&#20027;&#35201;&#26159;&#29992;&#26469;&#35299;&#20915;&#20160;&#20040;&#38382;&#39064;&#30340;&#21602;?</span>

  <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span> <span style="font-weight: bold; font-style: italic;">metaindex_handle</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Handle to metaindex_block: saved from footer</span>
  <span style="font-weight: bold; text-decoration: underline;">Block</span>* <span style="font-weight: bold; font-style: italic;">index_block</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20445;&#23384;data index&#30340;block.</span>
};
</pre>
</div>
</div>
</li>

<li><a id="org47e21c7"></a>Open<br />
<div class="outline-text-5" id="text-10-8-4-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">Table</span>::<span style="font-weight: bold;">Open</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                   <span style="font-weight: bold; text-decoration: underline;">RandomAccessFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>,
                   <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">size</span>,
                   <span style="font-weight: bold; text-decoration: underline;">Table</span>** <span style="font-weight: bold; font-style: italic;">table</span>) {
  *table = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold;">if</span> (size &lt; <span style="font-weight: bold; text-decoration: underline;">Footer</span>::kEncodedLength) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#25991;&#20214;&#22823;&#23567;&#32943;&#23450;&#38656;&#35201;&#19968;&#20010;footer&#23545;&#35937;.</span>
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::InvalidArgument(<span style="font-style: italic;">"file is too short to be an sstable"</span>);
  }

  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">footer_space</span>[<span style="font-weight: bold; text-decoration: underline;">Footer</span>::kEncodedLength]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">footer&#31354;&#38388;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">footer_input</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462;footer.</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = file-&gt;Read(size - <span style="font-weight: bold; text-decoration: underline;">Footer</span>::kEncodedLength, <span style="font-weight: bold; text-decoration: underline;">Footer</span>::kEncodedLength,
                        &amp;footer_input, footer_space);
  <span style="font-weight: bold;">if</span> (!s.ok()) <span style="font-weight: bold;">return</span> s;

  <span style="font-weight: bold; text-decoration: underline;">Footer</span> <span style="font-weight: bold; font-style: italic;">footer</span>;
  s = footer.DecodeFrom(&amp;footer_input);
  <span style="font-weight: bold;">if</span> (!s.ok()) <span style="font-weight: bold;">return</span> s;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read the index block</span>
  <span style="font-weight: bold; text-decoration: underline;">Block</span>* <span style="font-weight: bold; font-style: italic;">index_block</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold;">if</span> (s.ok()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35835;&#21462;index block.</span>
    s = ReadBlock(file, ReadOptions(), footer.index_handle(), &amp;index_block);
  }

  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We've successfully read the footer and the index block: we're</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ready to serve requests.</span>
    <span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">rep</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Table</span>::<span style="font-weight: bold; text-decoration: underline;">Rep</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">new&#21019;&#24314;Rep&#23545;&#35937;&#28982;&#21518;&#26500;&#36896;Table&#23545;&#35937;.</span>
    rep-&gt;options = options;
    rep-&gt;file = file;
    rep-&gt;metaindex_handle = footer.metaindex_handle();
    rep-&gt;index_block = index_block;
    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : 0);
    *table = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Table</span>(rep);
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">if</span> (index_block) <span style="font-weight: bold;">delete</span> index_block;
  }

  <span style="font-weight: bold;">return</span> s;
}
</pre>
</div>
</div>
</li>

<li><a id="org43e6085"></a>ApproximateOffsetOf<br />
<div class="outline-text-5" id="text-10-8-4-3">
<p>
根据key找到kv在file的偏移.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; text-decoration: underline;">Table</span>::<span style="font-weight: bold;">ApproximateOffsetOf</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">index_iter</span> =
      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);
  index_iter-&gt;Seek(key); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20351;&#29992;iterator seek&#21040;kv&#30340;index&#30340;&#20301;&#32622;.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">result</span>;
  <span style="font-weight: bold;">if</span> (index_iter-&gt;Valid()) {
    <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span> <span style="font-weight: bold; font-style: italic;">handle</span>;
    <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">input</span> = index_iter-&gt;value();
    <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = handle.DecodeFrom(&amp;input); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;index&#36825;&#20010;BlockHandle&#20013;&#30693;&#36947;&#25968;&#25454;&#30340;&#20559;&#31227;.</span>
    <span style="font-weight: bold;">if</span> (s.ok()) {
      result = handle.offset();
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Strange: we can't decode the block handle in the index block.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We'll just return the offset of the metaindex block, which is</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">close to the whole file size for this case.</span>
      result = rep_-&gt;metaindex_handle.offset();
    }
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">key is past the last key in the file.  Approximate the offset</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">by returning the offset of the metaindex block (which is</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">right near the end of the file).</span>
    result = rep_-&gt;metaindex_handle.offset();
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#25214;&#19981;&#21040;&#36825;&#20010;key&#30340;&#35805;&#65292;&#37027;&#20040;&#36820;&#22238;metaindex block&#30340;&#20559;&#31227;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#26159;meta block&#30340;&#26368;&#21518;&#20301;&#32622;.</span>
  <span style="font-weight: bold;">delete</span> index_iter;
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</li>

<li><a id="orgb7892b4"></a>NewIterator<br />
<div class="outline-text-5" id="text-10-8-4-4">
<p>
NewIterator创建的是TwoLevelIterator.意思非常简单因为需要读取两次才能够读到内容.首先读取index block,
然后读取具体的data block.关于TwoLevelIterator的实现会在后面分析.建议首先分析TwoLevelIterator
然后分析BlockReader.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; text-decoration: underline;">Table</span>::<span style="font-weight: bold;">NewIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">return</span> NewTwoLevelIterator(
      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),
      &amp;<span style="font-weight: bold; text-decoration: underline;">Table</span>::BlockReader, <span style="font-weight: bold;">const_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Table</span>*&gt;(<span style="font-weight: bold;">this</span>), options);
}
</pre>
</div>
</div>
</li>

<li><a id="org5ff7a3d"></a>DeleteBlock<br />
<div class="outline-text-5" id="text-10-8-4-5">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">DeleteBlock</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ignored</span>) {
  <span style="font-weight: bold;">delete</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Block</span>*&gt;(arg); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20316;&#20026;Block&#30452;&#25509;delete.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgd67e0c3"></a>DeleteCachedBlock<br />
<div class="outline-text-5" id="text-10-8-4-6">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">DeleteCachedBlock</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Block</span>* <span style="font-weight: bold; font-style: italic;">block</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Block</span>*&gt;(value); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20316;&#20026;Block&#30452;&#25509;&#21024;&#38500;.</span>
  <span style="font-weight: bold;">delete</span> block;
}
</pre>
</div>
</div>
</li>

<li><a id="orgf48fcd2"></a>ReleaseBlock<br />
<div class="outline-text-5" id="text-10-8-4-7">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ReleaseBlock</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">h</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>* <span style="font-weight: bold; font-style: italic;">cache</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Cache</span>*&gt;(arg);
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">handle</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>*&gt;(h);
  cache-&gt;Release(handle);
}
</pre>
</div>
</div>
</li>

<li><a id="org35d4225"></a>BlockReader<br />
<div class="outline-text-5" id="text-10-8-4-8">
<p>
BlockReader任务就是通过读取index<sub>value给定的位置然后读取对应的Block位置并且返回BlockIterator对象</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Convert an index iterator value (i.e., an encoded BlockHandle)</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">into an iterator over the contents of the corresponding block.</span>
<span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; text-decoration: underline;">Table</span>::<span style="font-weight: bold;">BlockReader</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>,
                             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                             <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">index_value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Table</span>* <span style="font-weight: bold; font-style: italic;">table</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Table</span>*&gt;(arg);
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>* <span style="font-weight: bold; font-style: italic;">block_cache</span> = table-&gt;rep_-&gt;options.block_cache;
  <span style="font-weight: bold; text-decoration: underline;">Block</span>* <span style="font-weight: bold; font-style: italic;">block</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold; text-decoration: underline;">Cache</span>::<span style="font-weight: bold; text-decoration: underline;">Handle</span>* <span style="font-weight: bold; font-style: italic;">cache_handle</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

  <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span> <span style="font-weight: bold; font-style: italic;">handle</span>;
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">input</span> = index_value;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = handle.DecodeFrom(&amp;input); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20808;&#25214;&#21040;offset&#21644;size.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We intentionally allow extra stuff in index_value so that we</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">can add more features in the future.</span>

  <span style="font-weight: bold;">if</span> (s.ok()) {
    <span style="font-weight: bold;">if</span> (block_cache != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#23384;&#22312;Cache&#30340;&#35805;.</span>
      <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">cache_key_buffer</span>[16];
      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;handle.offset&#21644;cache_id&#20570;&#19968;&#20010;&#31614;&#21517;&#26597;&#35810;.</span>
      EncodeFixed64(cache_key_buffer+8, handle.offset());
      <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">key</span>(cache_key_buffer, <span style="font-weight: bold;">sizeof</span>(cache_key_buffer));
      cache_handle = block_cache-&gt;Lookup(key);
      <span style="font-weight: bold;">if</span> (cache_handle != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#23384;&#22312;&#36825;&#20010;&#23545;&#35937;&#30340;&#35805;.</span>
        block = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Block</span>*&gt;(block_cache-&gt;Value(cache_handle));
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#36825;&#20010;&#23545;&#35937;&#30340;&#35805;.&#37027;&#20040;&#30452;&#25509;&#35835;&#21462;&#23545;&#35937;.</span>
        s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;block);
        <span style="font-weight: bold;">if</span> (s.ok() &amp;&amp; options.fill_cache) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26597;&#21040;&#32467;&#26524;&#25918;&#21040;cache&#30340;&#35805;.</span>
          cache_handle = block_cache-&gt;Insert( <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25554;&#20837;&#36825;&#20010;&#23545;&#35937;.</span>
              <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#20174;Cache&#20013;&#21024;&#38500;&#30340;&#22238;&#35843;&#23601;&#26159;&#30452;&#25509;delete.</span>
              key, block, block-&gt;size(), &amp;DeleteCachedBlock);
        }
      }
    } <span style="font-weight: bold;">else</span> {
      s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;block);
    }
  }

  <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">iter</span>;
  <span style="font-weight: bold;">if</span> (block != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24471;&#21040;&#36825;&#20010;block&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#21019;&#24314;&#36825;&#20010;Iterator.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#26159;&#19968;&#20010;user comparator.</span>
    iter = block-&gt;NewIterator(table-&gt;rep_-&gt;options.comparator);
    <span style="font-weight: bold;">if</span> (cache_handle == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#25918;&#22312;cache&#37324;&#38754;&#30340;&#35805;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#24403;&#36825;&#20010;iterator&#22833;&#25928;&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;&#23558;Block&#21024;&#38500;.</span>
      iter-&gt;RegisterCleanup(&amp;DeleteBlock, block, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#30340;&#35805;&#37027;&#20040;&#38656;&#35201;&#20351;&#29992;&#24341;&#29992;&#35745;&#25968;.&#25152;&#20197;ReleaseBlock&#37324;&#38754;&#26159;&#37319;&#29992;Release&#26041;&#24335;.</span>
      iter-&gt;RegisterCleanup(&amp;ReleaseBlock, block_cache, cache_handle);
    }
  } <span style="font-weight: bold;">else</span> {
    iter = NewErrorIterator(s);
  }
  <span style="font-weight: bold;">return</span> iter;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org72ae76b" class="outline-4">
<h4 id="org72ae76b"><span class="section-number-4">10.8.5</span> TableBuilder</h4>
<div class="outline-text-4" id="text-10-8-5">
<p>
table/table<sub>builde.cc</sub> TableBuilder接口在之前include/leveldb/table<sub>builder.h里面已经提供了</sub>。
这里我们具体看看TableBuilder的接口.关于table格式的话可以参考TableFormat这节.注意这里TableBuilder
只是将kv加入到了block并且写入了磁盘，但是对于index block并没有写入磁盘。
</p>
</div>

<ol class="org-ol">
<li><a id="orgf7bb129"></a>Rep<br />
<div class="outline-text-5" id="text-10-8-5-1">
<p>
Rep是TableBuilder里面具体涉及到的字段.我们来看看这个结构
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>::<span style="font-weight: bold; text-decoration: underline;">Rep</span> {
  <span style="font-weight: bold; text-decoration: underline;">Options</span> <span style="font-weight: bold; font-style: italic;">options</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25968;&#25454;options.</span>
  <span style="font-weight: bold; text-decoration: underline;">Options</span> <span style="font-weight: bold; font-style: italic;">index_block_options</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">index options.</span>
  <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sstable&#25991;&#20214;.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">offset</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#21521;&#36825;&#20010;file&#20889;&#20837;&#20102;&#22810;&#23569;&#25968;&#25454;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">file&#25805;&#20316;&#36820;&#22238;&#30340;status.</span>
  <span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span> <span style="font-weight: bold; font-style: italic;">data_block</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">data block.</span>
  <span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span> <span style="font-weight: bold; font-style: italic;">index_block</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">index block.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">last_key</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19978;&#27425;&#25554;&#20837;&#30340;key.</span>
  <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">num_entries</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24050;&#32463;&#25554;&#20837;&#20102;&#22810;&#23569;&#20010;kv.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">closed</span>;          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Either Finish() or Abandon() has been called.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We do not emit the index entry for a block until we have seen the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">first key for the next data block.  This allows us to use shorter</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">keys in the index block.  For example, consider a block boundary</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">between the keys "the quick brown fox" and "the who".  We can use</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"the r" as the key for the index block entry since it is &gt;= all</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">entries in the first block and &lt; all entries in subsequent</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">blocks.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Invariant: r-&gt;pending_index_entry is true only if data_block is empty.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">pending_index_entry</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21542;&#21018;&#25165;&#35843;&#29992;&#20102;Finish.</span>
  <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span> <span style="font-weight: bold; font-style: italic;">pending_handle</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Handle to add to index block</span>

  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">compressed_output</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20316;&#20026;compressed&#23384;&#25918;&#30340;&#20869;&#23481;.</span>

  <span style="font-weight: bold;">Rep</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">opt</span>, <span style="font-weight: bold; text-decoration: underline;">WritableFile</span>* <span style="font-weight: bold; font-style: italic;">f</span>)
      : options(opt),
        index_block_options(opt),
        file(f),
        offset(0),
        data_block(&amp;options),
        index_block(&amp;index_block_options),
        num_entries(0),
        closed(<span style="font-weight: bold; text-decoration: underline;">false</span>),
        pending_index_entry(<span style="font-weight: bold; text-decoration: underline;">false</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37324;&#38754;&#23384;&#25918;&#30340;key&#26159;&#20840;&#37327;.</span>
    index_block_options.block_restart_interval = 1; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">index block option restart&#20026;1.</span>
  }
};
</pre>
</div>
</div>
</li>

<li><a id="orgb244c3f"></a>ChangeOptions<br />
<div class="outline-text-5" id="text-10-8-5-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>::<span style="font-weight: bold;">ChangeOptions</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note: if more fields are added to Options, update</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">this function to catch changes that should not be allowed to</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">change in the middle of building a Table.</span>
  <span style="font-weight: bold;">if</span> (options.comparator != rep_-&gt;options.comparator) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38656;&#35201;&#30830;&#20445;comparator&#23545;&#35937;&#27809;&#26377;&#21457;&#29983;&#25913;&#21464;.</span>
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::InvalidArgument(<span style="font-style: italic;">"changing comparator while building table"</span>);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note that any live BlockBuilders point to rep_-&gt;options and therefore</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">will automatically pick up the updated options.</span>
  rep_-&gt;options = options;
  rep_-&gt;index_block_options = options;
  rep_-&gt;index_block_options.block_restart_interval = 1
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
}
</pre>
</div>
</div>
</li>

<li><a id="orgc150b12"></a>Add<br />
<div class="outline-text-5" id="text-10-8-5-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>::<span style="font-weight: bold;">Add</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">r</span> = rep_;
  assert(!r-&gt;closed);
  <span style="font-weight: bold;">if</span> (!ok()) <span style="font-weight: bold;">return</span>;
  <span style="font-weight: bold;">if</span> (r-&gt;num_entries &gt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30830;&#20445;&#25353;&#29031;&#39034;&#24207;&#25805;&#20316;.</span>
    assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key)) &gt; 0);
  }

  <span style="font-weight: bold;">if</span> (r-&gt;pending_index_entry) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36825;&#37324;&#26032;&#24320;&#36767;&#19968;&#20010;block&#30340;&#35805;&#23545;&#20110;&#31532;&#19968;&#22359;&#27809;&#26377;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#25105;&#20204;&#36825;&#37324;&#20570;&#19968;&#20010;index.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">index key&#26159;&#25353;&#29031;last_ley&#21644;key&#20043;&#38388;&#30340;FindShortestSeparator&#24471;&#21040;&#30340;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#26679;&#21487;&#20197;&#20351;&#29992;&#20108;&#20998;&#27861;&#26469;&#36827;&#34892;&#25628;&#32034;.</span>
    assert(r-&gt;data_block.empty());
    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">handle_encoding</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38405;&#35835;&#23436;Finish&#20250;&#21457;&#29616;&#36825;&#37324;handle_encoding&#23454;&#38469;&#19978;&#26159;&#23601;&#26159;last_key&#30340;&#20301;&#32622;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#20351;&#29992;FindShortestSeparator&#26356;&#21152;&#33410;&#30465;&#31354;&#38388;&#20316;&#20026;index_block&#37324;&#38754;&#30340;&#20869;&#23481;.:).</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#36825;&#37324;&#20063;&#20915;&#23450;&#20102;index_block&#30340;key&#19981;&#33021;&#22815;&#20316;&#20026;data block&#37324;&#38754;&#20934;&#30830;&#30340;key.</span>
    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);
    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));
    r-&gt;pending_index_entry = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26356;&#26032;last_key&#24182;&#19988;&#25554;&#20837;data block.</span>
  r-&gt;last_key.assign(key.data(), key.size());
  r-&gt;num_entries++;
  r-&gt;data_block.Add(key, value);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#24403;&#21069;&#30340;size&#36229;&#36807;block size&#30340;&#35805;&#37027;&#20040;&#23601;&#38656;&#35201;&#21047;&#26032;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">estimated_block_size</span> = r-&gt;data_block.CurrentSizeEstimate();
  <span style="font-weight: bold;">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) {
    Flush();
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgea5a4fb"></a>Flush<br />
<div class="outline-text-5" id="text-10-8-5-4">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>::<span style="font-weight: bold;">Flush</span>() {
  <span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">r</span> = rep_;
  assert(!r-&gt;closed);
  <span style="font-weight: bold;">if</span> (!ok()) <span style="font-weight: bold;">return</span>;
  <span style="font-weight: bold;">if</span> (r-&gt;data_block.empty()) <span style="font-weight: bold;">return</span>;
  assert(!r-&gt;pending_index_entry);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;data block&#20316;&#20026;Block&#20889;&#20837;&#28982;&#21518;&#23558;&#36825;&#20010;handle&#25918;&#22312;pengding_handle&#37324;&#38754;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;WriteBlock&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;&#20102;.</span>
  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);
  <span style="font-weight: bold;">if</span> (ok()) {
    r-&gt;pending_index_entry = <span style="font-weight: bold; text-decoration: underline;">true</span>;
    r-&gt;status = r-&gt;file-&gt;Flush();
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgeed725c"></a>WriteBlock<br />
<div class="outline-text-5" id="text-10-8-5-5">
<p>
写入block的内容并且将block所在的位置交给handle.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>::<span style="font-weight: bold;">WriteBlock</span>(<span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span>* <span style="font-weight: bold; font-style: italic;">block</span>, <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>* <span style="font-weight: bold; font-style: italic;">handle</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">File format contains a sequence of blocks where each block has:</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">block_data: uint8[n]</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">type: uint8</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">crc: uint32</span>
  assert(ok());
  <span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">r</span> = rep_;
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">raw</span> = block-&gt;Finish();

  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">block_contents</span>;
  <span style="font-weight: bold; text-decoration: underline;">CompressionType</span> <span style="font-weight: bold; font-style: italic;">type</span> = r-&gt;options.compression;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO(postrelease): Support more compression options: zlib?</span>
  <span style="font-weight: bold;">switch</span> (type) {
    <span style="font-weight: bold;">case</span> kNoCompression:
      block_contents = raw;
      <span style="font-weight: bold;">break</span>;

    <span style="font-weight: bold;">case</span> kSnappyCompression: {
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">compressed</span> = &amp;r-&gt;compressed_output;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23581;&#35797;&#20351;&#29992;snappy compress.&#22914;&#26524;&#21387;&#32553;&#26356;&#22823;&#30340;&#35805;&#37027;&#20040;&#25918;&#24323;.</span>
      <span style="font-weight: bold;">if</span> (<span style="font-weight: bold; text-decoration: underline;">port</span>::Snappy_Compress(raw.data(), raw.size(), compressed) &amp;&amp;
          compressed-&gt;size() &lt; raw.size() - (raw.size() / 8u)) {
        block_contents = *compressed;
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Snappy not supported, or compressed less than 12.5%, so just</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">store uncompressed form</span>
        block_contents = raw;
        type = kNoCompression;
      }
      <span style="font-weight: bold;">break</span>;
    }
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;handle&#20026;block&#30340;&#20301;&#32622;.</span>
  handle-&gt;set_offset(r-&gt;offset);
  handle-&gt;set_size(block_contents.size());
  r-&gt;status = r-&gt;file-&gt;Append(block_contents);
  <span style="font-weight: bold;">if</span> (r-&gt;status.ok()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20889;&#20837;type&#21644;crc33c:).</span>
    <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">trailer</span>[kBlockTrailerSize];
    trailer[0] = type;
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">crc</span> = <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Value(block_contents.data(), block_contents.size());
    crc = <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Extend(crc, trailer, 1);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Extend crc to cover block type</span>
    EncodeFixed32(trailer+1, <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Mask(crc));
    r-&gt;status = r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));
    <span style="font-weight: bold;">if</span> (r-&gt;status.ok()) {
      r-&gt;offset += block_contents.size() + kBlockTrailerSize;
    }
  }
  r-&gt;compressed_output.clear();
  block-&gt;Reset();
}
</pre>
</div>
</div>
</li>

<li><a id="org8dd7d19"></a>Finish<br />
<div class="outline-text-5" id="text-10-8-5-6">
<p>
Finish写入的TableFormat表述的最后面的index部分以及footer.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>::<span style="font-weight: bold;">Finish</span>() {
  <span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">r</span> = rep_;
  Flush();
  assert(!r-&gt;closed);
  r-&gt;closed = <span style="font-weight: bold; text-decoration: underline;">true</span>;
  <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span> <span style="font-weight: bold; font-style: italic;">metaindex_block_handle</span>;
  <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span> <span style="font-weight: bold; font-style: italic;">index_block_handle</span>;
  <span style="font-weight: bold;">if</span> (ok()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23454;&#38469;&#19978;&#36825;&#20010;meta_index_block&#37096;&#20998;&#27809;&#26377;&#20219;&#20309;&#20869;&#23481;.</span>
    <span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span> <span style="font-weight: bold; font-style: italic;">meta_index_block</span>(&amp;r-&gt;options);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO(postrelease): Add stats and other meta blocks</span>
    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20889;&#20837;&#20043;&#21518;&#28982;&#21518;&#24471;&#21040;handle.</span>
  }
  <span style="font-weight: bold;">if</span> (ok()) {
    <span style="font-weight: bold;">if</span> (r-&gt;pending_index_entry) {
      r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);
      <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">handle_encoding</span>;
      r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);
      r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));
      r-&gt;pending_index_entry = <span style="font-weight: bold; text-decoration: underline;">false</span>;
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20889;&#20837;index block.</span>
    WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);
  }
  <span style="font-weight: bold;">if</span> (ok()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#21518;&#23558;footer&#37096;&#20998;&#20889;&#20837;.</span>
    <span style="font-weight: bold; text-decoration: underline;">Footer</span> <span style="font-weight: bold; font-style: italic;">footer</span>;
    footer.set_metaindex_handle(metaindex_block_handle);
    footer.set_index_handle(index_block_handle);
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">footer_encoding</span>;
    footer.EncodeTo(&amp;footer_encoding);
    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);
    <span style="font-weight: bold;">if</span> (r-&gt;status.ok()) {
      r-&gt;offset += footer_encoding.size();
    }
  }
  <span style="font-weight: bold;">return</span> r-&gt;status;
}
</pre>
</div>
</div>
</li>

<li><a id="orgb5ab47f"></a>Abandon<br />
<div class="outline-text-5" id="text-10-8-5-7">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25805;&#20316;&#38750;&#24120;&#31616;&#21333;&#23601;&#26159;&#25918;&#24323;&#26500;&#24314;.</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TableBuilder</span>::<span style="font-weight: bold;">Abandon</span>() {
  <span style="font-weight: bold; text-decoration: underline;">Rep</span>* <span style="font-weight: bold; font-style: italic;">r</span> = rep_;
  assert(!r-&gt;closed);
  r-&gt;closed = <span style="font-weight: bold; text-decoration: underline;">true</span>;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org9ac07d9" class="outline-4">
<h4 id="org9ac07d9"><span class="section-number-4">10.8.6</span> BlockBuilder</h4>
<div class="outline-text-4" id="text-10-8-6">
<p>
table/block<sub>builder.h</sub> 从提供的接口来看的话，BlockBuilder功能应该是将多个有序的kv写到一个连续内存块内部。
我们首先看看结构然后具体分析里面的方法.提供的Reset接口允许BlockBuilder重复使用.底层针对key的prefix部分进行了压缩.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">BlockBuilder</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>* <span style="font-weight: bold; font-style: italic;">options</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Reset the contents as if the BlockBuilder was just constructed.</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Reset</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Finish() has not been callled since the last call to Reset().</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: key is larger than any previously added key</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Add</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30830;&#20445;key&#30340;&#26377;&#24207;&#24615;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Finish building the block and return a slice that refers to the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block contents.  The returned slice will remain valid for the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lifetime of this builder or until Reset() is called.</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">Finish</span>(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23436;&#25104;&#20043;&#21518;&#36820;&#22238;&#20889;&#20837;&#30340;buffer.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns an estimate of the current (uncompressed) size of the block</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we are building.</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">CurrentSizeEstimate</span>() <span style="font-weight: bold;">const</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36820;&#22238;block buffer&#22823;&#23567;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return true iff no entries have been added since the last Reset()</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">empty</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> buffer_.empty();
  }

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>*        <span style="font-weight: bold; font-style: italic;">options_</span>;
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>           <span style="font-weight: bold; font-style: italic;">buffer_</span>;      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Destination buffer</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint32_t</span>&gt; <span style="font-weight: bold; font-style: italic;">restarts_</span>;    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Restart points</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span>                   <span style="font-weight: bold; font-style: italic;">counter_</span>;     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Number of entries emitted since restart</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span>                  <span style="font-weight: bold; font-style: italic;">finished_</span>;    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Has Finish() been called?</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>           <span style="font-weight: bold; font-style: italic;">last_key_</span>;
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org4cf6827"></a>PrefixCompressed<br />
<div class="outline-text-5" id="text-10-8-6-1">
<p>
我们首先看看BlockBuilder是如何针对key进行prefix-compressed的.对于每K个key的话会保存一个完整key,然后对于
剩余的K-1个key采用prefix-compressed的方式压缩。共享的部分长度叫做shared<sub>bytes,非共享的部分叫做unshared</sub><sub>bytes</sub>.
对于保存这些完整的key的点，叫做restarts.这个非常好理解。然后从下面注释可以看到restarts的信息保存在最后.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">When we store a key, we drop the prefix shared with the previous</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">string.  This helps reduce the space requirement significantly.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Furthermore, once every K keys, we do not apply the prefix</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">compression and store the entire key.  We call this a "restart</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">point".  The tail end of the block stores the offsets of all of the</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">restart points, and can be used to do a binary search when looking</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">for a particular key.  Values are stored as-is (without compression)</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">immediately following the corresponding key.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">An entry for a particular key-value pair has the form:</span>
<span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">shared_bytes: varint32</span>
<span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">unshared_bytes: varint32</span>
<span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">value_length: varint32</span>
<span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">key_delta: char[unshared_bytes]</span>
<span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">value: char[value_length]</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">shared_bytes == 0 for restart points.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The trailer of the block has the form:</span>
<span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">restarts: uint32[num_restarts]</span>
<span style="font-weight: bold; font-style: italic;">//     </span><span style="font-weight: bold; font-style: italic;">num_restarts: uint32</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">restarts[i] contains the offset within the block of the ith restart point.</span>
</pre>
</div>
</div>
</li>

<li><a id="org13ffea5"></a>BlockBuilder<br />
<div class="outline-text-5" id="text-10-8-6-2">
<p>
构造函数非常简单.这里options-&gt;block<sub>restrat</sub><sub>interval可能就是之前说的参数K</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span>::<span style="font-weight: bold;">BlockBuilder</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Options</span>* <span style="font-weight: bold; font-style: italic;">options</span>)
    : options_(options),
      restarts_(),
      counter_(0),
      finished_(<span style="font-weight: bold; text-decoration: underline;">false</span>) {
  assert(options-&gt;block_restart_interval &gt;= 1);
  restarts_.push_back(0);       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">First restart point is at offset 0</span>
}
</pre>
</div>
<p>
我们这里注意到0就是restarts一个点.
</p>
</div>
</li>

<li><a id="org45907fb"></a>Reset<br />
<div class="outline-text-5" id="text-10-8-6-3">
<p>
Reset和构造函数非常简单.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span>::<span style="font-weight: bold;">Reset</span>() {
  buffer_.clear();
  restarts_.clear();
  restarts_.push_back(0);       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">First restart point is at offset 0</span>
  counter_ = 0;
  finished_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  last_key_.clear();
}
</pre>
</div>
</div>
</li>

<li><a id="org4bdbd1e"></a>CurrentSizeEstimate<br />
<div class="outline-text-5" id="text-10-8-6-4">
<p>
按照PrefixCompressed里面的注释来看的话，长度应该就是按照下面的代码计算出来的
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span>::<span style="font-weight: bold;">CurrentSizeEstimate</span>() <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">return</span> (buffer_.size() +                        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Raw data buffer</span>
          restarts_.size() * <span style="font-weight: bold;">sizeof</span>(uint32_t) +   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Restart array</span>
          <span style="font-weight: bold;">sizeof</span>(uint32_t));                      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Restart array length</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org2d6d051"></a>Finish<br />
<div class="outline-text-5" id="text-10-8-6-5">
<p>
Finish的工作就是将restarts的信息全部写入到block buffer的结尾吧.同时将buffer<sub>包装称为Slice返回</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span>::<span style="font-weight: bold;">Finish</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Append restart array</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; restarts_.size(); i++) {
    PutFixed32(&amp;buffer_, restarts_[i]);
  }
  PutFixed32(&amp;buffer_, restarts_.size());
  finished_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
  <span style="font-weight: bold;">return</span> Slice(buffer_);
}
</pre>
</div>
</div>
</li>

<li><a id="orge9adc39"></a>Add<br />
<div class="outline-text-5" id="text-10-8-6-6">
<p>
我们这里仔细看看prefix-compressed是相对哪一个key来进行压缩的.阅读代码会发现是针对last<sub>key来进行的</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">BlockBuilder</span>::<span style="font-weight: bold;">Add</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">last_key_piece</span>(last_key_);
  assert(!finished_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#25105;&#20204;&#19981;&#20801;&#35768;finished.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;counter_&#26159;&#33258;restart&#30340;&#35805;&#37027;&#20040;&#20250;reset0.&#25152;&#20197;&#24212;&#35813;&#26159;&lt;=.</span>
  assert(counter_ &lt;= options_-&gt;block_restart_interval);
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26377;&#20869;&#23481;&#30340;&#35805;&#65292;&#37027;&#20040;&#36825;&#37324;&#38656;&#35201;&#39564;&#35777;key&#26159;&#21542;&#26377;&#24207;.</span>
  assert(buffer_.empty() <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No values yet?</span>
         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; 0);
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">shared</span> = 0;
  <span style="font-weight: bold;">if</span> (counter_ &lt; options_-&gt;block_restart_interval) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">See how much sharing to do with previous string</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">min_length</span> = <span style="font-weight: bold; text-decoration: underline;">std</span>::min(last_key_piece.size(), key.size());
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;prefix compress&#38024;&#23545;last_key&#26469;&#20570;&#30340;.</span>
    <span style="font-weight: bold;">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) {
      shared++;
    }
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Restart compression</span>
    restarts_.push_back(buffer_.size()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;restart&#23384;&#25918;&#30340;&#26159;&#23383;&#33410;&#20559;&#31227;&#32780;&#19981;&#26159;counter.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;&#35760;&#24405;counter&#37027;&#20040;&#22312;read&#30340;&#26102;&#20505;&#27809;&#26377;&#21150;&#27861;&#36824;&#21407;&#65292;&#22240;&#20026;kv&#37117;&#26159;&#21464;&#38271;&#30340;.</span>
    counter_ = 0;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;restart point&#30340;&#35805;&#65292;&#37027;&#20040;shared&#30340;&#37096;&#20998;&#24212;&#35813;&#26159;0.</span>
  }
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">non_shared</span> = key.size() - shared;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span>
  PutVarint32(&amp;buffer_, shared);
  PutVarint32(&amp;buffer_, non_shared);
  PutVarint32(&amp;buffer_, value.size());

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add string delta to buffer_ followed by value</span>
  buffer_.append(key.data() + shared, non_shared);
  buffer_.append(value.data(), value.size());

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Update state</span>
  last_key_.resize(shared);
  last_key_.append(key.data() + shared, non_shared);
  assert(Slice(last_key_) == key);
  counter_++;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgb05a4a3" class="outline-4">
<h4 id="orgb05a4a3"><span class="section-number-4">10.8.7</span> Block</h4>
<div class="outline-text-4" id="text-10-8-7">
<p>
table/block.h Block可以认为是BlockBuilder的Reader对象，解析BlockBuilder生成的Block.提供访问接口是遍历。
首先我们看看具体接口.可以看到解析的就是一个完整的Block对象.
</p>
<div class="org-src-container">
<pre class="src src-C+">class Block {
 public:
  // Initialize the block with the specified contents.
  // Takes ownership of data[] and will delete[] it when done.
  Block(const char* data, size_t size);

  ~Block();

  size_t size() const { return size_; }
  Iterator* NewIterator(const Comparator* comparator); // 访问接口方式是遍历.

 private:
  uint32_t NumRestarts() const;

  const char* data_;
  size_t size_;
  uint32_t restart_offset_;     // Offset in data_ of restart array
  // restart数组的偏移.每个restart都是4个字节.
  class Iter; // 内部实现.
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org6c3dc40"></a>NumRestarts<br />
<div class="outline-text-5" id="text-10-8-7-1">
<p>
从之前的BloclBuilder知道restart个数在最后面的4字节
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; text-decoration: underline;">Block</span>::<span style="font-weight: bold;">NumRestarts</span>() <span style="font-weight: bold;">const</span> {
  assert(size_ &gt;= 2*<span style="font-weight: bold;">sizeof</span>(uint32_t));
  <span style="font-weight: bold;">return</span> DecodeFixed32(data_ + size_ - <span style="font-weight: bold;">sizeof</span>(uint32_t));
}
</pre>
</div>
</div>
</li>

<li><a id="org4fb3b20"></a>Block<br />
<div class="outline-text-5" id="text-10-8-7-2">
<p>
注意这里data已经由这个Block来托管了.在析构函数里面会释放data_
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Block</span>::<span style="font-weight: bold;">Block</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">data</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>)
    : data_(data),
      size_(size) {
  <span style="font-weight: bold;">if</span> (size_ &lt; <span style="font-weight: bold;">sizeof</span>(uint32_t)) {
    size_ = 0;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Error marker</span>
  } <span style="font-weight: bold;">else</span> {
    restart_offset_ = size_ - (1 + NumRestarts()) * <span style="font-weight: bold;">sizeof</span>(uint32_t); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#26368;&#21518;&#38754;&#26377;&#19968;&#20010;uint32&#34920;&#31034;restart&#20010;&#25968;.</span>
    <span style="font-weight: bold;">if</span> (restart_offset_ &gt; size_ - <span style="font-weight: bold;">sizeof</span>(uint32_t)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;restart_offset_&#23384;&#22312;&#38382;&#39064;&#30340;&#35805;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The size is too small for NumRestarts() and therefore</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">restart_offset_ wrapped around.</span>
      size_ = 0;
    }
  }
}

<span style="font-weight: bold; text-decoration: underline;">Block</span>::~<span style="font-weight: bold;">Block</span>() {
  <span style="font-weight: bold;">delete</span>[] data_;
}
</pre>
</div>
</div>
</li>

<li><a id="org1fdf640"></a>NewIterator<br />
<div class="outline-text-5" id="text-10-8-7-3">
<p>
创建一个迭代器.采用了工厂方法创建了具体类.关于这个具体类在后面会被称为BlockIterator来进行分析.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; text-decoration: underline;">Block</span>::<span style="font-weight: bold;">NewIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">cmp</span>) {
  <span style="font-weight: bold;">if</span> (size_ &lt; 2*<span style="font-weight: bold;">sizeof</span>(uint32_t)) {
    <span style="font-weight: bold;">return</span> NewErrorIterator(<span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"bad block contents"</span>));
  }
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">num_restarts</span> = NumRestarts();
  <span style="font-weight: bold;">if</span> (num_restarts == 0) {
    <span style="font-weight: bold;">return</span> NewEmptyIterator();
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Iter</span>(cmp, data_, restart_offset_, num_restarts);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;BlockIterator.</span>
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org57805aa" class="outline-4">
<h4 id="org57805aa"><span class="section-number-4">10.8.8</span> BlockIterator</h4>
<div class="outline-text-4" id="text-10-8-8">
<p>
table/block.cc BlockIterator本身完成的功能很简单就是Block的遍历器，我们首先看看结构
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Block</span>::<span style="font-weight: bold; text-decoration: underline;">Iter</span> : <span style="font-weight: bold;">public</span> Iterator {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">comparator_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27604;&#36739;&#23545;&#35937;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">data_</span>;      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">underlying block contents</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">restarts_</span>;     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Offset of restart array (list of fixed32)</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">num_restarts_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Number of uint32_t entries in restart array</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">current_ is offset in data_ of current entry.  &gt;= restarts_ if !Valid</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">current_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#30340;data_&#20301;&#32622;.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">restart_index_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Index of restart block in which current_ falls</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">key_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;key&#38656;&#35201;&#21333;&#29420;&#20445;&#23384;,&#22240;&#20026;&#25105;&#20204;&#20351;&#29992;&#20102;prefix-compressed.</span>
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">value_</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status_</span>;
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org5a248e6"></a>BlockIterator<br />
<div class="outline-text-5" id="text-10-8-8-1">
<p>
构造函数非常简单
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">Iter</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">comparator</span>,
     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">data</span>,
     <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">restarts</span>,
     <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">num_restarts</span>)
    : comparator_(comparator),
      data_(data),
      restarts_(restarts),
      num_restarts_(num_restarts),
      current_(restarts_),
      restart_index_(num_restarts_) {
  assert(num_restarts_ &gt; 0);
}
</pre>
</div>
</div>
</li>

<li><a id="org6b7738c"></a>NextEntryOffset<br />
<div class="outline-text-5" id="text-10-8-8-2">
<p>
得到下一个entry的偏移.直接使用value<sub>的偏移和大小即可计算出来</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the offset in data_ just past the end of the current entry.</span>
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">NextEntryOffset</span>() <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">return</span> (value_.data() + value_.size()) - data_;
}
</pre>
</div>
</div>
</li>

<li><a id="org0efbab7"></a>GetRestartPoint<br />
<div class="outline-text-5" id="text-10-8-8-3">
<p>
得到某个index的restart offset.这个直接访问最后的restart可以得到.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">GetRestartPoint</span>(<span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">index</span>) {
  assert(index &lt; num_restarts_);
  <span style="font-weight: bold;">return</span> DecodeFixed32(data_ + restarts_ + index * <span style="font-weight: bold;">sizeof</span>(uint32_t));
}
</pre>
</div>
</div>
</li>

<li><a id="org31f2910"></a>SeekToRestartPoint<br />
<div class="outline-text-5" id="text-10-8-8-4">
<p>
这个接口的语义是到某个restart point.我们需要调整restart<sub>index</sub><sub>.这里value</sub><sub>为了可以调用NextEntryOffset</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToRestartPoint</span>(<span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">index</span>) {
  key_.clear();
  restart_index_ = index;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">current_ will be fixed by ParseNextKey();</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ParseNextKey() starts at the end of value_, so set value_ accordingly</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">offset</span> = GetRestartPoint(index);
  value_ = Slice(data_ + offset, 0);
}
</pre>
</div>
</div>
</li>

<li><a id="orgf1704f6"></a>Next<br />
<div class="outline-text-5" id="text-10-8-8-5">
<p>
Next底层调用了ParseNextKey.后面我们会仔细看看ParseNextKey.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Next</span>() {
  assert(Valid());
  ParseNextKey();
}
</pre>
</div>
</div>
</li>

<li><a id="orge91eeee"></a>SeekToFirst<br />
<div class="outline-text-5" id="text-10-8-8-6">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToFirst</span>() {
  SeekToRestartPoint(0); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21040;restart0.</span>
  ParseNextKey(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#35299;&#26512;&#19979;&#19968;&#20010;&#20803;&#32032;&#21363;&#21487;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org0a41be7"></a>SeekToLast<br />
<div class="outline-text-5" id="text-10-8-8-7">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToLast</span>() {
  SeekToRestartPoint(num_restarts_ - 1); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#21040;&#26368;&#21518;&#19968;&#20010;restart.</span>
  <span style="font-weight: bold;">while</span> (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; restarts_) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19968;&#30452;&#35299;&#26512;&#21040;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Keep skipping</span>
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgb3c5291"></a>ParseNextKey<br />
<div class="outline-text-5" id="text-10-8-8-8">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">ParseNextKey</span>() {
  current_ = NextEntryOffset(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#19968;&#20010;entry offset.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">p</span> = data_ + current_;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">limit</span> = data_ + restarts_;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Restarts come right after data</span>
  <span style="font-weight: bold;">if</span> (p &gt;= limit) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#21040;&#36798;&#32467;&#23614;&#30340;&#35805;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No more entries to return.  Mark as invalid.</span>
    current_ = restarts_;
    restart_index_ = num_restarts_;
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Decode next entry</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">shared</span>, <span style="font-weight: bold; font-style: italic;">non_shared</span>, <span style="font-weight: bold; font-style: italic;">value_length</span>;
  p = DecodeEntry(p, limit, &amp;shared, &amp;non_shared, &amp;value_length); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;p&#35299;&#26512;key&#20986;&#26469;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21516;&#26102;&#24212;&#35813;&#21462;&#20986;&#20102;prefix&#37096;&#20998;.</span>
  <span style="font-weight: bold;">if</span> (p == <span style="font-weight: bold; text-decoration: underline;">NULL</span> || key_.size() &lt; shared) {
    CorruptionError();
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  } <span style="font-weight: bold;">else</span> {
    key_.resize(shared);
    key_.append(p, non_shared); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21152;&#20837;&#21518;&#38754;&#30340;&#37096;&#20998;</span>
    value_ = Slice(p + non_shared, value_length);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;&#19979;&#19968;&#20010;restart point&#26159;&#21542;&gt;=current_.</span>
    <span style="font-weight: bold;">while</span> (restart_index_ + 1 &lt; num_restarts_ &amp;&amp;
           GetRestartPoint(restart_index_ + 1) &lt; current_) {
      ++restart_index_; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#38656;&#35201;&#36827;&#20837;&#19979;&#19968;&#20010;restart point.</span>
    }
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org932a018"></a>DecodeEntry<br />
<div class="outline-text-5" id="text-10-8-8-9">
<p>
从头部decode出shared,non<sub>shared以及value</sub><sub>length.这里面为了加快判断的话有一个技巧.返回的是下一个要读取的地址</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold;">inline</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">DecodeEntry</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">p</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">limit</span>,
                                      <span style="font-weight: bold; text-decoration: underline;">uint32_t</span>* <span style="font-weight: bold; font-style: italic;">shared</span>,
                                      <span style="font-weight: bold; text-decoration: underline;">uint32_t</span>* <span style="font-weight: bold; font-style: italic;">non_shared</span>,
                                      <span style="font-weight: bold; text-decoration: underline;">uint32_t</span>* <span style="font-weight: bold; font-style: italic;">value_length</span>) {
  <span style="font-weight: bold;">if</span> (limit - p &lt; 3) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  *shared = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(p)[0];
  *non_shared = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(p)[1];
  *value_length = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(p)[2];
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33267;&#23569;&#23384;&#22312;3&#20010;&#23383;&#33410;.&#20294;&#26159;&#22914;&#26524;&#20219;&#24847;3&#20010;&#23383;&#33410;&lt;128&#30340;&#35805;&#65292;&#34920;&#31034;&#27599;&#20010;&#37096;&#20998;&#37117;&#26159;1&#20010;&#23383;&#33410;.</span>
  <span style="font-weight: bold;">if</span> ((*shared | *non_shared | *value_length) &lt; 128) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fast path: all three values are encoded in one byte each</span>
    p += 3;
  } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#36825;&#20010;fast path&#30340;&#35805;&#37027;&#20040;&#20998;&#21035;&#21462;&#20986;3&#20010;&#21464;&#38271;uint32.</span>
    <span style="font-weight: bold;">if</span> ((p = GetVarint32Ptr(p, limit, shared)) == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    <span style="font-weight: bold;">if</span> ((p = GetVarint32Ptr(p, limit, non_shared)) == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    <span style="font-weight: bold;">if</span> ((p = GetVarint32Ptr(p, limit, value_length)) == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }

  <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length)) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }
  <span style="font-weight: bold;">return</span> p;
}
</pre>
</div>
</div>
</li>

<li><a id="org52a4056"></a>Prev<br />
<div class="outline-text-5" id="text-10-8-8-10">
<p>
Prev相对于Next有一点低效.首先遍历找到restart point,然后在这个restart range里面遍历.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Prev</span>() {
  assert(Valid());

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Scan backwards to a restart point before current_</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">original</span> = current_;
  <span style="font-weight: bold;">while</span> (GetRestartPoint(restart_index_) &gt;= original) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#25214;&#21040;restart range.</span>
    <span style="font-weight: bold;">if</span> (restart_index_ == 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No more entries</span>
      current_ = restarts_;
      restart_index_ = num_restarts_;
      <span style="font-weight: bold;">return</span>;
    }
    restart_index_--;
  }

  SeekToRestartPoint(restart_index_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#36339;&#21040;&#36825;&#20010;restart range.</span>
  <span style="font-weight: bold;">do</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#36825;&#20010;restart range&#37324;&#38754;&#36941;&#21382;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Loop until end of current entry hits the start of original entry</span>
  } <span style="font-weight: bold;">while</span> (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; original);
}
</pre>
</div>
</div>
</li>

<li><a id="org7861380"></a>Seek<br />
<div class="outline-text-5" id="text-10-8-8-11">
<p>
Seek非常简单，首先在restart point地方因为里面存放都是有序的完整的key.那么可以restart point
这些地方进行二分查找.然后在restart range里面通过遍历查找.还算是比较高效吧。注意这里如果没有找到的话，
返回的是第一个&gt;=target的对象.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Binary search in restart array to find the first restart point</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">with a key &gt;= target</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">left</span> = 0;
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">right</span> = num_restarts_ - 1;
  <span style="font-weight: bold;">while</span> (left &lt; right) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;restart&#36825;&#20123;&#37096;&#20998;&#20108;&#20998;&#26597;&#25214;.</span>
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">mid</span> = (left + right + 1) / 2;
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">region_offset</span> = GetRestartPoint(mid);
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">shared</span>, <span style="font-weight: bold; font-style: italic;">non_shared</span>, <span style="font-weight: bold; font-style: italic;">value_length</span>;
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">key_ptr</span> = DecodeEntry(data_ + region_offset,
                                      data_ + restarts_,
                                      &amp;shared, &amp;non_shared, &amp;value_length);
    <span style="font-weight: bold;">if</span> (key_ptr == <span style="font-weight: bold; text-decoration: underline;">NULL</span> || (shared != 0)) {
      CorruptionError();
      <span style="font-weight: bold;">return</span>;
    }
    <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">mid_key</span>(key_ptr, non_shared);
    <span style="font-weight: bold;">if</span> (Compare(mid_key, target) &lt; 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Key at "mid" is smaller than "target".  Therefore all</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">blocks before "mid" are uninteresting.</span>
      left = mid;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Key at "mid" is &gt;= "target".  Therefore all blocks at or</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">after "mid" are uninteresting.</span>
      right = mid - 1;
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Linear search (within restart block) for first key &gt;= target</span>
  SeekToRestartPoint(left); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;&#36825;&#20010;&#37096;&#20998;&#24320;&#22987;&#36941;&#21382;&#26597;&#25214;.</span>
  <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">true</span>) {
    <span style="font-weight: bold;">if</span> (!ParseNextKey()) {
      <span style="font-weight: bold;">return</span>;
    }
    <span style="font-weight: bold;">if</span> (Compare(key_, target) &gt;= 0) {
      <span style="font-weight: bold;">return</span>;
    }
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org652ba3a" class="outline-4">
<h4 id="org652ba3a"><span class="section-number-4">10.8.9</span> BlockHandle</h4>
<div class="outline-text-4" id="text-10-8-9">
<p>
table/format.h BlockHandle用于压缩和解压文件信息.包括两个字段offset和size.不是很麻烦
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">BlockHandle is a pointer to the extent of a file that stores a data</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block or a meta block.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">BlockHandle</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The offset of the block in the file.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">offset</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> offset_; }
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">set_offset</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">offset</span>) { offset_ = offset; }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The size of the stored block</span>
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">size</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> size_; }
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">set_size</span>(<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">size</span>) { size_ = size; }

  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">EncodeTo</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dst</span>) <span style="font-weight: bold;">const</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">DecodeFrom</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">input</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Maximum encoding length of a BlockHandle</span>
  <span style="font-weight: bold;">enum</span> { <span style="font-weight: bold; font-style: italic;">kMaxEncodedLength</span> = 10 + 10 }; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">uint64&#26368;&#22823;&#21387;&#32553;&#22823;&#23567;&#20026;10&#23383;&#33410;.</span>

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">offset_</span>;
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">size_</span>;
};
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>::<span style="font-weight: bold;">BlockHandle</span>()
    : offset_(~<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt;(0)), <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#20540;&#38750;&#24120;&#22823;.</span>
      size_(~<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt;(0)) {
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orged0e6e0"></a>EncodeTo<br />
<div class="outline-text-5" id="text-10-8-9-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>::<span style="font-weight: bold;">EncodeTo</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dst</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Sanity check that all fields have been set</span>
  assert(offset_ != ~<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt;(0));
  assert(size_ != ~<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt;(0));
  PutVarint64(dst, offset_);
  PutVarint64(dst, size_);
}
</pre>
</div>
</div>
</li>

<li><a id="org21d4608"></a>DecodeFrom<br />
<div class="outline-text-5" id="text-10-8-9-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>::<span style="font-weight: bold;">DecodeFrom</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">input</span>) {
  <span style="font-weight: bold;">if</span> (GetVarint64(input, &amp;offset_) &amp;&amp;
      GetVarint64(input, &amp;size_)) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"bad block handle"</span>);
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org075757a" class="outline-4">
<h4 id="org075757a"><span class="section-number-4">10.8.10</span> Footer</h4>
<div class="outline-text-4" id="text-10-8-10">
<p>
db/format.h Footer里面打包称为定长信息.从注释上说保存在各个table文件末尾.现在还不知道具体有什么用途.
(但是阅读完TableFormat这节之后应该知道这两个字段的含义).前面两个BlockHandle使用变长打包但是空出了MaxEncodedLength.
最后8个字节使用
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kTableMagicNumber was picked by running</span>
<span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">echo http://code.google.com/p/leveldb/ | sha1sum</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and taking the leading 64 bits.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">kTableMagicNumber</span> = 0xdb4775248b80fb57ull;
</pre>
</div>
<p>
使用这个魔术数字比较有意思。我们来看看大致的结构.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Footer encapsulates the fixed information stored at the tail</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">end of every table file.</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Footer</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">Footer</span>() { }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The block handle for the metaindex block of the table</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>&amp; <span style="font-weight: bold;">metaindex_handle</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> metaindex_handle_; }
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">set_metaindex_handle</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>&amp; <span style="font-weight: bold; font-style: italic;">h</span>) { metaindex_handle_ = h; }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The block handle for the index block of the table</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>&amp; <span style="font-weight: bold;">index_handle</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> index_handle_;
  }
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">set_index_handle</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>&amp; <span style="font-weight: bold; font-style: italic;">h</span>) {
    index_handle_ = h;
  }

  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">EncodeTo</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dst</span>) <span style="font-weight: bold;">const</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">DecodeFrom</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">input</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Encoded length of a Footer.  Note that the serialization of a</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Footer will always occupy exactly this many bytes.  It consists</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of two block handles and a magic number.</span>
  <span style="font-weight: bold;">enum</span> {
    <span style="font-weight: bold; font-style: italic;">kEncodedLength</span> = 2*<span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>::kMaxEncodedLength + 8 <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22266;&#23450;&#38271;&#24230;.</span>
  };

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span> <span style="font-weight: bold; font-style: italic;">metaindex_handle_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">metaindex handle.</span>
  <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span> <span style="font-weight: bold; font-style: italic;">index_handle_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">index handle.</span>
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org0bfaaba"></a>EncodeTo<br />
<div class="outline-text-5" id="text-10-8-10-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Footer</span>::<span style="font-weight: bold;">EncodeTo</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dst</span>) <span style="font-weight: bold;">const</span> {
<span style="font-weight: bold;">#if</span><span style="font-weight: bold;">n</span><span style="font-weight: bold;">def</span> NDEBUG
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">original_size</span> = dst-&gt;size();
<span style="font-weight: bold;">#endif</span>
  metaindex_handle_.EncodeTo(dst);
  index_handle_.EncodeTo(dst);
  dst-&gt;resize(2 * <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>::kMaxEncodedLength);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Padding</span>
  PutFixed32(dst, <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint32_t</span>&gt;(kTableMagicNumber &amp; 0xffffffffu));
  PutFixed32(dst, <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint32_t</span>&gt;(kTableMagicNumber &gt;&gt; 32));
  assert(dst-&gt;size() == original_size + kEncodedLength);
}
</pre>
</div>
</div>
</li>

<li><a id="org2384d40"></a>DecodeFrom<br />
<div class="outline-text-5" id="text-10-8-10-2">
<p>
这里input作为输入，头部是EncodeTo的内容后面可能带有其他数据。解析完成之后将剩余返回给input.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; text-decoration: underline;">Footer</span>::<span style="font-weight: bold;">DecodeFrom</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">input</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">magic_ptr</span> = input-&gt;data() + kEncodedLength - 8;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">magic_lo</span> = DecodeFixed32(magic_ptr);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">magic_hi</span> = DecodeFixed32(magic_ptr + 4);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">magic</span> = ((<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt;(magic_hi) &lt;&lt; 32) |
                          (<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt;(magic_lo)));
  <span style="font-weight: bold;">if</span> (magic != kTableMagicNumber) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::InvalidArgument(<span style="font-style: italic;">"not an sstable (bad magic number)"</span>);
  }

  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">result</span> = metaindex_handle_.DecodeFrom(input);
  <span style="font-weight: bold;">if</span> (result.ok()) {
    result = index_handle_.DecodeFrom(input);
  }
  <span style="font-weight: bold;">if</span> (result.ok()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We skip over any leftover data (just padding for now) in "input"</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">end</span> = magic_ptr + 8;
    *input = Slice(end, input-&gt;data() + input-&gt;size() - end);
  }
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgf8918cf" class="outline-4">
<h4 id="orgf8918cf"><span class="section-number-4">10.8.11</span> ReadBlock</h4>
<div class="outline-text-4" id="text-10-8-11">
<p>
table/format.cc ReadBlock应该是从随机文件里面读取Block出来.对于这个Block的位置的话由handle提供.
注意每个Block后面还有crc和type.这个可以参考TableBuilder实现。然后将读取的Block二进制构造Block对象返回。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">1-byte type + 32-bit crc</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">type&#34920;&#31034;&#20351;&#29992;&#20160;&#20040;&#21387;&#32553;&#26041;&#24335;.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">kBlockTrailerSize</span> = 5;
</pre>
</div>

<p>
下面看看具体实现代码
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">ReadBlock</span>(<span style="font-weight: bold; text-decoration: underline;">RandomAccessFile</span>* <span style="font-weight: bold; font-style: italic;">file</span>,
                 <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
                 <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">BlockHandle</span>&amp; <span style="font-weight: bold; font-style: italic;">handle</span>,
                 <span style="font-weight: bold; text-decoration: underline;">Block</span>** <span style="font-weight: bold; font-style: italic;">block</span>) {
  *block = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read the block contents as well as the type/crc footer.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">See table_builder.cc for the code that built this structure.</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span> = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">size_t</span>&gt;(handle.size());
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">buf</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[n + kBlockTrailerSize];
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">contents</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">s</span> = file-&gt;Read(handle.offset(), n + kBlockTrailerSize, &amp;contents, buf);
  <span style="font-weight: bold;">if</span> (!s.ok()) {
    <span style="font-weight: bold;">delete</span>[] buf;
    <span style="font-weight: bold;">return</span> s;
  }
  <span style="font-weight: bold;">if</span> (contents.size() != n + kBlockTrailerSize) {
    <span style="font-weight: bold;">delete</span>[] buf;
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"truncated block read"</span>);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26657;&#39564;CRC32C</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Check the crc of the type and the block contents</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">data</span> = contents.data();    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Pointer to where Read put the data</span>
  <span style="font-weight: bold;">if</span> (options.verify_checksums) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">crc</span> = <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Unmask(DecodeFixed32(data + n + 1));
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">actual</span> = <span style="font-weight: bold; text-decoration: underline;">crc32c</span>::Value(data, n + 1);
    <span style="font-weight: bold;">if</span> (actual != crc) {
      <span style="font-weight: bold;">delete</span>[] buf;
      s = <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"block checksum mismatch"</span>);
      <span style="font-weight: bold;">return</span> s;
    }
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26681;&#25454;type&#21028;&#26029;&#20351;&#29992;&#20160;&#20040;&#21387;&#32553;&#26041;&#24335;.</span>
  <span style="font-weight: bold;">switch</span> (data[n]) {
    <span style="font-weight: bold;">case</span> kNoCompression:
      <span style="font-weight: bold;">if</span> (data != buf) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">File implementation gave us pointer to some other data.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Copy into buf[].</span>
        memcpy(buf, data, n + kBlockTrailerSize);
      }

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Ok</span>
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold;">case</span> kSnappyCompression: {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">... // &#36825;&#37324;&#25105;&#25925;&#24847;&#30465;&#21435;&#20102;.&#25105;&#20204;&#36825;&#37324;&#26242;&#26102;&#19981;&#20851;&#31995;&#36825;&#20010;&#36923;&#36753;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20351;&#29992;Snappy&#26469;&#35299;&#21387;&#32553;.</span>
      <span style="font-weight: bold;">break</span>;
    }
    <span style="font-weight: bold;">default</span>:
      <span style="font-weight: bold;">delete</span>[] buf;
      <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::Corruption(<span style="font-style: italic;">"bad block type"</span>);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36820;&#22238;Block&#23545;&#35937;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Block&#23545;&#35937;&#21487;&#20197;&#36890;&#36807;&#36845;&#20195;&#22120;&#26469;&#36827;&#34892;&#35775;&#38382;.</span>
  *block = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Block</span>(buf, n);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Block takes ownership of buf[]</span>
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>::OK();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfeeea7a" class="outline-4">
<h4 id="orgfeeea7a"><span class="section-number-4">10.8.12</span> IteratorWrapper</h4>
<div class="outline-text-4" id="text-10-8-12">
<p>
table/iterator<sub>wrapper.h</sub> IteratorWrapper就是Iterator的装饰者。对于Valid,Key进行了缓存.
这个其实还是比较有必要的.因为有些iterator取key和valid代价比较大.不过似乎对于虚函数没有节省开销，
因为内部存放的还是Iterator对象而不是模板。阅读完了TwoLevelIterator就会发现，这个类存在原因，
主要是为了管理Iterator对象的管理。比如Set的时候会将原来的Iterator对象释放，析构函数会将持有的Iterator释放。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A internal wrapper class with an interface similar to Iterator that</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">caches the valid() and key() results for an underlying iterator.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This can help avoid virtual function calls and also gives better</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">cache locality.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge382ed4" class="outline-4">
<h4 id="orge382ed4"><span class="section-number-4">10.8.13</span> EmptyIterator</h4>
<div class="outline-text-4" id="text-10-8-13">
<p>
EmptyIterator用来构造返回错误或者是空的Iterator.提供了两个函数
</p>
<ul class="org-ul">
<li>NewEmptyIterator</li>
<li>NewErrorIterator</li>
</ul>
<p>
来进行构造。具体实现放在了table/iterator.cc里面
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">EmptyIterator</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">EmptyIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Status</span>&amp; <span style="font-weight: bold; font-style: italic;">s</span>) : status_(s) { }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Valid</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>; }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) { }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToFirst</span>() { }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToLast</span>() { }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Next</span>() { assert(<span style="font-weight: bold; text-decoration: underline;">false</span>); }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Prev</span>() { assert(<span style="font-weight: bold; text-decoration: underline;">false</span>); }
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">key</span>() <span style="font-weight: bold;">const</span> { assert(<span style="font-weight: bold; text-decoration: underline;">false</span>); <span style="font-weight: bold;">return</span> Slice(); }
  <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">value</span>() <span style="font-weight: bold;">const</span> { assert(<span style="font-weight: bold; text-decoration: underline;">false</span>); <span style="font-weight: bold;">return</span> Slice(); }
  <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold;">status</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> status_; }
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org8101eed" class="outline-4">
<h4 id="org8101eed"><span class="section-number-4">10.8.14</span> TwoLevelIterator</h4>
<div class="outline-text-4" id="text-10-8-14">
<p>
table/two<sub>level</sub><sub>iterator.h</sub> TwoLevelIterator是一个二级Iterator配合sstable二级索引文件使用的。
通过工厂方法来进行构造所以接口非常简单。主要还是看TwoLevelIterator里面的实现。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a new two level iterator.  A two-level iterator contains an</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">index iterator whose values point to a sequence of blocks where</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">each block is itself a sequence of key,value pairs.  The returned</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">two-level iterator yields the concatenation of all key/value pairs</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">in the sequence of blocks.  Takes ownership of "index_iter" and</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">will delete it when no longer needed.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Uses a supplied function to convert an index_iter value into</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">an iterator over the contents of the corresponding block.</span>
<span style="font-weight: bold;">extern</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewTwoLevelIterator</span>(
    <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">index_iter</span>, <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">index block iterator.</span>
    <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* (*<span style="font-weight: bold;">block_function</span>)(
        <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>,
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>,
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">index_value</span>),
    <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>);
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org98c76a2"></a>NewTwoLevelIterator<br />
<div class="outline-text-5" id="text-10-8-14-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewTwoLevelIterator</span>(
    <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">index_iter</span>,
    <span style="font-weight: bold; text-decoration: underline;">BlockFunction</span> <span style="font-weight: bold; font-style: italic;">block_function</span>,
    <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38750;&#24120;&#31616;&#21333;&#23601;&#26159;&#21019;&#24314;&#23545;&#35937;.</span>
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>(index_iter, block_function, arg, options);
}
</pre>
</div>

<p>
然后我们看看TwoLevelIterator的结构以及构造函数实现。接下来我们看看几个主要的接口。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* (*<span style="font-weight: bold; text-decoration: underline;">BlockFunction</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>*, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp;, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp;);

<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>: <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">BlockFunction</span> <span style="font-weight: bold; font-style: italic;">block_function_</span>;
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg_</span>;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span> <span style="font-weight: bold; font-style: italic;">options_</span>;
  <span style="font-weight: bold; text-decoration: underline;">Status</span> <span style="font-weight: bold; font-style: italic;">status_</span>;
  <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span> <span style="font-weight: bold; font-style: italic;">index_iter_</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;key,value&#36825;&#26679;&#30340;&#26041;&#27861;&#30452;&#25509;&#32473;data_iter_&#20195;&#29702;&#21363;&#21487;.</span>
  <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span> <span style="font-weight: bold; font-style: italic;">data_iter_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">May be NULL</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If data_iter_ is non-NULL, then "data_block_handle_" holds the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">"index_value" passed to block_function_ to create the data_iter_.</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">data_block_handle_</span>;
};

<span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">TwoLevelIterator</span>(
    <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">index_iter</span>,
    <span style="font-weight: bold; text-decoration: underline;">BlockFunction</span> <span style="font-weight: bold; font-style: italic;">block_function</span>,
    <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>,
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">ReadOptions</span>&amp; <span style="font-weight: bold; font-style: italic;">options</span>)
    : block_function_(block_function),
      arg_(arg),
      options_(options),
      index_iter_(index_iter),
      data_iter_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
}
</pre>
</div>
</div>
</li>

<li><a id="org2099c02"></a>Seek<br />
<div class="outline-text-5" id="text-10-8-14-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) {
  index_iter_.Seek(target); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#36890;&#36807;index iter&#36827;&#34892;&#23450;&#20301;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#21487;&#33021;&#27809;&#26377;&#25214;&#21040;&#12290;BlockIterator::Seek&#34892;&#20026;&#26159;&#25214;&#21040;&gt;=target&#23545;&#35937;.</span>
  InitDataBlock(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#21270;data_iter.</span>
  <span style="font-weight: bold;">if</span> (data_iter_.iter() != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) data_iter_.Seek(target); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20351;&#29992;data_iter&#23450;&#20301;.</span>
  SkipEmptyDataBlocksForward(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21521;&#21069;&#30053;&#36807;&#31354;&#30333;&#35760;&#24405;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgcce3863"></a>SeekToFirst<br />
<div class="outline-text-5" id="text-10-8-14-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">SeekToFirst</span>() {
  index_iter_.SeekToFirst(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;index inter.</span>
  InitDataBlock();
  <span style="font-weight: bold;">if</span> (data_iter_.iter() != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) data_iter_.SeekToFirst(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;data iter.</span>
  SkipEmptyDataBlocksForward(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21521;&#21069;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgb37155f"></a>SeekToLast<br />
<div class="outline-text-5" id="text-10-8-14-4">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">SeekToLast</span>() {
  index_iter_.SeekToLast(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;index iter.</span>
  InitDataBlock();
  <span style="font-weight: bold;">if</span> (data_iter_.iter() != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) data_iter_.SeekToLast(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;data iter.</span>
  SkipEmptyDataBlocksBackward(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21521;&#21518;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgfe19653"></a>Next<br />
<div class="outline-text-5" id="text-10-8-14-5">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">Next</span>() {
  assert(Valid());
  data_iter_.Next();
  SkipEmptyDataBlocksForward(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21521;&#21069;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.&#36825;&#20010;&#37096;&#20998;&#21487;&#33021;&#38656;&#35201;&#32771;&#34385;data_iter_&#22833;&#25928;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgec0ac85"></a>Prev<br />
<div class="outline-text-5" id="text-10-8-14-6">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">Prev</span>() {
  assert(Valid());
  data_iter_.Prev();
  SkipEmptyDataBlocksBackward(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21521;&#21518;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.&#36825;&#20010;&#37096;&#20998;&#21487;&#33021;&#38656;&#35201;&#32771;&#34385;data_iter_&#22833;&#25928;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org5fad044"></a>InitDataBlock<br />
<div class="outline-text-5" id="text-10-8-14-7">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">InitDataBlock</span>() {
  <span style="font-weight: bold;">if</span> (!index_iter_.Valid()) {
    SetDataIterator(<span style="font-weight: bold; text-decoration: underline;">NULL</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;index_iter&#24050;&#32463;&#22833;&#25928;&#30340;&#35805;.</span>
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold; font-style: italic;">handle</span> = index_iter_.value();
    <span style="font-weight: bold;">if</span> (data_iter_.iter() != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; handle.compare(data_block_handle_) == 0) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">data_iter_ is already constructed with this iterator, so</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">no need to change anything</span>
    } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992;block_function&#26469;&#35835;&#21462;&#20855;&#20307;&#30340;data block.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#21487;&#20197;&#30475;&#21040;,block_function&#30340;&#29992;&#36884;&#23601;&#26159;&#35835;&#21462;handle</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20854;&#20013;handle&#37324;&#38754;&#26159;&#23545;&#24212;data block&#25152;&#22312;&#30340;&#20301;&#32622;&#12290;</span>
      <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">iter</span> = (*block_function_)(arg_, options_, handle);
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;data block handle.:).</span>
      data_block_handle_.assign(handle.data(), handle.size());
      SetDataIterator(iter);
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgf54d0f3"></a>SetDataIterator<br />
<div class="outline-text-5" id="text-10-8-14-8">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">SetDataIterator</span>(<span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">data_iter</span>) {
  <span style="font-weight: bold;">if</span> (data_iter_.iter() != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) SaveError(data_iter_.status());
  data_iter_.Set(data_iter); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;IteratorWrapper&#36827;&#34892;Set&#30340;&#35805;&#21407;&#26469;&#20250;&#37322;&#25918;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20063;&#35299;&#37322;&#20102;&#20026;&#20160;&#20040;&#25105;&#20204;&#38656;&#35201;IteratorWrapper&#23545;&#35937;&#23384;&#22312;.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org22d2227"></a>SkipEmptyDataBlocksForward<br />
<div class="outline-text-5" id="text-10-8-14-9">
<p>
对于空的DataBlock的话那么!data<sub>iter</sub><sub>.Valid</sub>().对于空的DataBlock可以跳过IndexBlock快速跨越。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">SkipEmptyDataBlocksForward</span>() {
  <span style="font-weight: bold;">while</span> (data_iter_.iter() == <span style="font-weight: bold; text-decoration: underline;">NULL</span> || !data_iter_.Valid()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Move to next block</span>
    <span style="font-weight: bold;">if</span> (!index_iter_.Valid()) {
      SetDataIterator(<span style="font-weight: bold; text-decoration: underline;">NULL</span>);
      <span style="font-weight: bold;">return</span>;
    }
    index_iter_.Next();
    InitDataBlock();
    <span style="font-weight: bold;">if</span> (data_iter_.iter() != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) data_iter_.SeekToFirst();
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgd1f912a"></a>SkipEmptyDataBlocksBackward<br />
<div class="outline-text-5" id="text-10-8-14-10">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TwoLevelIterator</span>::<span style="font-weight: bold;">SkipEmptyDataBlocksBackward</span>() {
  <span style="font-weight: bold;">while</span> (data_iter_.iter() == <span style="font-weight: bold; text-decoration: underline;">NULL</span> || !data_iter_.Valid()) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Move to next block</span>
    <span style="font-weight: bold;">if</span> (!index_iter_.Valid()) {
      SetDataIterator(<span style="font-weight: bold; text-decoration: underline;">NULL</span>);
      <span style="font-weight: bold;">return</span>;
    }
    index_iter_.Prev();
    InitDataBlock();
    <span style="font-weight: bold;">if</span> (data_iter_.iter() != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) data_iter_.SeekToLast();
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org8cf7a1f" class="outline-4">
<h4 id="org8cf7a1f"><span class="section-number-4">10.8.15</span> MergingIterator</h4>
<div class="outline-text-4" id="text-10-8-15">
<p>
table/merger.cc 可以认为这个是一个Iterator的多路归并实现。但是巧妙的是将多路Iterator
归并称为一个Iterator进行遍历。从注释上面可以看到对于key不会进行去重。依然是一个工厂方法。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return an iterator that provided the union of the data in</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">children[0,n-1].  Takes ownership of the child iterators and</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">will delete them when the result iterator is deleted.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The result does no duplicate suppression.  I.e., if a particular</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">key is present in K child iterators, it will be yielded K times.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: n &gt;= 0</span>
<span style="font-weight: bold;">extern</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewMergingIterator</span>(
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">comparator</span>, <span style="font-weight: bold; text-decoration: underline;">Iterator</span>** <span style="font-weight: bold; font-style: italic;">children</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>);
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgedc898f"></a>NewMergingIterator<br />
<div class="outline-text-5" id="text-10-8-15-1">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#25105;&#20204;&#38656;&#35201;&#25176;&#31649;list&#37324;&#38754;&#30340;Iterator&#23545;&#35937;.</span>
<span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold;">NewMergingIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">cmp</span>, <span style="font-weight: bold; text-decoration: underline;">Iterator</span>** <span style="font-weight: bold; font-style: italic;">list</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  assert(n &gt;= 0);
  <span style="font-weight: bold;">if</span> (n == 0) {
    <span style="font-weight: bold;">return</span> NewEmptyIterator(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;n==0&#37027;&#20040;&#26159;empty iterator.</span>
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (n == 1) {
    <span style="font-weight: bold;">return</span> list[0]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;n==1&#30340;&#35805;&#37027;&#20040;&#21482;&#38656;&#35201;&#36820;&#22238;&#31532;&#19968;&#20010;&#21363;&#21487;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#24182;&#27809;&#26377;&#38382;&#39064;&#22240;&#20026;&#25105;&#20204;&#26368;&#21518;&#20250;&#30452;&#25509;delete&#36825;&#20010;&#23545;&#35937;&#30340;&#12290;</span>
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">MergingIterator</span>(cmp, list, n); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#23601;&#38656;&#35201;&#36827;&#34892;&#21512;&#24182;.</span>
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org40b871a"></a>MergingIterator<br />
<div class="outline-text-5" id="text-10-8-15-2">
<p>
首先看看结构以及构造和析构函数.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MergingIterator</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">MergingIterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">comparator</span>, <span style="font-weight: bold; text-decoration: underline;">Iterator</span>** <span style="font-weight: bold; font-style: italic;">children</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>)
      : comparator_(comparator),
        children_(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span>[n]),
        n_(n),
        current_(<span style="font-weight: bold; text-decoration: underline;">NULL</span>),
        direction_(kForward) {
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++) {
      children_[i].Set(children[i]);
    }
  }

  <span style="font-weight: bold;">virtual</span> ~<span style="font-weight: bold;">MergingIterator</span>() {
    <span style="font-weight: bold;">delete</span>[] children_;
  }

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We might want to use a heap in case there are lots of children.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For now we use a simple array since we expect a very small number</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">of children in leveldb.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>* <span style="font-weight: bold; font-style: italic;">comparator_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27604;&#36739;&#22120;.</span>
  <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span>* <span style="font-weight: bold; font-style: italic;">children_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22810;&#36335;Iterator.</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22810;&#23569;&#36335;.</span>
  <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span>* <span style="font-weight: bold; font-style: italic;">current_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;Iterator.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Which direction is the iterator moving?</span>
  <span style="font-weight: bold;">enum</span> <span style="font-weight: bold; text-decoration: underline;">Direction</span> {
    <span style="font-weight: bold; font-style: italic;">kForward</span>,
    <span style="font-weight: bold; font-style: italic;">kReverse</span>
  };
  <span style="font-weight: bold; text-decoration: underline;">Direction</span> <span style="font-weight: bold; font-style: italic;">direction_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26041;&#21521;.</span>
};
</pre>
</div>
</div>
</li>

<li><a id="org8b3b25a"></a>Key<br />
<div class="outline-text-5" id="text-10-8-15-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">key</span>() <span style="font-weight: bold;">const</span> {
  assert(Valid());
  <span style="font-weight: bold;">return</span> current_-&gt;key();
}
</pre>
</div>
</div>
</li>

<li><a id="orgcde63ba"></a>Value<br />
<div class="outline-text-5" id="text-10-8-15-4">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span> <span style="font-weight: bold;">value</span>() <span style="font-weight: bold;">const</span> {
  assert(Valid());
  <span style="font-weight: bold;">return</span> current_-&gt;value();
}
</pre>
</div>
</div>
</li>

<li><a id="org8d555ec"></a>Seek<br />
<div class="outline-text-5" id="text-10-8-15-5">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n_; i++) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010;children&#37117;seek&#21040;&#36825;&#20010;target.</span>
    children_[i].Seek(target);
  }
  FindSmallest(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23545;&#27604;&#19968;&#19979;&#26368;&#23567;&#30340;&#23545;&#35937;.&#35774;&#32622;&#20026;current.</span>
  direction_ = kForward; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;&#19968;&#19979;&#26041;&#21521;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;Key,Value&#30340;&#35805;&#35843;&#29992;current&#36825;&#20010;Iterator.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="orgb2f14fe"></a>SeekToFirst<br />
<div class="outline-text-5" id="text-10-8-15-6">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToFirst</span>() {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n_; i++) {
    children_[i].SeekToFirst();
  }
  FindSmallest();
  direction_ = kForward;
}
</pre>
</div>
</div>
</li>

<li><a id="orgaa439e9"></a>SeekToLast<br />
<div class="outline-text-5" id="text-10-8-15-7">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToLast</span>() {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n_; i++) {
    children_[i].SeekToLast();
  }
  FindLargest(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25214;&#21040;&#26368;&#22823;&#30340;&#20316;&#20026;current_.</span>
  direction_ = kReverse;
}
</pre>
</div>
</div>
</li>

<li><a id="org17eb1b7"></a>Next<br />
<div class="outline-text-5" id="text-10-8-15-8">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Next</span>() {
  assert(Valid());

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19981;&#26159;&#27491;&#26041;&#21521;&#30340;&#35805;.&#19981;&#36807;&#35273;&#24471;&#36825;&#20010;&#37096;&#20998;&#20195;&#30721;&#21487;&#33021;&#23384;&#22312;&#38382;&#39064;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#36807;&#20063;&#27809;&#26377;&#26356;&#22909;&#30340;&#35299;&#20915;&#21150;&#27861;&#20102;&#12290;&#25105;&#35273;&#24471;&#36825;&#37324;&#30452;&#25509;assert&#23601;&#22909;&#20102;&#65292;&#19981;&#38656;&#35201;&#35843;&#25972;&#12290;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Ensure that all children are positioned after key().</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we are moving in the forward direction, it is already</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">true for all of the non-current_ children since current_ is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the smallest child and key() == current_-&gt;key().  Otherwise,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we explicitly position the non-current_ children.</span>
  <span style="font-weight: bold;">if</span> (direction_ != kForward) {
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n_; i++) {
      <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span>* <span style="font-weight: bold; font-style: italic;">child</span> = &amp;children_[i];
      <span style="font-weight: bold;">if</span> (child != current_) {
        child-&gt;Seek(key());
        <span style="font-weight: bold;">if</span> (child-&gt;Valid() &amp;&amp;
            comparator_-&gt;Compare(key(), child-&gt;key()) == 0) {
          child-&gt;Next();
        }
      }
    }
    direction_ = kForward;
  }
  current_-&gt;Next();
  FindSmallest();
}
</pre>
</div>
</div>
</li>

<li><a id="orgf2a735e"></a>Prev<br />
<div class="outline-text-5" id="text-10-8-15-9">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Prev</span>() {
  assert(Valid());

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19981;&#26159;&#21453;&#26041;&#21521;&#30340;&#35805;.&#19981;&#36807;&#35273;&#24471;&#36825;&#20010;&#37096;&#20998;&#20195;&#30721;&#21487;&#33021;&#23384;&#22312;&#38382;&#39064;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#36807;&#20063;&#27809;&#26377;&#26356;&#22909;&#30340;&#35299;&#20915;&#21150;&#27861;&#20102;&#12290;&#25105;&#35273;&#24471;&#36825;&#37324;&#30452;&#25509;assert&#23601;&#22909;&#20102;&#65292;&#26681;&#26412;&#19981;&#38656;&#35201;&#35843;&#25972;&#12290;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Ensure that all children are positioned before key().</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we are moving in the reverse direction, it is already</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">true for all of the non-current_ children since current_ is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the largest child and key() == current_-&gt;key().  Otherwise,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we explicitly position the non-current_ children.</span>
  <span style="font-weight: bold;">if</span> (direction_ != kReverse) {
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n_; i++) {
      <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span>* <span style="font-weight: bold; font-style: italic;">child</span> = &amp;children_[i];
      <span style="font-weight: bold;">if</span> (child != current_) {
        child-&gt;Seek(key());
        <span style="font-weight: bold;">if</span> (child-&gt;Valid()) {
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Child is at first entry &gt;= key().  Step back one to be &lt; key()</span>
          child-&gt;Prev();
        } <span style="font-weight: bold;">else</span> {
          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Child has no entries &gt;= key().  Position at last entry.</span>
          child-&gt;SeekToLast();
        }
      }
    }
    direction_ = kReverse;
  }

  current_-&gt;Prev();
  FindLargest();
}
</pre>
</div>
</div>
</li>

<li><a id="org1fb465f"></a>FindSmallest<br />
<div class="outline-text-5" id="text-10-8-15-10">
<p>
从这些Iterator找到最小的Iterator作为current.算法naive.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">MergingIterator</span>::<span style="font-weight: bold;">FindSmallest</span>() {
  <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span>* <span style="font-weight: bold; font-style: italic;">smallest</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n_; i++) {
    <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span>* <span style="font-weight: bold; font-style: italic;">child</span> = &amp;children_[i];
    <span style="font-weight: bold;">if</span> (child-&gt;Valid()) {
      <span style="font-weight: bold;">if</span> (smallest == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
        smallest = child;
      } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (comparator_-&gt;Compare(child-&gt;key(), smallest-&gt;key()) &lt; 0) {
        smallest = child;
      }
    }
  }
  current_ = smallest;
}
</pre>
</div>
</div>
</li>

<li><a id="orgd479943"></a>FindLargest<br />
<div class="outline-text-5" id="text-10-8-15-11">
<p>
从这些Iterator里面找到最大的Iterator作为current.算法naive.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">MergingIterator</span>::<span style="font-weight: bold;">FindLargest</span>() {
  <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span>* <span style="font-weight: bold; font-style: italic;">largest</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = n_-1; i &gt;= 0; i--) {
    <span style="font-weight: bold; text-decoration: underline;">IteratorWrapper</span>* <span style="font-weight: bold; font-style: italic;">child</span> = &amp;children_[i];
    <span style="font-weight: bold;">if</span> (child-&gt;Valid()) {
      <span style="font-weight: bold;">if</span> (largest == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
        largest = child;
      } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (comparator_-&gt;Compare(child-&gt;key(), largest-&gt;key()) &gt; 0) {
        largest = child;
      }
    }
  }
  current_ = largest;
}
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgabeacab" class="outline-3">
<h3 id="orgabeacab"><span class="section-number-3">10.9</span> Util</h3>
<div class="outline-text-3" id="text-10-9">
</div>
<div id="outline-container-org5bfde69" class="outline-4">
<h4 id="org5bfde69"><span class="section-number-4">10.9.1</span> Arena</h4>
<div class="outline-text-4" id="text-10-9-1">
<p>
util/arena.h[.cc] arena作为一个局部,对于逻辑来说存在生命周期的内存分配器.所有的内存都在这上面分配然后一次性释放.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Arena</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">Arena</span>();
  ~<span style="font-weight: bold;">Arena</span>();

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a pointer to a newly allocated memory block of "bytes" bytes.</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">Allocate</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Allocate memory with the normal alignment guarantees provided by malloc</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">AllocateAligned</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns an estimate of the total memory usage of data allocated</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">by the arena (including space allocated but not yet used for user</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">allocations).</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">MemoryUsage</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#20998;&#37197;&#20869;&#23384;&#20197;&#21450;std::vector&#20998;&#37197;&#20869;&#23384;.</span>
    <span style="font-weight: bold;">return</span> blocks_memory_ + blocks_.capacity() * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">char</span>*);
  }

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">AllocateFallback</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#24403;&#21069;&#30340;block&#19981;&#22815;&#20998;&#37197;&#30340;&#35805;&#65292;&#37027;&#20040;&#38656;&#35201;new&#19968;&#20010;&#26032;&#30340;block.</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold;">AllocateNewBlock</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">block_bytes</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">new&#26032;&#30340;block&#36923;&#36753;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Allocation state</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">alloc_ptr_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#20801;&#35768;&#20998;&#37197;&#30340;ptr</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">alloc_bytes_remaining_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#36824;&#26377;&#36830;&#32493;&#20869;&#23384;&#22320;&#22336;&#36824;&#26377;&#22810;&#23569;&#27809;&#26377;&#20998;&#37197;&#25481;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Array of new[] allocated memory blocks</span>
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>*&gt; <span style="font-weight: bold; font-style: italic;">blocks_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#29616;&#22312;&#20998;&#37197;&#20102;&#22810;&#23569;&#36830;&#32493;&#20869;&#23384;&#22320;&#22336;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Bytes of memory in blocks allocated so far</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">blocks_memory_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#20998;&#37197;&#20102;&#22810;&#23569;&#20869;&#23384;.</span>
};
</pre>
</div>
<p>
阅读完了这个接口基本上就能够猜想到怎么实现了.都是基于sample方式的内存分配,每次分配固定大小的block
然后在上面不断地进行切分。但是这里必须确保block内存大小足够大，不然不能够正常分配内存.
(#note: 不过阅读了后面实现，发现如果超过block的话按照本身大小分配，不会存在问题).
</p>

<p>
还是稍微看看实现吧
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; text-decoration: underline;">Arena</span>::<span style="font-weight: bold;">Allocate</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The semantics of what to return are a bit messy if we allow</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0-byte allocations, so we disallow them here (we don't need</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">them for our internal use).</span>
  assert(bytes &gt; 0);
  <span style="font-weight: bold;">if</span> (bytes &lt;= alloc_bytes_remaining_) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26597;&#30475;&#24403;&#21069;&#26159;&#21542;&#21487;&#20197;&#20998;&#37197;.</span>
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">result</span> = alloc_ptr_;
    alloc_ptr_ += bytes;
    alloc_bytes_remaining_ -= bytes;
    <span style="font-weight: bold;">return</span> result;
  }
  <span style="font-weight: bold;">return</span> AllocateFallback(bytes);
}

<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kBlockSize</span> = 4096; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">block size&#26159;4K.</span>

<span style="font-weight: bold; text-decoration: underline;">Arena</span>::<span style="font-weight: bold;">Arena</span>() {
  blocks_memory_ = 0;
  alloc_ptr_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">First allocation will allocate a block</span>
  alloc_bytes_remaining_ = 0;
}

<span style="font-weight: bold; text-decoration: underline;">Arena</span>::~<span style="font-weight: bold;">Arena</span>() {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; blocks_.size(); i++) {
    <span style="font-weight: bold;">delete</span>[] blocks_[i];
  }
}

<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; text-decoration: underline;">Arena</span>::<span style="font-weight: bold;">AllocateFallback</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>) {
  <span style="font-weight: bold;">if</span> (bytes &gt; kBlockSize / 4) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#20998;&#37197;&#36229;&#36807;1K.&#37027;&#20040;&#30452;&#25509;&#20998;&#37197;&#21344;&#29992;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Object is more than a quarter of our block size.  Allocate it separately</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to avoid wasting too much space in leftover bytes.</span>
    <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">result</span> = AllocateNewBlock(bytes);
    <span style="font-weight: bold;">return</span> result;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We waste the remaining space in the current block.</span>
  alloc_ptr_ = AllocateNewBlock(kBlockSize); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#20250;&#20998;&#37197;&#20986;&#26469;&#28982;&#21518;&#22312;&#36825;&#19978;&#38754;&#36827;&#34892;&#20999;&#20998;.</span>
  alloc_bytes_remaining_ = kBlockSize;

  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">result</span> = alloc_ptr_;
  alloc_ptr_ += bytes;
  alloc_bytes_remaining_ -= bytes;
  <span style="font-weight: bold;">return</span> result;
}

<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; text-decoration: underline;">Arena</span>::<span style="font-weight: bold;">AllocateAligned</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">align</span> = <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>*);    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We'll align to pointer size</span>
  assert((align &amp; (align-1)) == 0);   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Pointer size should be a power of 2</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">current_mod</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align-1); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38656;&#35201;&#32771;&#34385;&#24403;&#21069;&#22320;&#22336;&#26159;&#21542;&#23545;&#20854;.</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">slop</span> = (current_mod == 0 ? 0 : align - current_mod);
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">needed</span> = bytes + slop; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#23545;&#40784;&#25105;&#20204;&#21487;&#33021;&#38656;&#35201;&#20570;&#30340;&#20559;&#31227;.</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">result</span>;
  <span style="font-weight: bold;">if</span> (needed &lt;= alloc_bytes_remaining_) {
    result = alloc_ptr_ + slop;
    alloc_ptr_ += needed;
    alloc_bytes_remaining_ -= needed;
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">AllocateFallback always returned aligned memory</span>
    result = AllocateFallback(bytes);
  }
  assert((<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uintptr_t</span>&gt;(result) &amp; (align-1)) == 0);
  <span style="font-weight: bold;">return</span> result;
}

<span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; text-decoration: underline;">Arena</span>::<span style="font-weight: bold;">AllocateNewBlock</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">block_bytes</span>) {
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">result</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">char</span>[block_bytes];
  blocks_memory_ += block_bytes;
  blocks_.push_back(result);
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb5bd0ee" class="outline-4">
<h4 id="orgb5bd0ee"><span class="section-number-4">10.9.2</span> Coding</h4>
<div class="outline-text-4" id="text-10-9-2">
<p>
util/coding.h[.cc] Coding主要是用来完成变长数据以及字符串还有Slice的序列化和反序列化的.主要方法包括下面这些
</p>
<ul class="org-ul">
<li>PutFixed32 写入定长uint32</li>
<li>PutFixed64 写入定长uint64</li>
<li>PutVarint32 写入变长uint32</li>
<li>PutVarint64 写入变长uint64</li>
<li>PutLengthPrefixedSlice 后面解释.</li>
<li>GetVarint32 读取变长uint32</li>
<li>GetVarint64 读取变长uint64</li>
<li>GetLengthPrefixedSlice 后面解释.</li>
<li>GetVarint32Ptr(p,limit,v) 将[p,limit)部分的内存解析为变长uint32放到v里面,返回下一个字节</li>
<li>GetVarint64Ptr(p,limit,v) 将[p,limit)部分的内存解析为变长uint64放到v里面,返回下一个字节</li>
<li>VarintLength 变长uint32/uint64长度</li>
<li>EncodeFixed32 PutFixed32 low-level</li>
<li>EncodeFixed64 PutFixed64 low-level</li>
<li>EncodeVarint32 PutVarint32 low-level</li>
<li>EncodeVarint64 PutVarint64 low-level</li>
<li>DecodeFixed32 读取定长uint32</li>
<li>DecodeFixed64 读取定长uint64</li>
<li>GetVarint32PtrFallback</li>
<li>GetVarint32Ptr 从[p,limit)读取uint32并且返回下一个字节.</li>
</ul>

<p>
编码方式有点类似于google::protobuf里面的变长整数打包。我们这里着重看看下面两个函数
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">PutLengthPrefixedSlice</span>(<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dst</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">value</span>) {
  PutVarint32(dst, value.size());
  dst-&gt;append(value.data(), value.size());
}
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">GetLengthPrefixedSlice</span>(<span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">input</span>, <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">result</span>) {
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">len</span>;
  <span style="font-weight: bold;">if</span> (GetVarint32(input, &amp;len) &amp;&amp;
      input-&gt;size() &gt;= len) {
    *result = Slice(input-&gt;data(), len);
    input-&gt;remove_prefix(len);
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
}
</pre>
</div>
<p>
PutLengthPrefixedSlice对于slice的存储，首先是放入uint32长度然后放入内容.
GetLengthPrefixedSlice从input首先取出长度，然后取出数据,并且将input跳过这些长度.
</p>
</div>
</div>

<div id="outline-container-orgfc69fbf" class="outline-4">
<h4 id="orgfc69fbf"><span class="section-number-4">10.9.3</span> Histogram</h4>
<div class="outline-text-4" id="text-10-9-3">
<p>
todo:
</p>
</div>
</div>

<div id="outline-container-orgeeca770" class="outline-4">
<h4 id="orgeeca770"><span class="section-number-4">10.9.4</span> SkipList</h4>
<div class="outline-text-4" id="text-10-9-4">
<p>
db/skiplist.h SkipList(跳表)之前在课本上看到过，但是当时觉得实在是没有太大的用途。现在仔细看看吧.
这里的SkipList附带了一个iterator.首先看看SkipList的结构.SkipList对于写的话是需要外部进行同步的，
对于读的话可以是多个读同时发起。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">Node</span>;

 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create a new SkipList object that will use "cmp" for comparing keys,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">and will allocate memory using "*arena".  Objects allocated in the arena</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">must remain allocated for the lifetime of the skiplist object.</span>
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">SkipList</span>(<span style="font-weight: bold; text-decoration: underline;">Comparator</span> <span style="font-weight: bold; font-style: italic;">cmp</span>, <span style="font-weight: bold; text-decoration: underline;">Arena</span>* <span style="font-weight: bold; font-style: italic;">arena</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Insert key into the list.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: nothing that compares equal to key is currently in the list.</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Insert</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns true iff an entry that compares equal to key is in the list.</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Contains</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Iteration over the contents of a skip list</span>
  <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Iterator</span> {
   <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Initialize an iterator over the specified list.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The returned iterator is not valid.</span>
    <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">Iterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>* <span style="font-weight: bold; font-style: italic;">list</span>);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns true iff the iterator is positioned at a valid node.</span>
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Valid</span>() <span style="font-weight: bold;">const</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Returns the key at the current position.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Valid()</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold;">key</span>() <span style="font-weight: bold;">const</span>;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Advances to the next position.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Valid()</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Next</span>();

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Advances to the previous position.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">REQUIRES: Valid()</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Prev</span>();

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Advance to the first entry with a key &gt;= target</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>);

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Position at the first entry in list.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Final state of iterator is Valid() iff list is not empty.</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToFirst</span>();

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Position at the last entry in list.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Final state of iterator is Valid() iff list is not empty.</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SeekToLast</span>();

   <span style="font-weight: bold;">private</span>:
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>* <span style="font-weight: bold; font-style: italic;">list_</span>;
    <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">node_</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Intentionally copyable</span>
  };

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold;">enum</span> { <span style="font-weight: bold; font-style: italic;">kMaxHeight</span> = 12 }; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36339;&#34920;&#26368;&#22823;&#39640;&#24230;&#26159;12.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Immutable after construction</span>
  <span style="font-weight: bold; text-decoration: underline;">Comparator</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">compare_</span>;
  <span style="font-weight: bold; text-decoration: underline;">Arena</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">arena_</span>;    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Arena used for allocations of nodes</span>

  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">head_</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Modified only by Insert().  Read racily by readers, but stale</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">values are ok.</span>
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">AtomicPointer</span> <span style="font-weight: bold; font-style: italic;">max_height_</span>;   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Height of the entire list</span>

  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">GetMaxHeight</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#26368;&#22823;&#30340;skiplist&#39640;&#24230;.</span>
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">intptr_t</span>&gt;(max_height_.NoBarrier_Load());
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Read/written only by Insert().</span>
  <span style="font-weight: bold; text-decoration: underline;">Random</span> <span style="font-weight: bold; font-style: italic;">rnd_</span>;

  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold;">NewNode</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">height</span>);
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">RandomHeight</span>();
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">Equal</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">b</span>) <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> (compare_(a, b) == 0); }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return true if key is greater than the data stored in "n"</span>
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">KeyIsAfterNode</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">n</span>) <span style="font-weight: bold;">const</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the earliest node that comes at or after key.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return NULL if there is no such node.</span>
  <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If prev is non-NULL, fills prev[level] with pointer to previous</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">node at "level" for every level in [0..max_height_-1].</span>
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold;">FindGreaterOrEqual</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">Node</span>** <span style="font-weight: bold; font-style: italic;">prev</span>) <span style="font-weight: bold;">const</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the latest node with a key &lt; key.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return head_ if there is no such node.</span>
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold;">FindLessThan</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the last node in the list.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return head_ if list is empty.</span>
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold;">FindLast</span>() <span style="font-weight: bold;">const</span>;
};
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgf6a8d2c"></a>RandomHeight<br />
<div class="outline-text-5" id="text-10-9-4-1">
<p>
随机产生一个SkipList的高度.从1开始每次以1/4的概率+1.
</p>
<ul class="org-ul">
<li>h=1 3/4</li>
<li>h=2 3/16</li>
<li>&#x2026;</li>
</ul>
<p>
主要就是有这么一个大概的概率就是,随机初始化的高度不会很大.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold;">RandomHeight</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Increase height with probability 1 in kBranching</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">unsigned</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kBranching</span> = 4;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">height</span> = 1;
  <span style="font-weight: bold;">while</span> (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) {
    height++;
  }
  assert(height &gt; 0);
  assert(height &lt;= kMaxHeight);
  <span style="font-weight: bold;">return</span> height;
}
</pre>
</div>
</div>
</li>

<li><a id="orgaaba9a0"></a>KeyIsAfterNode<br />
<div class="outline-text-5" id="text-10-9-4-2">
<p>
可以认为是key的比较函数吧.拿key和当前某一个node进行比较，看看这个key是否应该存在这个node之后.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold;">KeyIsAfterNode</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">n</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NULL n is considered infinite</span>
  <span style="font-weight: bold;">return</span> (n != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20869;&#37096;&#30340;comparator.</span>
}
</pre>
</div>
</div>
</li>

<li><a id="org8cf9969"></a>FindGreaterOrEqual<br />
<div class="outline-text-5" id="text-10-9-4-3">
<p>
找到和key相当或者是&gt;key的第一个node.对跳表的原理稍微熟悉一些大概就可以看懂代码了.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold;">FindGreaterOrEqual</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">Node</span>** <span style="font-weight: bold; font-style: italic;">prev</span>)
    <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">x</span> = head_;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = GetMaxHeight() - 1; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25353;&#29031;&#26368;&#39640;&#23618;&#30340;&#36339;&#34920;&#26597;&#25214;</span>
  <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">true</span>) {
    <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">next</span> = x-&gt;Next(level);
    <span style="font-weight: bold;">if</span> (KeyIsAfterNode(key, next)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;key&#22312;&#36825;&#20010;&#21518;&#38754;&#30340;&#35805;,&#37027;&#20040;&#32487;&#32493;&#25353;&#29031;&#36825;&#20010;&#39640;&#24230;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Keep searching in this list</span>
      x = next;
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold;">if</span> (prev != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) prev[level] = x; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35760;&#24405;&#36825;&#20010;prev.</span>
      <span style="font-weight: bold;">if</span> (level == 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#21040;&#20102;&#26368;&#19979;&#23618;&#30340;&#35805;.</span>
        <span style="font-weight: bold;">return</span> next; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#30340;&#36820;&#22238;&#20540;&#19981;&#19968;&#23450;Equal(key)</span>
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Switch to next list</span>
        level--; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;level--.</span>
      }
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org2d789e5"></a>Insert<br />
<div class="outline-text-5" id="text-10-9-4-4">
<p>
插入某一个key.恩,逻辑还算是比较简单吧
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold;">Insert</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">here since Insert() is externally synchronized.</span>
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">prev</span>[kMaxHeight];
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">x</span> = FindGreaterOrEqual(key, prev); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26597;&#25214;&#21040;key&#30340;previous&#30340;&#20869;&#23481;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Our data structure does not allow duplicate insertion</span>
  assert(x == <span style="font-weight: bold; text-decoration: underline;">NULL</span> || !Equal(key, x-&gt;key));

  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">height</span> = RandomHeight();
  <span style="font-weight: bold;">if</span> (height &gt; GetMaxHeight()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38543;&#26426;&#20135;&#29983;&#39640;&#24230;.:&#25105;&#22312;&#24819;&#65292;&#26159;&#19981;&#26159;&#21482;&#26377;&#36825;&#20010;&#22320;&#26041;&#25165;&#20250;&#25913;&#21464;&#39640;&#24230;&#21602;?.</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = GetMaxHeight(); i &lt; height; i++) {
      prev[i] = head_; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#30340;&#35805;&#65292;&#37027;&#20040;&#21021;&#22987;&#21270;&#20026;head_.</span>
    }
    <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">fprintf(stderr, "Change height from %d to %d\n", max_height_, height);</span>

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">It is ok to mutate max_height_ without any synchronization</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">with concurrent readers.  A concurrent reader that observes</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the new value of max_height_ will see either the old value of</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">new level pointers from head_ (NULL), or a new value set in</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">the loop below.  In the former case the reader will</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">immediately drop to the next level since NULL sorts after all</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">keys.  In the latter case the reader will use the new node.</span>
    max_height_.NoBarrier_Store(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>*&gt;(height));
  }

  x = NewNode(key, height); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20135;&#29983;&#19968;&#20010;&#26032;&#30340;&#33410;&#28857;.</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; height; i++) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#25554;&#20837;&#32500;&#25252;&#22909;&#36825;&#20010;&#36339;&#34920;&#32467;&#26500;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">NoBarrier_SetNext() suffices since we will add a barrier when</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we publish a pointer to "x" in prev[i].</span>
    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));
    prev[i]-&gt;SetNext(i, x);
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgaa5cf2f"></a>Contains<br />
<div class="outline-text-5" id="text-10-9-4-5">
<p>
Contains用来判断跳表里面是否包含key
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold;">Contains</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">x</span> = FindGreaterOrEqual(key, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold;">if</span> (x != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; Equal(key, x-&gt;key)) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;!=NULL&#24182;&#19988;Equal&#30340;&#35805;&#37027;&#20040;&#36820;&#22238;true.</span>
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org8d601ff"></a>FindLessThan<br />
<div class="outline-text-5" id="text-10-9-4-6">
<p>
查找最后面一个less than key的这个node.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Node</span>*
<span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold;">FindLessThan</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">x</span> = head_;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = GetMaxHeight() - 1;
  <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">true</span>) {
    assert(x == head_ || compare_(x-&gt;key, key) &lt; 0);
    <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">next</span> = x-&gt;Next(level);
    <span style="font-weight: bold;">if</span> (next == <span style="font-weight: bold; text-decoration: underline;">NULL</span> || compare_(next-&gt;key, key) &gt;= 0) {
      <span style="font-weight: bold;">if</span> (level == 0) {
        <span style="font-weight: bold;">return</span> x;
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Switch to next list</span>
        level--;
      }
    } <span style="font-weight: bold;">else</span> {
      x = next;
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="org0480380"></a>FindLast<br />
<div class="outline-text-5" id="text-10-9-4-7">
<p>
FindLast就是找到元素的最后一个节点.非常简单，首先在最高节点遍历然后不断地降低level遍历.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold;">FindLast</span>()
    <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">x</span> = head_;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = GetMaxHeight() - 1;
  <span style="font-weight: bold;">while</span> (<span style="font-weight: bold; text-decoration: underline;">true</span>) {
    <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">next</span> = x-&gt;Next(level);
    <span style="font-weight: bold;">if</span> (next == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      <span style="font-weight: bold;">if</span> (level == 0) {
        <span style="font-weight: bold;">return</span> x;
      } <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Switch to next list</span>
        level--;
      }
    } <span style="font-weight: bold;">else</span> {
      x = next;
    }
  }
}
</pre>
</div>
</div>
</li>

<li><a id="orgcf0edff"></a>Node<br />
<div class="outline-text-5" id="text-10-9-4-8">
<p>
在看下面的函数之前我们先看看Node的实现.其实非常简单，而且似乎没有必要使用atomic的方式来操作。
因为这里面我们已经要求写需要外部加锁保证了.(#note: 后来想想还是有必要的,这里我们只是要求用户
在写的时候使用外部同步机保证，而读的时候没有。那么这样必须强制读取内存才可以保证正确,所以这里
需要Acquire<sub>Load以及Release</sub><sub>Load</sub>).非常简单，就是持有key以及跳表指针.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Node</span> {
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">Node</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">k</span>) : key(k) { }

  <span style="font-weight: bold; text-decoration: underline;">Key</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">key</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Accessors/mutators for links.  Wrapped in methods so we can</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">add the appropriate barriers as necessary.</span>
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold;">Next</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
    assert(n &gt;= 0);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Use an 'acquire load' so that we observe a fully initialized</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">version of the returned Node.</span>
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Node</span>*&gt;(<span style="font-weight: bold; text-decoration: underline;">next_</span>[n].Acquire_Load());
  }
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">SetNext</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">x</span>) {
    assert(n &gt;= 0);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Use a 'release store' so that anybody who reads through this</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pointer observes a fully initialized version of the inserted node.</span>
    next_[n].Release_Store(x);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No-barrier variants that can be safely used in a few locations.</span>
  <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold;">NoBarrier_Next</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
    assert(n &gt;= 0);
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Node</span>*&gt;(<span style="font-weight: bold; text-decoration: underline;">next_</span>[n].NoBarrier_Load());
  }
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">NoBarrier_SetNext</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">Node</span>* <span style="font-weight: bold; font-style: italic;">x</span>) {
    assert(n &gt;= 0);
    next_[n].NoBarrier_Store(x);
  }

 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Array of length equal to the node height.  next_[0] is lowest level link.</span>
  <span style="font-weight: bold; text-decoration: underline;">port</span>::<span style="font-weight: bold; text-decoration: underline;">AtomicPointer</span> <span style="font-weight: bold; font-style: italic;">next_</span>[1]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#33267;&#23569;&#26377;&#19968;&#20010;next&#25351;&#38024;.</span>
};
</pre>
</div>
</div>
</li>

<li><a id="orgd2c9dc5"></a>NewNode<br />
<div class="outline-text-5" id="text-10-9-4-9">
<p>
前面看完了Node的结构.然后Node分配就非常简单了.这里采用了inplacement new的方式来分配内存
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Node</span>*
<span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold;">NewNode</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">height</span>) {
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">mem</span> = arena_-&gt;AllocateAligned(
      <span style="font-weight: bold;">sizeof</span>(Node) + <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">port</span>::AtomicPointer) * (height - 1));
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">new</span> (mem) <span style="font-weight: bold; text-decoration: underline;">Node</span>(key);
}
</pre>
</div>
<p>
注意这里只需要分配height-1的高度即可，因为在Node里面已经存在了1个链表指针.
</p>
</div>
</li>

<li><a id="org23daee5"></a>Iterator<br />
<div class="outline-text-5" id="text-10-9-4-10">
<p>
了解了跳表的工作原理之后，对于其遍历器理解就非常简单了。代码也非常简单。但是阅读代码就会发现，
跳表的前向遍历功能不怎么样，因为没有维护prev指针。这里prev的方法是用过调用FindLessThan来实现的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">Iterator</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>* <span style="font-weight: bold; font-style: italic;">list</span>) {
  list_ = list;
  node_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
}

<span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">Valid</span>() <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">return</span> node_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
}

<span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">key</span>() <span style="font-weight: bold;">const</span> {
  assert(Valid());
  <span style="font-weight: bold;">return</span> node_-&gt;key;
}

<span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">Next</span>() {
  assert(Valid());
  node_ = node_-&gt;Next(0);
}

<span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">Prev</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Instead of using explicit "prev" links, we just search for the</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">last node that falls before key.</span>
  assert(Valid());
  node_ = list_-&gt;FindLessThan(node_-&gt;key); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21487;&#33021;&#24615;&#33021;&#20250;&#23384;&#22312;&#38382;&#39064;.&#25152;&#20197;&#26368;&#22909;&#19981;&#35201;&#21069;&#21521;&#36941;&#21382;.</span>
  <span style="font-weight: bold;">if</span> (node_ == list_-&gt;head_) {
    node_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }
}

<span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">Seek</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>&amp; <span style="font-weight: bold; font-style: italic;">target</span>) {
  node_ = list_-&gt;FindGreaterOrEqual(target, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
}

<span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">SeekToFirst</span>() {
  node_ = list_-&gt;head_-&gt;Next(0);
}

<span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">Key</span>, <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">SkipList</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Key</span>,<span style="font-weight: bold; text-decoration: underline;">Comparator</span>&gt;::<span style="font-weight: bold; text-decoration: underline;">Iterator</span>::<span style="font-weight: bold;">SeekToLast</span>() {
  node_ = list_-&gt;FindLast();
  <span style="font-weight: bold;">if</span> (node_ == list_-&gt;head_) {
    node_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }
}
</pre>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org66976a8" class="outline-4">
<h4 id="org66976a8"><span class="section-number-4">10.9.5</span> AtomicPointer</h4>
<div class="outline-text-4" id="text-10-9-5">
<p>
port/atomic<sub>pointer.h</sub> 指针的存取都是原子操作.对于pointer来说，不管是32位还是64位的话都是原子操作的。但是这里必须考虑内存屏障。
对于leveldb还考虑到c++0x的原子操作库cstdatomic本身所提供的功能。我们都看看这个是如何实现的。
</p>

<p>
对于没有cstdatomic并且是x86CPU的话.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">AtomicPointer built using platform-specific MemoryBarrier()</span>

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Gcc on x86</span>
<span style="font-weight: bold;">#elif</span> <span style="font-weight: bold;">defined</span>(ARCH_CPU_X86_FAMILY) &amp;&amp; <span style="font-weight: bold;">defined</span>(__GNUC__)
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">MemoryBarrier</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering.</span>
  <span style="font-weight: bold;">__asm__</span> __volatile__(<span style="font-style: italic;">""</span> : : : <span style="font-style: italic;">"memory"</span>);
}

<span style="font-weight: bold;">#if</span> <span style="font-weight: bold;">defined</span>(LEVELDB_HAVE_MEMORY_BARRIER)
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">AtomicPointer</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">rep_</span>;
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">AtomicPointer</span>() { }
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">AtomicPointer</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">p</span>) : rep_(p) {}
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">NoBarrier_Load</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> rep_; }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">NoBarrier_Store</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">v</span>) { rep_ = v; }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">Acquire_Load</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">result</span> = rep_;
    MemoryBarrier();
    <span style="font-weight: bold;">return</span> result;
  }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Release_Store</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">v</span>) {
    MemoryBarrier();
    rep_ = v;
  }
};
</pre>
</div>

<p>
对于有cstdatomic库的话.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#elif</span> <span style="font-weight: bold;">defined</span>(LEVELDB_CSTDATOMIC_PRESENT)
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">AtomicPointer</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">atomic</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>*&gt; <span style="font-weight: bold; font-style: italic;">rep_</span>;
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">AtomicPointer</span>() { }
  <span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">AtomicPointer</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">v</span>) : rep_(v) { }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">Acquire_Load</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> rep_.load(<span style="font-weight: bold; text-decoration: underline;">std</span>::memory_order_acquire); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">memory order acquire</span>
  }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">Release_Store</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">v</span>) {
    rep_.store(v, <span style="font-weight: bold; text-decoration: underline;">std</span>::memory_order_release); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">memory order release.</span>
  }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">NoBarrier_Load</span>() <span style="font-weight: bold;">const</span> {
    <span style="font-weight: bold;">return</span> rep_.load(<span style="font-weight: bold; text-decoration: underline;">std</span>::memory_order_relaxed); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">memory order relaxed.</span>
  }
  <span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">NoBarrier_Store</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">v</span>) {
    rep_.store(v, <span style="font-weight: bold; text-decoration: underline;">std</span>::memory_order_relaxed);
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org2579f5a" class="outline-4">
<h4 id="org2579f5a"><span class="section-number-4">10.9.6</span> CRC32C</h4>
<div class="outline-text-4" id="text-10-9-6">
<p>
util/crc32c.cc CRC32C算法实现.注意这里Extend的第一个参数是初始值.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the crc32c of concat(A, data[0,n-1]) where init_crc is the</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">crc32c of some string A.  Extend() is often used to maintain the</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">crc32c of a stream of data.</span>
<span style="font-weight: bold;">extern</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">Extend</span>(<span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">init_crc</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">data</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>);

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the crc32c of data[0,n-1]</span>
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">Value</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">data</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  <span style="font-weight: bold;">return</span> Extend(0, data, n);
}
</pre>
</div>

<p>
后面还有两个函数没有看懂存在的意义，但是本身算法并不麻烦.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">kMaskDelta</span> = 0xa282ead8ul;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return a masked representation of crc.</span>
<span style="font-weight: bold; font-style: italic;">//</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Motivation: it is problematic to compute the CRC of a string that</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">contains embedded CRCs.  Therefore we recommend that CRCs stored</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">somewhere (e.g., in files) should be masked before being stored.</span>
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">Mask</span>(<span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">crc</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Rotate right by 15 bits and add a constant.</span>
  <span style="font-weight: bold;">return</span> ((crc &gt;&gt; 15) | (crc &lt;&lt; 17)) + kMaskDelta;
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Return the crc whose masked representation is masked_crc.</span>
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">Unmask</span>(<span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">masked_crc</span>) {
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">rot</span> = masked_crc - kMaskDelta;
  <span style="font-weight: bold;">return</span> ((rot &gt;&gt; 17) | (rot &lt;&lt; 15));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org537fb65" class="outline-4">
<h4 id="org537fb65"><span class="section-number-4">10.9.7</span> Hash</h4>
<div class="outline-text-4" id="text-10-9-7">
<p>
hash.cc提供了Hash算法，看上去有点类似于murmurhash.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">Hash</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">data</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">seed</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Similar to murmur hash</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">m</span> = 0xc6a4a793;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">r</span> = 24;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">limit</span> = data + n;
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">h</span> = seed ^ (n * m);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Pick up four bytes at a time</span>
  <span style="font-weight: bold;">while</span> (data + 4 &lt;= limit) {
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">w</span> = DecodeFixed32(data);
    data += 4;
    h += w;
    h *= m;
    h ^= (h &gt;&gt; 16);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Pick up remaining bytes</span>
  <span style="font-weight: bold;">switch</span> (limit - data) {
    <span style="font-weight: bold;">case</span> 3:
      h += data[2] &lt;&lt; 16;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">fall through</span>
    <span style="font-weight: bold;">case</span> 2:
      h += data[1] &lt;&lt; 8;
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">fall through</span>
    <span style="font-weight: bold;">case</span> 1:
      h += data[0];
      h *= m;
      h ^= (h &gt;&gt; r);
      <span style="font-weight: bold;">break</span>;
  }
  <span style="font-weight: bold;">return</span> h;
}
</pre>
</div>

<p>
之前一直纠结于这个seed应该如何来进行设置。其实现在自己也不知道:(.
在bloom.cc里面使用方式是：
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold;">BloomHash</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>) {
  <span style="font-weight: bold;">return</span> Hash(key.data(), key.size(), 0xbc9f1d34);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgda45575" class="outline-4">
<h4 id="orgda45575"><span class="section-number-4">10.9.8</span> BloomFilterPolicy</h4>
<div class="outline-text-4" id="text-10-9-8">
<p>
第一次看接口有点混淆。为什么CreateFilter需要将生成的filter追加到dst里面呢?其实我猜想这个完全取决于应用，
可能应用在上层希望将filter的内存统一管理，然后一次释放。使用的时候可以选取某一个slice作为filter.
</p>

<p>
#note: 之前可能对于filter有点错误理解.觉得这个filter没有必要存放在磁盘上而应该全部在内存上面。
但是leveldb会针对若干个data block生成一个filter存放在磁盘上面。如果是这样接口就非常好理解了，
将所有的filter全部聚合在连续的内存上面写入table.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">explicit</span> <span style="font-weight: bold;">BloomFilterPolicy</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">bits_per_key</span>)
    : bits_per_key_(bits_per_key) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35745;&#31639;&#20026;&#27599;&#20010;key&#29983;&#25104;&#22810;&#23569;&#20010;probe(&#26816;&#27979;&#28857;).</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bits_per_key*ln(2)</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We intentionally round down to reduce probing cost a little bit</span>
  k_ = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">size_t</span>&gt;(bits_per_key * 0.69);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">0.69 =~ ln(2)</span>
  <span style="font-weight: bold;">if</span> (k_ &lt; 1) k_ = 1;
  <span style="font-weight: bold;">if</span> (k_ &gt; 30) k_ = 30;
}

<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">CreateFilter</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>* <span style="font-weight: bold; font-style: italic;">keys</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">string</span>* <span style="font-weight: bold; font-style: italic;">dst</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Compute bloom filter size (in both bits and bytes)</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bits</span> = n * bits_per_key_; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197;&#22810;&#23569;&#20010;bits.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For small n, we can see a very high false positive rate.  Fix it</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">by enforcing a minimum bloom filter length.</span>
  <span style="font-weight: bold;">if</span> (bits &lt; 64) bits = 64;

  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span> = (bits + 7) / 8; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20570;&#19968;&#20010;round&#28982;&#21518;&#35745;&#31639;&#20998;&#37197;&#22810;&#23569;&#20010;bits.</span>
  bits = bytes * 8;

  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">init_size</span> = dst-&gt;size();
  dst-&gt;resize(init_size + bytes, 0); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">dst&#21069;&#38754;&#30340;&#37096;&#20998;&#19981;&#21516;&#36861;&#21152;bytes&#23383;&#33410;.</span>
  dst-&gt;push_back(<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>&gt;(k_));  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Remember # of probes in filter // &#23558;&#36825;&#20010;probe&#20010;&#25968;&#35760;&#24405;&#22312;dst&#26411;&#23614;.</span>
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">array</span> = &amp;(*dst)[init_size]; <span style="font-weight: bold; font-style: italic;">//</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; n; i++) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Use double-hashing to generate a sequence of hash values.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">See analysis in [Kirsch,Mitzenmacher 2006].</span>
    <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">h</span> = BloomHash(keys[i]);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">delta</span> = (h &gt;&gt; 17) | (h &lt;&lt; 15);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Rotate right 17 bits</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">j</span> = 0; j &lt; k_; j++) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#27425;&#20570;key&#20010;&#28857;&#30340;probe.</span>
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">bitpos</span> = h % bits;
      array[bitpos/8] |= (1 &lt;&lt; (bitpos % 8));
      h += delta;
    }
  }
}

<span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">KeyMayMatch</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">key</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">bloom_filter</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">len</span> = bloom_filter.size(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#20010;len&#21253;&#21547;&#20102;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#30340;probe.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21518;&#38754;&#37117;&#38750;&#24120;&#22909;&#29702;&#35299;.</span>
  <span style="font-weight: bold;">if</span> (len &lt; 2) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;

  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">array</span> = bloom_filter.data();
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bits</span> = (len - 1) * 8;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Use the encoded k so that we can read filters generated by</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">bloom filters created using different parameters.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">k</span> = array[len-1];
  <span style="font-weight: bold;">if</span> (k &gt; 30) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Reserved for potentially new encodings for short bloom filters.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Consider it a match.</span>
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }

  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">h</span> = BloomHash(key);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">delta</span> = (h &gt;&gt; 17) | (h &lt;&lt; 15);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Rotate right 17 bits</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">j</span> = 0; j &lt; k; j++) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">bitpos</span> = h % bits;
    <span style="font-weight: bold;">if</span> ((array[bitpos/8] &amp; (1 &lt;&lt; (bitpos % 8))) == 0) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
    h += delta;
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orge36dd1c" class="outline-2">
<h2 id="orge36dd1c"><span class="section-number-2">11</span> Discussion</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-orgbbe4d71" class="outline-3">
<h3 id="orgbbe4d71"><span class="section-number-3">11.1</span> leveldb通过iterator遍历，对于相同的key如何保证获取到最新的值（hpplinux)</h3>
<div class="outline-text-3" id="text-11-1">
<p>
<b>Question</b>
</p>

<pre class="example">
我在看LevelDB代码的时候遇到了一个问题，百思不得其解，也找不到可以探讨请教的人，所以冒昧的给您发了这封邮件，希望得到您的帮助。
我遇到的问题是这样的：
在
void Version::AddIterators(const ReadOptions&amp; options,
                           std::vector&lt;Iterator*&gt;* iters) {
  // Merge all level zero files together since they may overlap
  for (size_t i = 0; i &lt; files_[0].size(); i++) {
    iters-&gt;push_back(
        vset_-&gt;table_cache_-&gt;NewIterator(
            options, files_[0][i]-&gt;number, files_[0][i]-&gt;file_size));
  }

  // For levels &gt; 0, we can use a concatenating iterator that sequentially
  // walks through the non-overlapping files in the level, opening them
  // lazily.
  for (int level = 1; level &lt; config::kNumLevels; level++) {
    if (!files_[level].empty()) {
      iters-&gt;push_back(NewConcatenatingIterator(options, level));
    }
  }
}

中对于Level 0层是按照下标从0到N开始遍历的， 但是由于数据加入的时候老的文件在前，新的在后，所以这样的话在iters数组中
下标最小的不一定是最新的。
而在DBImpl::NewInternalIterator 中会把该函数的返回结果直接进行merging，而且原则是key相同的话选取丢弃后面出现的。

这样的策略的话会不会导致较老的数据被留下，较新的被删除 ？
</pre>

<hr />

<p>
<b>Answer</b>
</p>

<p>
是这样的，你可以看到AddIterators这个部分是被DBImpl::NewInternalIterator调用的，得到所有的iterators之后，构造一个MergingIterator对象。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;version&#26469;&#35828;&#21487;&#33021;&#23384;&#22312;&#24456;&#22810;&#25991;&#20214;&#38656;&#35201;&#36941;&#21382;.</span>
versions_-&gt;current()-&gt;AddIterators(options, &amp;list);
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20123;&#20869;&#23481;&#26500;&#36896;&#31216;&#20026;&#19968;&#20010;merge iterator.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27880;&#24847;&#36825;&#37324;&#30340;&#20869;&#23481;&#37117;&#21152;&#20102;&#24341;&#29992;&#35745;&#25968;.</span>
<span style="font-weight: bold; text-decoration: underline;">Iterator</span>* <span style="font-weight: bold; font-style: italic;">internal_iter</span> =
    NewMergingIterator(&amp;internal_comparator_, &amp;list[0], list.size());
</pre>
</div>

<p>
注意它这里提供的comparator是一个internal<sub>comparator</sub>. 这个comparator不仅仅比较user key, 还比较sequence number. 因为sequence number是顺序分配的，所以新的kv得到更大的sequence number. 代码在这里：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">InternalKeyComparator</span>::<span style="font-weight: bold;">Compare</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">akey</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Slice</span>&amp; <span style="font-weight: bold; font-style: italic;">bkey</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Order by:</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">increasing user key (according to user-supplied comparator)</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">decreasing sequence number</span>
  <span style="font-weight: bold; font-style: italic;">//    </span><span style="font-weight: bold; font-style: italic;">decreasing type (though sequence# should be enough to disambiguate)</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">r</span> = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
  <span style="font-weight: bold;">if</span> (r == 0) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">anum</span> = DecodeFixed64(akey.data() + akey.size() - 8);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">bnum</span> = DecodeFixed64(bkey.data() + bkey.size() - 8);
    <span style="font-weight: bold;">if</span> (anum &gt; bnum) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25353;&#29031;sequence number&#27604;&#36739;.</span>
     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20043;&#21069;&#25105;&#20204;&#22312;MemTableInserter&#37324;&#38754;&#21487;&#20197;&#30475;&#21040;sequence number&#26159;&#19981;&#26029;&#22686;&#21152;&#30340;.</span>
      r = -1;
    } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (anum &lt; bnum) {
      r = +1;
    }
  }
  <span style="font-weight: bold;">return</span> r;
}

</pre>
</div>

<p>
然后这个就好解释问题了。首先每个iterator内部都是按照key做好排序的，多路iterator如果出现相同的key那么使用sequence number大的那个，这样就可以保证始终首先看到的是新值。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: work</p>
<p class="date">Created: 2019-04-03 Wed 04:56</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://maypeppa.github.io/html/leveldb.html';this.page.identifier = 'leveldb.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://cdnjs.cloudflare.com/ajax/libs/embed-js/4.2.1/embed.min.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
