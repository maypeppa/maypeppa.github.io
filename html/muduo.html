<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-31377772-3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-31377772-3');</script>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>muduo</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="work" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/htmlize.css"/><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/readtheorg.css"/><script src="https://ajax.loli.net/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script><script type="text/javascript" src="/themes/styles/lib/js/jquery.stickytableheaders.min.js"></script><script type="text/javascript" src="/themes/styles/readtheorg/js/readtheorg.js"></script></head>
<body>
<div id="content">
<h1 class="title">muduo</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9fdc696">1. base</a></li>
<li><a href="#orgbfa7a62">2. Buffer</a></li>
<li><a href="#org9cfec36">3. Channel</a></li>
<li><a href="#orga620f41">4. Poller</a></li>
<li><a href="#orgc97c7bc">5. EventLoop</a>
<ul>
<li><a href="#orgddc8268">5.1. 单线程单EventLoop</a></li>
<li><a href="#orgf9a6dc3">5.2. 跨线程激活</a></li>
<li><a href="#org91892b8">5.3. 跨线程任务</a></li>
<li><a href="#org8230f7f">5.4. 定时器任务</a></li>
<li><a href="#org4e2ed72">5.5. How it works</a></li>
</ul>
</li>
<li><a href="#org40eabab">6. TimerQueue</a></li>
<li><a href="#org67017a6">7. EventLoopThread</a></li>
<li><a href="#orgee7f9bf">8. Acceptor</a></li>
<li><a href="#org72d9846">9. Connector</a></li>
<li><a href="#org06cb849">10. TcpConnection</a></li>
<li><a href="#org9bd0f67">11. TcpClient</a></li>
<li><a href="#org3c561ca">12. TcpServer</a></li>
</ul>
</div>
</div>
<p>
<a href="http://code.google.com/p/muduo/">http://code.google.com/p/muduo/</a>
</p>

<p>
在分析muduo之前必须了解一下作者的想法：<a href="http://www.cnblogs.com/Solstice/archive/2010/08/29/muduo_net_lib.html">http://www.cnblogs.com/Solstice/archive/2010/08/29/muduo_net_lib.html</a>
</p>
<ul class="org-ul">
<li>线程安全，支持多核多线程</li>
<li>不考虑可移植性，不跨平台，只支持 Linux，不支持 Windows。 // 支持Windows有时候代价太大了</li>
<li>在不增加复杂度的前提下可以支持 FreeBSD/Darwin，方便将来用 Mac 作为开发用机，但不为它做性能优化。也就是说 IO multiplexing 使用 poll 和 epoll。</li>
<li>主要支持 x86-64，兼顾 IA32</li>
<li>不支持 UDP，只支持 TCP</li>
<li>不支持 IPv6，只支持 IPv4</li>
<li>不考虑广域网应用，只考虑局域网 // 不会存在慢连接，所以即使是阻塞读也不会花去太长时间用在阻塞上面</li>
<li>只支持一种使用模式：non-blocking IO + one event loop per thread，不考虑阻塞 IO</li>
<li>API 简单易用，只暴露具体类和标准库里的类，不使用 non-trivial templates，也不使用虚函数 // GP而非OO</li>
<li>只满足常用需求的 90%，不面面俱到，必要的时候以 app 来适应 lib</li>
<li>只做 library，不做成 framework</li>
<li>争取全部代码在 5000 行以内（不含测试）</li>
<li>以上条件都满足时，可以考虑搭配 Google Protocol Buffers RPC // RPC可以简化很多东西</li>
</ul>
<p>
muduo使用了很多新的Linux内核特性，包括使用signalfd和timerfd来触发信号以及定时器，所以代码上相对于于hpserver好看很多了。但是里面使用了boost::bind以及boost一些东西，
因为个人对于这个部分不是很清楚，所以很多地方并不是非常理解。muduo和hpserver一样也引入了很多概念，了解这些概念也非常有帮助。muduo做了线程管理，但是仅仅做了event loop
的线程管理，没有做工作线程的管理。所以工作线程还是需要自己管理。异步队列在base目录下面也实现了。所以基本上可以认为muduo里面包含了很多网络编程框架需要的组件。
muduo将hpserver下面的event item和event handler以及handle都在一起，称之为Channel.而Reactor在这里称为EventLoop.所以可以认为相对于hpserver,类层次结构好理解多了。
</p>

<div id="outline-container-org9fdc696" class="outline-2">
<h2 id="org9fdc696"><span class="section-number-2">1</span> base</h2>
<div class="outline-text-2" id="text-1">
<p>
base下面都是一些关于多线程编程方面需要使用的组件
<a href="http://www.cnblogs.com/Solstice/archive/2010/08/21/muduo_thread_lib.html">http://www.cnblogs.com/Solstice/archive/2010/08/21/muduo_thread_lib.html</a>
包括下面这些文件：
</p>
<ul class="org-ul">
<li>Atomic.h // 原子操作，里面的CAS没有使用汇编而是使用_<sub>sync</sub><sub>val</sub><sub>compare</sub><sub>and</sub><sub>swap这个GCC内置函数</sub></li>
<li>BlockingQueue.h // 异步队列，底层使用std::deque来实现，没有大小限制</li>
<li>BoundedBlockingQueue.h // 异步队列，但是使用循环数组来实现，有大小限制</li>
<li>Condition.h // pthread<sub>cond封装</sub></li>
<li>CountDownLatch.h // 可以用作类似于起跑线机制，值得学习一下</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">CountDownLatch</span>::<span style="font-weight: bold;">wait</span>() <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">latchdown&#20043;&#21518;&#28982;&#21518;&#35843;&#29992;wait.&#31561;&#24453;&#26368;&#21518;&#19968;&#20010;&#32447;&#31243;notifyAll,</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#22810;&#20010;&#32447;&#31243;&#21516;&#26102;&#35299;&#38500;&#38145;&#23450;&#23601;&#21487;&#20197;&#21516;&#26102;&#24320;&#22987;&#25191;&#34892;&#20102;</span>
{
    <span style="font-weight: bold; text-decoration: underline;">MutexLockGuard</span> <span style="font-weight: bold; font-style: italic;">lock</span>(mutex_);
    <span style="font-weight: bold;">while</span> (count_ &gt; 0) {
        condition_.wait();
    }
}

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">CountDownLatch</span>::<span style="font-weight: bold;">countDown</span>() <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010;&#32447;&#31243;&#22312;&#24320;&#22987;&#37117;latchdown,&#26368;&#21518;&#19968;&#20010;&#32447;&#31243;&#20250;notifyAll</span>
{
    <span style="font-weight: bold; text-decoration: underline;">MutexLockGuard</span> <span style="font-weight: bold; font-style: italic;">lock</span>(mutex_);
    --count_;
    <span style="font-weight: bold;">if</span> (count_ == 0) {
        condition_.notifyAll();
    }
}
</pre>
</div>
<ul class="org-ul">
<li>Logging.h // 日志</li>
<li>Mutex.h // 互斥锁</li>
<li>ProcessInfo.h // 进程信息</li>
<li>Singleton.h // 单例模式，实现上比较有特色</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">T</span>&amp; <span style="font-weight: bold;">instance</span>()
{
  pthread_once(&amp;ponce_, &amp;<span style="font-weight: bold; text-decoration: underline;">Singleton</span>::init); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20351;&#29992;pthread_once&#26469;&#36827;&#34892;&#26500;&#36896;</span>
  <span style="font-weight: bold;">return</span> *value_;
}
</pre>
</div>
<ul class="org-ul">
<li>Thread.h // 线程封装,内部有一个static变量记录当前创建了多少个线程</li>
<li>ThreadLocal.h // 线程局部变量封装，不用在使用pthread<sub>get</sub>/setspecific</li>
<li>ThreadLocalSignleton.h // 线程局部单例，不用考虑多个线程同时创建</li>
<li>ThreadPool.h // 线程池包装，内部维护了一个异步队列，多个线程的工作就是取出task来执行</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22806;&#37096;&#20002;&#20837;Task&#25918;&#21040;&#32447;&#31243;&#27744;&#20869;&#37096;</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadPool</span>::<span style="font-weight: bold;">run</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Task</span>&amp; <span style="font-weight: bold; font-style: italic;">task</span>)
{
  <span style="font-weight: bold;">if</span> (threads_.empty()) <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;&#20219;&#20309;&#32447;&#31243;</span>
  {
    task();
  }
  <span style="font-weight: bold;">else</span>
  {
    <span style="font-weight: bold; text-decoration: underline;">MutexLockGuard</span> <span style="font-weight: bold; font-style: italic;">lock</span>(mutex_);
    queue_.push_back(task);
    cond_.notify();
  }
}
<span style="font-weight: bold; text-decoration: underline;">ThreadPool</span>::<span style="font-weight: bold; text-decoration: underline;">Task</span> <span style="font-weight: bold; text-decoration: underline;">ThreadPool</span>::<span style="font-weight: bold;">take</span>()
{
  <span style="font-weight: bold; text-decoration: underline;">MutexLockGuard</span> <span style="font-weight: bold; font-style: italic;">lock</span>(mutex_);
  <span style="font-weight: bold;">while</span> (queue_.empty() &amp;&amp; running_)
  {
    cond_.wait();
  }
  <span style="font-weight: bold; text-decoration: underline;">Task</span> <span style="font-weight: bold; font-style: italic;">task</span>;
  <span style="font-weight: bold;">if</span>(!queue_.empty())
  {
    task = queue_.front();
    queue_.pop_front();
  }
  <span style="font-weight: bold;">return</span> task;
}
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32447;&#31243;&#22238;&#35843;&#20989;&#25968;</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadPool</span>::<span style="font-weight: bold;">runInThread</span>()
{
  <span style="font-weight: bold;">try</span>
  {
    <span style="font-weight: bold;">while</span> (running_)
    {
      <span style="font-weight: bold; text-decoration: underline;">Task</span> <span style="font-weight: bold; font-style: italic;">task</span>(take());
      <span style="font-weight: bold;">if</span> (task)
      {
        task();
      }
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbfa7a62" class="outline-2">
<h2 id="orgbfa7a62"><span class="section-number-2">2</span> Buffer</h2>
<div class="outline-text-2" id="text-2">
<p>
Buffer设计的非常精巧。Buffer内部是一个std::vector&lt;char*&gt;表示的，逻辑上结构是这样的
</p>
<pre class="example">
/// @code
/// +-------------------+------------------+------------------+
/// | prependable bytes |  readable bytes  |  writable bytes  |
/// |                   |     (CONTENT)    |                  |
/// +-------------------+------------------+------------------+
/// |                   |                  |                  |
/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size
/// @endcode
</pre>
<p>
头部有prependable bytes这个似乎可以不要，内部是占用8个字节，初始化的时候size占用了1024+8个字节。初始的时候readerIndex==writerIndex==8,
就好比现在没有任何数据写入。一旦开始要写入数据的话，那么writerIndex+=size(要写入的字节数)这个buffer会动态地增长。readerIndex标记的就是我们
可以读的下标，如果readerIndex==writerIndex就表示没有数据了。但是很明显这个Buffer并不是无限增长的，在makeSpace函数里面的话就可以看到，实际上
是会进行压缩的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">makeSpace</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">len</span>)
{
    <span style="font-weight: bold;">if</span> (writableBytes() + prependableBytes() &lt; len + kCheapPrepend) <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#24403;&#21069;&#19981;&#33021;&#22815;&#36890;&#36807;&#21387;&#32553;&#21512;&#24182;&#30340;&#35805;</span>
    {
        buffer_.resize(writerIndex_+len);
    }
    <span style="font-weight: bold;">else</span>
    {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">move readable data to the front, make space inside buffer</span>
        assert(kCheapPrepend &lt; readerIndex_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#21487;&#20197;&#21387;&#32553;&#30340;&#35805;&#37027;&#20040;&#23601;&#21387;&#32553;</span>
        <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">readable</span> = readableBytes();
        <span style="font-weight: bold; text-decoration: underline;">std</span>::copy(begin()+readerIndex_,
                  begin()+writerIndex_,
                  begin()+kCheapPrepend);
        readerIndex_ = kCheapPrepend;
        writerIndex_ = readerIndex_ + readable;
        assert(readable == readableBytes());
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9cfec36" class="outline-2">
<h2 id="org9cfec36"><span class="section-number-2">3</span> Channel</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Channel</span> : <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">noncopyable</span>
{
  <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">function</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>()&gt; <span style="font-weight: bold; text-decoration: underline;">EventCallback</span>;
    <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">function</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>(<span style="font-weight: bold; font-style: italic;">Timestamp</span>)&gt; <span style="font-weight: bold; text-decoration: underline;">ReadEventCallback</span>;
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">handleEvent</span>(<span style="font-weight: bold; text-decoration: underline;">Timestamp</span> <span style="font-weight: bold; font-style: italic;">receiveTime</span>);
  <span style="font-weight: bold;">private</span>:
    <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>* <span style="font-weight: bold; font-style: italic;">loop_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23646;&#20110;&#21738;&#19968;&#20010;Reactor</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span>  <span style="font-weight: bold; font-style: italic;">fd_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20851;&#32852;fd</span>
    <span style="font-weight: bold; text-decoration: underline;">int</span>        <span style="font-weight: bold; font-style: italic;">events_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20851;&#27880;&#20107;&#20214;</span>
    <span style="font-weight: bold; text-decoration: underline;">int</span>        <span style="font-weight: bold; font-style: italic;">revents_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">ready&#20107;&#20214;</span>
    <span style="font-weight: bold; text-decoration: underline;">int</span>        <span style="font-weight: bold; font-style: italic;">index_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">used by Poller. &#22312;Poller&#20013;&#30340;&#32534;&#21495;&#65292;&#23454;&#38469;&#19978;&#27809;&#26377;&#29305;&#21035;&#24847;&#24605;</span>

    <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">weak_ptr</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>&gt; <span style="font-weight: bold; font-style: italic;">tie_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32465;&#23450;&#30340;&#23545;&#35937;&#65292;&#36825;&#20010;&#23545;&#20110;boost::weak_ptr&#19981;&#26159;&#24456;&#20102;&#35299;&#65292;&#20294;&#26159;&#36825;&#20010;&#23545;&#20110;&#29702;&#35299;&#26694;&#26550;&#27809;&#26377;&#29992;&#36884;</span>
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">tied_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21542;&#32465;&#23450;&#20102;&#23545;&#35937;&#19978;&#26469;</span>
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">eventHandling_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#27491;&#22312;&#22788;&#29702;event</span>
    <span style="font-weight: bold; text-decoration: underline;">ReadEventCallback</span> <span style="font-weight: bold; font-style: italic;">readCallback_</span>;
    <span style="font-weight: bold; text-decoration: underline;">EventCallback</span> <span style="font-weight: bold; font-style: italic;">writeCallback_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23450;&#20041;&#22914;&#20309;&#20889;&#25968;&#25454;</span>
    <span style="font-weight: bold; text-decoration: underline;">EventCallback</span> <span style="font-weight: bold; font-style: italic;">closeCallback_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23450;&#20041;&#22914;&#20309;&#20851;&#38381;&#36830;&#25509;</span>
    <span style="font-weight: bold; text-decoration: underline;">EventCallback</span> <span style="font-weight: bold; font-style: italic;">errorCallback_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23450;&#20041;&#22914;&#26524;&#20986;&#38169;&#30340;&#35805;&#22914;&#20309;&#22788;&#29702;</span>
};
</pre>
</div>
<p>
一旦EventLoop通知Channel触发事件的话那么就会调用handleEvent这个函数。参数receiveTime本身只对ReadEventCallback有效并且作为参数使用，
代表接收超时时间，对于write而言的话没有超时时间。内部的话handleEvent会根据revents触发的事件来分别决定调用哪些回调
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">Channel</span>::<span style="font-weight: bold;">handleEventWithGuard</span>(<span style="font-weight: bold; text-decoration: underline;">Timestamp</span> <span style="font-weight: bold; font-style: italic;">receiveTime</span>)
{
    eventHandling_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
    <span style="font-weight: bold;">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))
    {
        LOG_WARN &lt;&lt; <span style="font-style: italic;">"Channel::handle_event() POLLHUP"</span>;
        <span style="font-weight: bold;">if</span> (closeCallback_) closeCallback_();
    }
    <span style="font-weight: bold;">if</span> (revents_ &amp; POLLNVAL)
    {
        LOG_WARN &lt;&lt; <span style="font-style: italic;">"Channel::handle_event() POLLNVAL"</span>;
    }
    <span style="font-weight: bold;">if</span> (revents_ &amp; (POLLERR | POLLNVAL))
    {
        <span style="font-weight: bold;">if</span> (errorCallback_) errorCallback_();
    }
    <span style="font-weight: bold;">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))
    {
        <span style="font-weight: bold;">if</span> (readCallback_) readCallback_(receiveTime);
    }
    <span style="font-weight: bold;">if</span> (revents_ &amp; POLLOUT)
    {
        <span style="font-weight: bold;">if</span> (writeCallback_) writeCallback_();
    }
    eventHandling_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga620f41" class="outline-2">
<h2 id="orga620f41"><span class="section-number-2">4</span> Poller</h2>
<div class="outline-text-2" id="text-4">
<p>
Poller本身也是一个抽象类，然后底层支持poll和epoll.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Poller</span> : <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">noncopyable</span>
{
  <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Channel</span>*&gt; <span style="font-weight: bold; text-decoration: underline;">ChannelList</span>;
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Polls the I/O events.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Must be called in the loop thread.</span>
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">Timestamp</span> <span style="font-weight: bold;">poll</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">timeoutMs</span>, <span style="font-weight: bold; text-decoration: underline;">ChannelList</span>* <span style="font-weight: bold; font-style: italic;">activeChannels</span>) = 0;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36827;&#34892;poll&#25805;&#20316;&#65292;&#27963;&#36291;&#20107;&#20214;&#25918;&#22312;activeChannels&#37324;&#38754;</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Changes the interested I/O events.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Must be called in the loop thread.</span>
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">updateChannel</span>(<span style="font-weight: bold; text-decoration: underline;">Channel</span>* <span style="font-weight: bold; font-style: italic;">channel</span>) = 0; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26356;&#26032;channel</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Remove the channel, when it destructs.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Must be called in the loop thread.</span>
    <span style="font-weight: bold;">virtual</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">removeChannel</span>(<span style="font-weight: bold; text-decoration: underline;">Channel</span>* <span style="font-weight: bold; font-style: italic;">channel</span>) = 0; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21024;&#38500;channel</span>
  <span style="font-weight: bold;">private</span>:
    <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>* <span style="font-weight: bold; font-style: italic;">ownerLoop_</span>;
};
</pre>
</div>
<p>
在poller目录下面有poll和epoll的对应实现，不过我们这里没有必要仔细阅读。需要注意的是这里的channel处理并没有引入优先级的概念。
poll操作的timeoutMs就是epoll<sub>wait超时时间</sub>，而activeChannels就是活跃channel.返回值就是epoll<sub>wait之后的时间戳</sub>。
</p>
</div>
</div>

<div id="outline-container-orgc97c7bc" class="outline-2">
<h2 id="orgc97c7bc"><span class="section-number-2">5</span> EventLoop</h2>
<div class="outline-text-2" id="text-5">
<p>
和之前一样，我们还是看看EventLoop有哪些结构。对于EventLoop结构比较复杂，我们列出主要的接口和成员。
首先我们看EventLoop有runInLoop和queueInLoop功能，虽然作者建议event loop和一个线程绑定，但是在其他线程的话依然可以调用runInLoop和
queueInLoop的功能，将一些task加入到这个event loop对应的线程中执行。这样就很地然地引入了pendingFunctors字段。因为需要跨线程激活，
那么就需要线程之间的通知机制，这个使用eventfd来完成，对应字段就是wakeFd并且内部绑定了一个wakeupChannel.如果没有eventfd的话，通常也可以使用
pipe来完成。然后我们还允许向EventLoop里面添加定时器任务，就是runAt,runAfter和runEvery三个函数，我们只需要关注其中一个即可。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">EventLoop</span> : <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">noncopyable</span>
{
  <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">function</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>()&gt; <span style="font-weight: bold; text-decoration: underline;">Functor</span>;
    <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">function</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>()&gt; <span style="font-weight: bold; text-decoration: underline;">TimerCallback</span>;
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">loop</span>();
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">quit</span>();
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Runs callback immediately in the loop thread.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">It wakes up the loop, and run the cb.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">If in the same loop thread, cb is run within the function.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Safe to call from other threads.</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">runInLoop</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Functor</span>&amp; <span style="font-weight: bold; font-style: italic;">cb</span>);
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Queues callback in the loop thread.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Runs after finish pooling.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Safe to call from other threads.</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">queueInLoop</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Functor</span>&amp; <span style="font-weight: bold; font-style: italic;">cb</span>);

    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Runs callback at 'time'.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Safe to call from other threads.</span>
    <span style="font-weight: bold; font-style: italic;">///</span>
    <span style="font-weight: bold; text-decoration: underline;">TimerId</span> <span style="font-weight: bold;">runAt</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Timestamp</span>&amp; <span style="font-weight: bold; font-style: italic;">time</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TimerCallback</span>&amp; <span style="font-weight: bold; font-style: italic;">cb</span>);
    <span style="font-weight: bold; font-style: italic;">///</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Runs callback after @c delay seconds.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Safe to call from other threads.</span>
    <span style="font-weight: bold; font-style: italic;">///</span>
    <span style="font-weight: bold; text-decoration: underline;">TimerId</span> <span style="font-weight: bold;">runAfter</span>(<span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">delay</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TimerCallback</span>&amp; <span style="font-weight: bold; font-style: italic;">cb</span>);
    <span style="font-weight: bold; font-style: italic;">///</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Runs callback every @c interval seconds.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Safe to call from other threads.</span>
    <span style="font-weight: bold; font-style: italic;">///</span>
    <span style="font-weight: bold; text-decoration: underline;">TimerId</span> <span style="font-weight: bold;">runEvery</span>(<span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">interval</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TimerCallback</span>&amp; <span style="font-weight: bold; font-style: italic;">cb</span>);
    <span style="font-weight: bold; font-style: italic;">///</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Cancels the timer.</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Safe to call from other threads.</span>
    <span style="font-weight: bold; font-style: italic;">///</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">void cancel(TimerId timerId);</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">internal usage</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">wakeup</span>();
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">updateChannel</span>(<span style="font-weight: bold; text-decoration: underline;">Channel</span>* <span style="font-weight: bold; font-style: italic;">channel</span>);
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">removeChannel</span>(<span style="font-weight: bold; text-decoration: underline;">Channel</span>* <span style="font-weight: bold; font-style: italic;">channel</span>);
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">isInLoopThread</span>() <span style="font-weight: bold;">const</span> { <span style="font-weight: bold;">return</span> threadId_ == <span style="font-weight: bold; text-decoration: underline;">CurrentThread</span>::tid(); }
  <span style="font-weight: bold;">private</span>:
    <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Channel</span>*&gt; <span style="font-weight: bold; text-decoration: underline;">ChannelList</span>;
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">looping_</span>; <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">atomic */</span>
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">quit_</span>; <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">atomic */</span>
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">eventHandling_</span>; <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">atomic */</span>
    <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">callingPendingFunctors_</span>; <span style="font-weight: bold; font-style: italic;">/* </span><span style="font-weight: bold; font-style: italic;">atomic */</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">pid_t</span> <span style="font-weight: bold; font-style: italic;">threadId_</span>;
    <span style="font-weight: bold; text-decoration: underline;">Timestamp</span> <span style="font-weight: bold; font-style: italic;">pollReturnTime_</span>;
    <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">scoped_ptr</span>&lt;Poller&gt; <span style="font-weight: bold; font-style: italic;">poller_</span>;
    <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">scoped_ptr</span>&lt;TimerQueue&gt; <span style="font-weight: bold; font-style: italic;">timerQueue_</span>;
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">wakeupFd_</span>;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">unlike in TimerQueue, which is an internal class,</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we don't expose Channel to client.</span>
    <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">scoped_ptr</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Channel</span>&gt; <span style="font-weight: bold; font-style: italic;">wakeupChannel_</span>;
    <span style="font-weight: bold; text-decoration: underline;">ChannelList</span> <span style="font-weight: bold; font-style: italic;">activeChannels_</span>;
    <span style="font-weight: bold; text-decoration: underline;">MutexLock</span> <span style="font-weight: bold; font-style: italic;">mutex_</span>;
    <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Functor</span>&gt; <span style="font-weight: bold; font-style: italic;">pendingFunctors_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">@BuardedBy mutex_</span>
};
</pre>
</div>
</div>

<div id="outline-container-orgddc8268" class="outline-3">
<h3 id="orgddc8268"><span class="section-number-3">5.1</span> 单线程单EventLoop</h3>
<div class="outline-text-3" id="text-5-1">
<p>
作者建议一个线程绑定一个EventLoop,这个实现呢？其实还是使用线程局部变量。首先定义线程局部变量
</p>
<div class="org-src-container">
<pre class="src src-C++">__thread <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>* <span style="font-weight: bold; font-style: italic;">t_loopInThisThread</span> = 0;
</pre>
</div>
<p>
然后在EventLoop构造函数的时候判断这个是否==0,如果不为=0的话说明在这个线程已经构造过一个EventLoop了。
直接使用_<sub>thread这个关键字</sub>，值得学习一下。
</p>
</div>
</div>

<div id="outline-container-orgf9a6dc3" class="outline-3">
<h3 id="orgf9a6dc3"><span class="section-number-3">5.2</span> 跨线程激活</h3>
<div class="outline-text-3" id="text-5-2">
<p>
首先我们看看跨线程激活是怎么操作的。在EventLoop的初始化函数内部初始化了wakeupFd并且创建了channel.但是如果不仔细阅读，
很可能觉得的这个channel没有注册。而实际上这个channel在enableReading()就会注册的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">EventLoop</span>::<span style="font-weight: bold;">EventLoop</span>()
  : wakeupFd_(createEventfd()),
    wakeupChannel_(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Channel</span>(<span style="font-weight: bold;">this</span>, wakeupFd_))
{
  wakeupChannel_-&gt;setReadCallback(
      <span style="font-weight: bold; text-decoration: underline;">boost</span>::bind(&amp;<span style="font-weight: bold; text-decoration: underline;">EventLoop</span>::handleRead, <span style="font-weight: bold;">this</span>)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32465;&#23450;&#21040;handleRead&#19978;&#38754;&#20102;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we are always reading the wakeupfd</span>
  wakeupChannel_-&gt;enableReading();
}
#+END_SRC C++
&#36328;&#32447;&#31243;&#28608;&#27963;&#30340;&#20989;&#25968;&#26159;wakeUp.&#25105;&#20204;&#30475;&#30475;&#24590;&#20040;&#23454;&#29616;
#+BEGIN_SRC C++
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>::wakeup()
{
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">one</span> = 1;
  <span style="font-weight: bold; text-decoration: underline;">ssize_t</span> <span style="font-weight: bold; font-style: italic;">n</span> = <span style="font-weight: bold; text-decoration: underline;">sockets</span>::write(wakeupFd_, &amp;one, <span style="font-weight: bold;">sizeof</span> one); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31867;&#20284;&#20110;&#31649;&#36947;&#30452;&#25509;&#20889;</span>
}
</pre>
</div>
<p>
一旦wakeup完成之后那么wakeUpFd<sub>就是可读的</sub>，这样EventLoop就会被通知到并且立刻跳出epoll<sub>wait开始处理</sub>。当然我们需要将这个wakeupFd_
上面数据读出来，不然的话下一次又会被通知到，读取函数就是handleRead
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>::<span style="font-weight: bold;">handleRead</span>()
{
  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">one</span> = 1;
  <span style="font-weight: bold; text-decoration: underline;">ssize_t</span> <span style="font-weight: bold; font-style: italic;">n</span> = <span style="font-weight: bold; text-decoration: underline;">sockets</span>::read(wakeupFd_, &amp;one, <span style="font-weight: bold;">sizeof</span> one);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org91892b8" class="outline-3">
<h3 id="org91892b8"><span class="section-number-3">5.3</span> 跨线程任务</h3>
<div class="outline-text-3" id="text-5-3">
<p>
runInLoop和queueInLoop就是跨线程任务。内容非常简单
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>::<span style="font-weight: bold;">runInLoop</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Functor</span>&amp; <span style="font-weight: bold; font-style: italic;">cb</span>){
  <span style="font-weight: bold;">if</span> (isInLoopThread()){ <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36825;&#20010;&#20989;&#25968;&#22312;&#33258;&#24049;&#30340;&#32447;&#31243;&#35843;&#29992;&#65292;&#37027;&#20040;&#23601;&#21487;&#20197;&#31435;&#21363;&#25191;&#34892;</span>
    cb();
  }<span style="font-weight: bold;">else</span>{
    queueInLoop(cb); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;&#20854;&#20182;&#32447;&#31243;&#35843;&#29992;&#65292;&#37027;&#20040;&#21152;&#20837;&#21040;pendingFunctors&#37324;&#38754;&#21435;</span>
    wakeup(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#36890;&#30693;&#36825;&#20010;&#32447;&#31243;&#65292;&#26377;&#20219;&#21153;&#21040;&#26469;</span>
  }
}

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>::<span style="font-weight: bold;">queueInLoop</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Functor</span>&amp; <span style="font-weight: bold; font-style: italic;">cb</span>){
  {
  <span style="font-weight: bold; text-decoration: underline;">MutexLockGuard</span> <span style="font-weight: bold; font-style: italic;">lock</span>(mutex_);
  pendingFunctors_.push_back(cb);
  }
  <span style="font-weight: bold;">if</span> (isInLoopThread() &amp;&amp; callingPendingFunctors_){
    wakeup(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#34987;&#25490;&#19978;&#38431;&#20043;&#21518;&#22914;&#26524;&#26159;&#22312;&#33258;&#24049;&#32447;&#31243;&#24182;&#19988;&#27491;&#22312;&#25191;&#34892;pendingFunctors&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#21487;&#20197;&#28608;&#27963;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#19979;&#19968;&#36718;&#23436;&#20840;&#21487;&#20197;&#34987;&#25490;&#19978;&#65292;&#25152;&#20197;&#27809;&#26377;&#24517;&#35201;&#28608;&#27963;</span>
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8230f7f" class="outline-3">
<h3 id="org8230f7f"><span class="section-number-3">5.4</span> 定时器任务</h3>
<div class="outline-text-3" id="text-5-4">
<p>
定时器任务都是交给了TimerQueue来处理的，在TimerQueue这个部分我们会简要地分析一下
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">TimerId</span> <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>::<span style="font-weight: bold;">runAt</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Timestamp</span>&amp; <span style="font-weight: bold; font-style: italic;">time</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TimerCallback</span>&amp; <span style="font-weight: bold; font-style: italic;">cb</span>)
{
  <span style="font-weight: bold;">return</span> timerQueue_-&gt;addTimer(cb, time, 0.0); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">time&#26159;&#22312;&#20043;&#21518;&#20160;&#20040;&#26102;&#20505;&#24320;&#22987;&#65292;0.0&#34920;&#31034;&#20197;&#21518;&#27599;&#27425;&#36816;&#34892;&#26102;&#38388;(0.0&#34920;&#31034;&#19981;&#20250;repeat).</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4e2ed72" class="outline-3">
<h3 id="org4e2ed72"><span class="section-number-3">5.5</span> How it works</h3>
<div class="outline-text-3" id="text-5-5">
<p>
基本上和hpserver非常相似，不断地调用poller::poll方法，然后在外层不断地查看是否需要quit.poll之后会得到activeChannels.和hpserver不同的是，
muduo没有调用器(其实也不需要，本来就没有优先级概念)，仅仅遍历这个activeChannels，并且调用内部的handleEvent方法，然后在调用pengdingFunctors
一些跨线程任务。
</p>
</div>
</div>
</div>

<div id="outline-container-org40eabab" class="outline-2">
<h2 id="org40eabab"><span class="section-number-2">6</span> TimerQueue</h2>
<div class="outline-text-2" id="text-6">
<p>
TimerQueue里面最主要的方法就是addTimer.我们看看addTimer里面做了哪些事情，整个过程有点绕
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">TimerId</span> <span style="font-weight: bold; text-decoration: underline;">TimerQueue</span>::<span style="font-weight: bold;">addTimer</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">TimerCallback</span>&amp; <span style="font-weight: bold; font-style: italic;">cb</span>,
                             <span style="font-weight: bold; text-decoration: underline;">Timestamp</span> <span style="font-weight: bold; font-style: italic;">when</span>,
                             <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">interval</span>)
{
  <span style="font-weight: bold; text-decoration: underline;">Timer</span>* <span style="font-weight: bold; font-style: italic;">timer</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Timer</span>(cb, when, interval); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#21019;&#24314;&#19968;&#20010;Timer&#23545;&#35937;&#65292;&#28982;&#21518;&#23558;cb&#25918;&#22312;&#37324;&#38754;&#12290;&#20869;&#37096;&#26377;&#19968;&#20010;run&#20989;&#25968;&#65292;&#35843;&#29992;&#30340;&#23601;&#26159;cb</span>
  loop_-&gt;runInLoop(
      <span style="font-weight: bold; text-decoration: underline;">boost</span>::bind(&amp;<span style="font-weight: bold; text-decoration: underline;">TimerQueue</span>::scheduleInLoop, <span style="font-weight: bold;">this</span>, timer)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23558;&#36825;&#20010;timer&#20002;&#21040;eventLoop&#37324;&#38754;&#21435;&#25191;&#34892;</span>
  <span style="font-weight: bold;">return</span> TimerId(timer, timer-&gt;sequence());
}
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TimerQueue</span>::<span style="font-weight: bold;">scheduleInLoop</span>(<span style="font-weight: bold; text-decoration: underline;">Timer</span>* <span style="font-weight: bold; font-style: italic;">timer</span>)
{
  loop_-&gt;assertInLoopThread();
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">earliestChanged</span> = insert(timer); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;timer&#25554;&#20837;&#21040;&#20869;&#37096;&#30340;&#38142;&#34920;&#37324;&#38754;&#21435;&#65292;&#25353;&#29031;&#36229;&#26102;&#26102;&#38388;&#39034;&#24207;&#25554;&#20837;&#65292;&#24182;&#19988;&#21028;&#26029;&#36825;&#20010;&#25554;&#20837;&#26159;&#21542;&#20250;&#24433;&#21709;&#26368;&#26089;&#26102;&#38388;</span>

  <span style="font-weight: bold;">if</span> (earliestChanged)
  {
    resetTimerfd(timerfd_, timer-&gt;expiration()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#24433;&#21709;&#30340;&#35805;&#65292;&#37027;&#20040;&#35201;&#20462;&#25913;&#36825;&#20010;timerfd&#36229;&#26102;&#26102;&#38388;&#12290;</span>
  }
}
</pre>
</div>
<p>
然后一旦timerfd可读的时候，就会调用下面这个函数
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TimerQueue</span>::<span style="font-weight: bold;">handleRead</span>()
{
  loop_-&gt;assertInLoopThread();
  <span style="font-weight: bold; text-decoration: underline;">Timestamp</span> <span style="font-weight: bold; font-style: italic;">now</span>(<span style="font-weight: bold; text-decoration: underline;">Timestamp</span>::now());
  readTimerfd(timerfd_, now);
  <span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;Entry&gt; <span style="font-weight: bold; font-style: italic;">expired</span> = getExpired(now); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25105;&#20204;&#21487;&#20197;&#30693;&#36947;&#26377;&#21738;&#20123;&#35745;&#26102;&#22120;&#36229;&#26102;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">safe to callback outside critical section</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">std</span>::<span style="font-weight: bold; text-decoration: underline;">vector</span>&lt;Entry&gt;::<span style="font-weight: bold; text-decoration: underline;">iterator</span> <span style="font-weight: bold; font-style: italic;">it</span> = expired.begin();
      it != expired.end(); ++it)
  {
    it-&gt;second-&gt;run(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&#36825;&#20123;&#36229;&#26102;&#30340;Timer,&#25191;&#34892;run()&#20989;&#25968;&#65292;&#23545;&#24212;&#20063;&#23601;&#26159;&#25105;&#20204;&#19968;&#24320;&#22987;&#27880;&#20876;&#30340;&#22238;&#35843;&#20989;&#25968;&#12290;</span>
  }
  reset(expired, now);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org67017a6" class="outline-2">
<h2 id="org67017a6"><span class="section-number-2">7</span> EventLoopThread</h2>
<div class="outline-text-2" id="text-7">
<p>
EventLoopThread就是将一个EventLoop和Thread包装在一起的对象。这个内容到没有什么，不过觉得代码方面有点技巧。
我们在启动startLoop这个样就会执行线程threadFunc,但是我们必须等待threadFunc将栈上面的EventLoop绑定之后才可以返回，所以这里用到了条件变量。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">EventLoop</span>* <span style="font-weight: bold; text-decoration: underline;">EventLoopThread</span>::<span style="font-weight: bold;">startLoop</span>(){
    thread_.start();
    {
        <span style="font-weight: bold; text-decoration: underline;">MutexLockGuard</span> <span style="font-weight: bold; font-style: italic;">lock</span>(mutex_);
        <span style="font-weight: bold;">while</span> (loop_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>)
        {
            cond_.wait();
        }
    }
    <span style="font-weight: bold;">return</span> loop_;
}

<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">EventLoopThread</span>::<span style="font-weight: bold;">threadFunc</span>(){
    <span style="font-weight: bold; text-decoration: underline;">EventLoop</span> <span style="font-weight: bold; font-style: italic;">loop</span>;
    {
        <span style="font-weight: bold; text-decoration: underline;">MutexLockGuard</span> <span style="font-weight: bold; font-style: italic;">lock</span>(mutex_);
        loop_ = &amp;loop;
        cond_.notify();
    }
    loop.loop();
}
</pre>
</div>
<p>
而EventLoopThreadPool就是维持一个EventLoopThread线程池，所以没有什么特别好说的。我们只需要setThreadNum告诉开多少个线程，然后调用start即可。
</p>
</div>
</div>

<div id="outline-container-orgee7f9bf" class="outline-2">
<h2 id="orgee7f9bf"><span class="section-number-2">8</span> Acceptor</h2>
<div class="outline-text-2" id="text-8">
<p>
Acceptor帮助简化了搭建服务器accept这个部分的逻辑。通常这个逻辑是在单个线程里面完成的，所以抽取出来蛮有必要的。
代码不是很麻烦，用户要做的就是编写一个回调，这个回调在新建立连接时候出发，参数分别是链接fd和连接地址。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">function</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">sockfd</span>,<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InetAddress</span>&amp;)&gt; <span style="font-weight: bold; text-decoration: underline;">NewConnectionCallback</span>;
</pre>
</div>
<p>
原理很简单，初始化socket和对应的channel并且监听READ事件，然后开始进行listen.一旦触发read事件的话那么就证明我们无阻塞
地进行accept，然后在READ事件回调里面进行accept。一旦accept成功的话就调用这个回调函数即可。
</p>
</div>
</div>

<div id="outline-container-org72d9846" class="outline-2">
<h2 id="org72d9846"><span class="section-number-2">9</span> Connector</h2>
<div class="outline-text-2" id="text-9">
<p>
Connector也是为了简化客户端编写，用户只需要提供这个逻辑即可，这个回调函数在建立链接成功的时候使用
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">function</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">sockfd</span>)&gt; <span style="font-weight: bold; text-decoration: underline;">NewConnectionCallback</span>;
</pre>
</div>
<p>
Connector初始化以EventLoop和服务器地址初始化，然后在start的时候的话开始尝试进行connect.如果返回非阻塞的错误码的话，那么
创建一个channel并且监视WRITE和ERROR事件，否则就会尝试重连(按照一定时间间隔).在Connector::handleWrite里面的话会将这个channel
移除，然后调用NewConnectionCallback来处理连接建立的事件。
</p>
</div>
</div>

<div id="outline-container-org06cb849" class="outline-2">
<h2 id="org06cb849"><span class="section-number-2">10</span> TcpConnection</h2>
<div class="outline-text-2" id="text-10">
<p>
TcpConnection完成的工作就是当TCP连接建立之后处理socket的读写以及关闭。同样我们看看TcpConnection的结构
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">TcpConnection</span> : <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">noncopyable</span>,
                      <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">enable_shared_from_this</span>&lt;<span style="font-weight: bold; text-decoration: underline;">TcpConnection</span>&gt;
{
  <span style="font-weight: bold;">public</span>:
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">Constructs a TcpConnection with a connected sockfd</span>
    <span style="font-weight: bold; font-style: italic;">///</span>
    <span style="font-weight: bold; font-style: italic;">/// </span><span style="font-weight: bold; font-style: italic;">User should not create this object.</span>
    <span style="font-weight: bold;">TcpConnection</span>(<span style="font-weight: bold; text-decoration: underline;">EventLoop</span>* <span style="font-weight: bold; font-style: italic;">loop</span>, <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24314;&#31435;&#36830;&#25509;&#38656;&#35201;&#19968;&#20010;Reactor</span>
                  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">name</span>, <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36830;&#25509;&#21517;&#31216;</span>
                  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">sockfd</span>, <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36830;&#25509;fd.</span>
                  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InetAddress</span>&amp; <span style="font-weight: bold; font-style: italic;">localAddr</span>, <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36830;&#25509;&#30340;address.</span>
                  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InetAddress</span>&amp; <span style="font-weight: bold; font-style: italic;">peerAddr</span>);
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">called when TcpServer accepts a new connection</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">connectEstablished</span>();   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">should be called only once</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">called when TcpServer has removed me from its map</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">connectDestroyed</span>();  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">should be called only once</span>
  <span style="font-weight: bold;">private</span>:
    <span style="font-weight: bold;">enum</span> <span style="font-weight: bold; text-decoration: underline;">StateE</span> { <span style="font-weight: bold; font-style: italic;">kDisconnected</span>, <span style="font-weight: bold; font-style: italic;">kConnecting</span>, <span style="font-weight: bold; font-style: italic;">kConnected</span>, <span style="font-weight: bold; font-style: italic;">kDisconnecting</span> };
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">sendInLoop</span>(<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">message</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">len</span>); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21457;&#36865;&#28040;&#24687;</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">setState</span>(<span style="font-weight: bold; text-decoration: underline;">StateE</span> <span style="font-weight: bold; font-style: italic;">s</span>) { state_ = s; }

    <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>* <span style="font-weight: bold; font-style: italic;">loop_</span>;
    <span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">name_</span>;
    <span style="font-weight: bold; text-decoration: underline;">StateE</span> <span style="font-weight: bold; font-style: italic;">state_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">FIXME: use atomic variable</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we don't expose those classes to client.</span>
    <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">scoped_ptr</span>&lt;Socket&gt; <span style="font-weight: bold; font-style: italic;">socket_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">socket.</span>
    <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">scoped_ptr</span>&lt;Channel&gt; <span style="font-weight: bold; font-style: italic;">channel_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36830;&#25509;channel</span>
    <span style="font-weight: bold; text-decoration: underline;">InetAddress</span> <span style="font-weight: bold; font-style: italic;">localAddr_</span>;
    <span style="font-weight: bold; text-decoration: underline;">InetAddress</span> <span style="font-weight: bold; font-style: italic;">peerAddr_</span>;
    <span style="font-weight: bold; text-decoration: underline;">ConnectionCallback</span> <span style="font-weight: bold; font-style: italic;">connectionCallback_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36830;&#25509;&#22238;&#35843;&#65292;&#36825;&#20010;&#35302;&#21457;&#21253;&#25324;&#22312;&#36830;&#25509;&#24314;&#31435;&#21644;&#26029;&#24320;&#37117;&#20250;&#35302;&#21457;</span>
    <span style="font-weight: bold; text-decoration: underline;">MessageCallback</span> <span style="font-weight: bold; font-style: italic;">messageCallback_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26377;&#25968;&#25454;&#21487;&#35835;&#30340;&#22238;&#35843;</span>
    <span style="font-weight: bold; text-decoration: underline;">WriteCompleteCallback</span> <span style="font-weight: bold; font-style: italic;">writeCompleteCallback_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20889;&#23436;&#27605;&#30340;&#22238;&#35843;</span>
    <span style="font-weight: bold; text-decoration: underline;">CloseCallback</span> <span style="font-weight: bold; font-style: italic;">closeCallback_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36830;&#25509;&#20851;&#38381;&#22238;&#35843;</span>
    <span style="font-weight: bold; text-decoration: underline;">Buffer</span> <span style="font-weight: bold; font-style: italic;">inputBuffer_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25968;&#25454;&#35835;&#21462;buffer.</span>
    <span style="font-weight: bold; text-decoration: underline;">Buffer</span> <span style="font-weight: bold; font-style: italic;">outputBuffer_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">FIXME: use list&lt;Buffer&gt; as output buffer.</span>
    <span style="font-weight: bold; text-decoration: underline;">boost</span>::<span style="font-weight: bold; text-decoration: underline;">any</span> <span style="font-weight: bold; font-style: italic;">context_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19978;&#19979;&#25991;&#29615;&#22659;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">FIXME: creationTime_, lastReceiveTime_</span>
    <span style="font-weight: bold; font-style: italic;">//        </span><span style="font-weight: bold; font-style: italic;">bytesReceived_, bytesSent_</span>
};
</pre>
</div>
<p>
首先TcpConnection在初始化的时候会建立好channel.然后一旦TcpClient或者是TcpServer建立连接之后的话，那么调用TcpConnection::connectEstablished.
这个函数内部的话就会将channel设置成为可读。一旦可读的话那么TcpConnection内部就会调用handleRead这个动作，内部托管了读取数据这个操作。
读取完毕之后然后交给MessageBack这个回调进行操作。如果需要写的话调用sendInLoop，那么会将message放在outputBuffer里面，并且设置可写。
后当可写的话TcpConnection内部就托管写，然后写完之后的话会发生writeCompleteCallback这个回调。托管的读写操作都是非阻塞的。如果希望断开的话调用
shutdown。解除这个连接的话那么可以调用TcpConnection::connectDestroyed,内部大致操作就是从reactor移除这个channel.
</p>

<p>
在TcpConnection这层并不知道一次需要读取多少个字节，这个是在上层进行消息拆分的，这点可以仔细阅读一下Httpserver这个example.
TcpConnection一次最多读取64K字节的内容，然后交给上层。上层决定这些内容是否足够，如果不够的话那么直接返回让Reactor继续等待读。
同样写的话内部也是会分多次写。这样就要求reactor内部必须使用水平触发而不是边缘触发。
</p>
</div>
</div>

<div id="outline-container-org9bd0f67" class="outline-2">
<h2 id="org9bd0f67"><span class="section-number-2">11</span> TcpClient</h2>
<div class="outline-text-2" id="text-11">
<p>
一旦我们了解了TcpConnection之后的话，这个托管了建立好连接之后所需要的处理的所有事情，那么我们对于client关心的重点就是如果触发连接的建立以及连接是如何断开的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">TcpClient</span>::<span style="font-weight: bold;">TcpClient</span>(<span style="font-weight: bold; text-decoration: underline;">EventLoop</span>* <span style="font-weight: bold; font-style: italic;">loop</span>,
                     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InetAddress</span>&amp; <span style="font-weight: bold; font-style: italic;">serverAddr</span>,
                     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">name</span>)
        : loop_(CHECK_NOTNULL(loop)),
          connector_(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Connector</span>(loop, serverAddr)),
          name_(name),
          connectionCallback_(defaultConnectionCallback),
          messageCallback_(defaultMessageCallback),
          retry_(<span style="font-weight: bold; text-decoration: underline;">false</span>),
          connect_(<span style="font-weight: bold; text-decoration: underline;">true</span>),
          nextConnId_(1)
{
    connector_-&gt;setNewConnectionCallback(
        <span style="font-weight: bold; text-decoration: underline;">boost</span>::bind(&amp;<span style="font-weight: bold; text-decoration: underline;">TcpClient</span>::newConnection, <span style="font-weight: bold;">this</span>, _1));
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">FIXME setConnectFailedCallback</span>
}
</pre>
</div>
<p>
可以看到初始化了connector这个对象并且设置了connector的连接建立的回调。我们需要设置一下TcpConnection所需要设置的回调之后，然后调用connect()这个方法。
内部会调用connector::start方法，一旦连接建立成功的话那么会调用TcpClient::newConnection这个函数。在这个函数内部会建立TcpConnection，并且调用
TcpConnection::connectEstablished,之后的所有操作都交给TcpConnection了。如果需要断开连接的话调用disconnect,内部会调用TcpConnection::shutdown.在析构
函数里面会调用TcpConneciton::connectDestroyed来移除连接。
</p>
</div>
</div>

<div id="outline-container-org3c561ca" class="outline-2">
<h2 id="org3c561ca"><span class="section-number-2">12</span> TcpServer</h2>
<div class="outline-text-2" id="text-12">
<p>
从分析上我们和TcpClient一样只是关心连接是如何建立这个过程。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">TcpServer</span>::<span style="font-weight: bold;">TcpServer</span>(<span style="font-weight: bold; text-decoration: underline;">EventLoop</span>* <span style="font-weight: bold; font-style: italic;">loop</span>,
                     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InetAddress</span>&amp; <span style="font-weight: bold; font-style: italic;">listenAddr</span>,
                     <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">string</span>&amp; <span style="font-weight: bold; font-style: italic;">nameArg</span>)
  : loop_(CHECK_NOTNULL(loop)),
    hostport_(listenAddr.toHostPort()),
    name_(nameArg),
    acceptor_(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Acceptor</span>(loop, listenAddr)),
    threadPool_(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">EventLoopThreadPool</span>(loop)),
    connectionCallback_(defaultConnectionCallback),
    messageCallback_(defaultMessageCallback),
    started_(<span style="font-weight: bold; text-decoration: underline;">false</span>),
    nextConnId_(1)
{
  acceptor_-&gt;setNewConnectionCallback(
      <span style="font-weight: bold; text-decoration: underline;">boost</span>::bind(&amp;<span style="font-weight: bold; text-decoration: underline;">TcpServer</span>::newConnection, <span style="font-weight: bold;">this</span>, _1, _2));
}
</pre>
</div>
<p>
同样是建立好acceptor这个对象然后设置好回调为TcpServer::newConnection,同时在外部设置好TcpConnection的各个回调。然后调用start来启动服务器，start
会调用acceptor::listen这个方法，一旦有连接建立的话那么会调用newConnection.下面是newConnection代码
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">TcpServer</span>::<span style="font-weight: bold;">newConnection</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">sockfd</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">InetAddress</span>&amp; <span style="font-weight: bold; font-style: italic;">peerAddr</span>)
{
    loop_-&gt;assertInLoopThread();
    <span style="font-weight: bold; text-decoration: underline;">EventLoop</span>* <span style="font-weight: bold; font-style: italic;">ioLoop</span> = threadPool_-&gt;getNextLoop();
    <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[32];
    snprintf(buf, <span style="font-weight: bold;">sizeof</span> buf, <span style="font-style: italic;">":%s#%d"</span>, hostport_.c_str(), nextConnId_);
    ++nextConnId_;
    <span style="font-weight: bold; text-decoration: underline;">string</span> <span style="font-weight: bold; font-style: italic;">connName</span> = name_ + buf;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">FIXME poll with zero timeout to double confirm the new connection</span>
    <span style="font-weight: bold; text-decoration: underline;">TcpConnectionPtr</span> <span style="font-weight: bold; font-style: italic;">conn</span>(
        <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">TcpConnection</span>(ioLoop, connName, sockfd, localAddr, peerAddr));
    connections_[connName] = conn;
    conn-&gt;setConnectionCallback(connectionCallback_);
    conn-&gt;setMessageCallback(messageCallback_);
    conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);
    conn-&gt;setCloseCallback(
        <span style="font-weight: bold; text-decoration: underline;">boost</span>::bind(&amp;<span style="font-weight: bold; text-decoration: underline;">TcpServer</span>::removeConnection, <span style="font-weight: bold;">this</span>, _1)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">FIXME: unsafe</span>
    ioLoop-&gt;runInLoop(<span style="font-weight: bold; text-decoration: underline;">boost</span>::bind(&amp;<span style="font-weight: bold; text-decoration: underline;">TcpConnection</span>::connectEstablished, conn));
}
</pre>
</div>
<p>
对于服务端来说连接都被唯一化了然后映射称为字符串放在connections<sub>这个容器内部</sub>。threadPool_-&gt;getNextLoop()可以轮询地将取出么一个线程然后将
TcpConnection::connectEstablished轮询地丢到每个线程里面去完成。存放在connections<sub>是有原因了</sub>，每个TcpConnection有唯一一个名字，这样Server
就可以根据TcpConnection来从自己内部移除链接了。在析构函数里面可以遍历connections<sub>内容得到所有建立的连接并且逐一释放</sub>。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: work</p>
<p class="date">Created: 2019-04-03 Wed 04:57</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://maypeppa.github.io/html/muduo.html';this.page.identifier = 'muduo.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://cdnjs.cloudflare.com/ajax/libs/embed-js/4.2.1/embed.min.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
