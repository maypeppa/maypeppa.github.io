<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-31377772-3"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-31377772-3');</script>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>tcmalloc</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="work" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/htmlize.css"/><link rel="stylesheet" type="text/css" href="/themes/styles/readtheorg/css/readtheorg.css"/><script src="https://ajax.loli.net/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script><script type="text/javascript" src="/themes/styles/lib/js/jquery.stickytableheaders.min.js"></script><script type="text/javascript" src="/themes/styles/readtheorg/js/readtheorg.js"></script></head>
<body>
<div id="content">
<h1 class="title">tcmalloc</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgfefbbd2">1. 写在前面</a></li>
<li><a href="#org927a533">2. 函数入口</a></li>
<li><a href="#orgba66fde">3. 全局内存</a></li>
<li><a href="#org91de354">4. 管理对象</a>
<ul>
<li><a href="#orgae134ff">4.1. TCMallocGuard</a></li>
<li><a href="#org0cdcd64">4.2. PageHeapAllocator</a></li>
<li><a href="#org2e6f5c1">4.3. SizeMap</a></li>
<li><a href="#orgc12dba6">4.4. Central Cache</a>
<ul>
<li><a href="#org322784c">4.4.1. Data Structure</a></li>
<li><a href="#org11f5565">4.4.2. Init</a></li>
<li><a href="#orgf01bc66">4.4.3. InsertRange</a></li>
<li><a href="#orgb6ac97e">4.4.4. RemoveRange</a></li>
<li><a href="#org52c6d71">4.4.5. Populate</a></li>
</ul>
</li>
<li><a href="#org089f414">4.5. PageHeap</a>
<ul>
<li><a href="#org02128f2">4.5.1. Data Structure</a></li>
<li><a href="#org9983943">4.5.2. New</a></li>
<li><a href="#orgeaab645">4.5.3. Carve</a></li>
<li><a href="#org11a6555">4.5.4. GrowHeap</a></li>
<li><a href="#org441c9ba">4.5.5. Delete</a></li>
<li><a href="#org7f99d7c">4.5.6. IncrementalScavenge</a></li>
<li><a href="#orgf5fde78">4.5.7. ReleaseAtLeastNPages</a></li>
<li><a href="#orgf0bcf1a">4.5.8. Split</a></li>
<li><a href="#orgb16d51b">4.5.9. GetNextRange</a></li>
</ul>
</li>
<li><a href="#orgfc63d19">4.6. TCMalloc<sub>PageMap3</sub></a></li>
<li><a href="#orgc2f035e">4.7. PackedCache</a></li>
<li><a href="#org4961989">4.8. Thread Cache</a>
<ul>
<li><a href="#org67d42ea">4.8.1. Data Structure</a></li>
<li><a href="#org54f5166">4.8.2. InitModule</a></li>
<li><a href="#orge832814">4.8.3. InitTSD</a></li>
<li><a href="#org9ce3377">4.8.4. GetCache</a></li>
<li><a href="#org0978d7d">4.8.5. CreateCacheIfNecessary</a></li>
<li><a href="#org16e1431">4.8.6. NewHeap</a></li>
<li><a href="#org29b7da7">4.8.7. BecomeIdle</a></li>
<li><a href="#org1b67568">4.8.8. Init</a></li>
<li><a href="#org8ceb193">4.8.9. ThreadCache::FreeList</a></li>
<li><a href="#org06eaadb">4.8.10. IncreaseCacheLimitLocked</a></li>
<li><a href="#org1135bdb">4.8.11. DeleteCache</a></li>
<li><a href="#org6b28061">4.8.12. Cleanup</a></li>
<li><a href="#org9f0a8e4">4.8.13. ReleaseToCentralCache</a></li>
<li><a href="#orge7ae4aa">4.8.14. Allocate</a></li>
<li><a href="#orge99c1f3">4.8.15. FetchFromCentralCache</a></li>
<li><a href="#org2156eb7">4.8.16. Deallocate</a></li>
<li><a href="#org03121c3">4.8.17. ListTooLong</a></li>
<li><a href="#orgff0422c">4.8.18. Scavenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf7bf644">5. 用户对象</a>
<ul>
<li><a href="#org1d6c654">5.1. 函数入口</a></li>
<li><a href="#org23eb231">5.2. 分配逻辑</a></li>
<li><a href="#orgfa7bb8f">5.3. 释放逻辑</a></li>
</ul>
</li>
<li><a href="#orge35f3db">6. 扩展组件</a>
<ul>
<li><a href="#org8be9c0d">6.1. Sampler</a></li>
<li><a href="#org6e556ef">6.2. MallocExtension</a></li>
<li><a href="#orgf102b40">6.3. MallocHook</a></li>
<li><a href="#orgb4e8cda">6.4. HeapChecker</a></li>
<li><a href="#orga91a73a">6.5. HeapProfiler</a></li>
<li><a href="#orgd136e23">6.6. CPUProfiler</a></li>
</ul>
</li>
<li><a href="#orge5efaba">7. Discussion</a>
<ul>
<li><a href="#org8b951da">7.1. tcmalloc中的 MmapSysAllocator::Alloc 疑问(nwlzee)</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgfefbbd2" class="outline-2">
<h2 id="orgfefbbd2"><span class="section-number-2">1</span> 写在前面</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>内存管理内幕 <a href="http://www.ibm.com/developerworks/cn/linux/l-memory/">http://www.ibm.com/developerworks/cn/linux/l-memory/</a></li>
<li>hoard内存分配器 <a href="http://www.hoard.org/">http://www.hoard.org/</a></li>
<li>dlmalloc内存分配器 <a href="http://gee.cs.oswego.edu/dl/html/malloc.html">http://gee.cs.oswego.edu/dl/html/malloc.html</a></li>
<li>ptmalloc2内存分配器 <a href="http://www.malloc.de/en/index.html">http://www.malloc.de/en/index.html</a></li>
<li>jemalloc内存分配器 <a href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf">http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf</a></li>
<li>jemalloc地址 <a href="http://www.canonware.com/download/jemalloc/">http://www.canonware.com/download/jemalloc/</a></li>
<li>tcmalloc内存分配器 <a href="http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html">http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html</a></li>
<li>tcmalloc地址 <a href="http://google-perftools.googlecode.com/files/google-perftools-1.8.3.tar.gz">http://google-perftools.googlecode.com/files/google-perftools-1.8.3.tar.gz</a></li>
</ul>

<p>
<b>如果你对使用tcmalloc有什么问题的话，请给我发邮件。我会尽量给你答复，对于常见的问题也会整理到FAQ上面。</b>
</p>

<p>
jemalloc论文上面谈到了很多关于内存分配器方面的基本概念与问题。
性能指标主要体现在分配时间以及平均和高峰内存使用大小上面。但是两个指标很难单独测量，所以现在比较权威的测量方式还是使用benchmark然后看看运行时间以及内存使用量。内存碎片分为内部碎片和外部碎片。
内部碎片通常都是因为分配的话会进行round之后而没有使用的部分，而外部碎片指已经回收但是因为地址不连续等原因没有办法被应用程序使用的部分。
jemalloc提高CPU Cache命中率有两个途径：
</p>
<ul class="org-ul">
<li>首先尽可能地让内存使用更小。working set可以放在cache-line里面全部存放效率就会比较好。</li>
<li>另外就是应该让连续开辟的对象放在一起。jemalloc是假设在一个线程内部调用两次的malloc的话，那么通常是在一起访问的。</li>
</ul>
<p>
第一个假设非常合理，但是第二个假设不一定是合理的。jemalloc首先确保第一个前提，然后尽可能地保证第二个条件。
另外cache命中率的一个问题就是false-cache-line.简单的说就是两个线程开辟的对象(A,B)可能连在一起，可以一起载入cache-line.线程1对于A的修改会造成线程2下一次读取B的时候，需要重新从内存载入，因为对于A的修改会使得所在的cache-line失效。解决这个问题的办法就是有多个allocation arena.不同的线程尽可能在不同的arena下面开辟。
</p>

<p>
锁冲突是造成传统malloc在多线程情况下表现差的主要原因。解决的方法和解决false-cache-line是一样的，都是开辟多个allocation arena然后让不同的线程尽可能地在不同的arena分配。
</p>

<p>
ptmalloc2解决为了解决锁冲突这个问题，也采用了arena-per-thread的方法。但是ptmalloc2内部依然存在一个大的问题，就是各个arena之间是没有办法迁移的。
如果一个线程一开始开辟很大但是之后释放了，那个这块内存是没有办法被其他线程所使用的。
</p>

<p>
同样tcmalloc会为每一个线程分配一个arena,这样每一个线程分配时候都不需要进行加锁。但是tcmalloc解决了ptmalloc2的内存迁移问题。
tcmalloc如果发现thread cache内部占用率高但是使用率低的话，那么会将部分内存存放在中心部分。基本上jemalloc原理上和tcmalloc相似。
每个线程有一个arena池，但是线程按照round-robin方式在每一个arena上面取。代价是需要加锁，但是假设冲突应该不严重。
</p>

<p>
后面我们着重针对tcmalloc进行分析。tcmalloc文档写的足够好了，看完一遍基本上就知道内部原理了。所以这里我也只是自己总结一下，然后用自己的理解写出来。里面尽量附上代码分析:)
tcmalloc代码写得相当得好，虽然很多地方没有看懂(而且我猜想有很多地方已经过时了但是没有删去，所以对于代码阅读有一定的影响).基本上阅读完tcmalloc阅读和编写代码能力会提高很多。
看下面分析之前，还是强烈建议先阅读一次文档。
</p>
</div>
</div>

<div id="outline-container-org927a533" class="outline-2">
<h2 id="org927a533"><span class="section-number-2">2</span> 函数入口</h2>
<div class="outline-text-2" id="text-2">
<p>
tcmalloc.cc
</p>

<p>
tcmallo.cc里面定义了函数入口.对于安排在section(google<sub>malloc</sub>)不知道有作用。当然下面有很多相关的函数比如tc<sub>memalign</sub>，但是这些并不影响阅读主线。
我们只需要关心两个函数tc<sub>malloc以及tc</sub><sub>free即可</sub>。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;malloc.h&gt;</span>
<span style="font-weight: bold;">#define</span> <span style="font-weight: bold; font-style: italic;">__THROW</span>
<span style="font-weight: bold;"># define</span> <span style="font-weight: bold;">ATTRIBUTE_SECTION</span>(<span style="font-weight: bold; font-style: italic;">name</span>) <span style="font-weight: bold;">__attribute__</span> ((section (#name)))
<span style="font-weight: bold;">extern</span> <span style="font-style: italic;">"C"</span> {
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">tc_malloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>) <span style="font-weight: bold; text-decoration: underline;">__THROW</span>
      <span style="font-weight: bold;">ATTRIBUTE_SECTION</span>(google_malloc);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">tc_free</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>) <span style="font-weight: bold; text-decoration: underline;">__THROW</span>
      <span style="font-weight: bold;">ATTRIBUTE_SECTION</span>(google_malloc);
}
</pre>
</div>

<p>
然后在libc<sub>override</sub><sub>gcc</sub><sub>and</sub><sub>weak.h和libc</sub><sub>override</sub><sub>glibc.h进行了函数替换</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#define</span> <span style="font-weight: bold;">ALIAS</span>(<span style="font-weight: bold; font-style: italic;">tc_fn</span>)   <span style="font-weight: bold;">__attribute__</span> ((alias (#tc_fn)))
<span style="font-weight: bold;">extern</span> <span style="font-style: italic;">"C"</span> {
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">__libc_malloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>)                ALIAS(tc_malloc);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">__libc_free</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>)                     ALIAS(tc_free);
} <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">extern "C"</span>
<span style="font-weight: bold;">extern</span> <span style="font-style: italic;">"C"</span> {
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">malloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>) <span style="font-weight: bold; text-decoration: underline;">__THROW</span>               <span style="font-weight: bold;">ALIAS</span>(tc_malloc);
  <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">free</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>) <span style="font-weight: bold; text-decoration: underline;">__THROW</span>                    <span style="font-weight: bold;">ALIAS</span>(tc_free);
} <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">extern "C"</span>
</pre>
</div>

<p>
同时在里面还覆盖了malloc<sub>hook和free</sub><sub>hook这两个函数</sub>，不允许用户自己进行hook.
我猜想tcmalloc应该是自己提供了malloc<sub>hook和free</sub><sub>hook的定义</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">extern</span> <span style="font-style: italic;">"C"</span> {
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">glibc_override_malloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">caller</span>) {
  <span style="font-weight: bold;">return</span> tc_malloc(size);
}
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">glibc_override_free</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">ptr</span>, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">caller</span>) {
  tc_free(ptr);
}
<span style="font-weight: bold; text-decoration: underline;">void</span>* (* MALLOC_HOOK_MAYBE_VOLATILE __malloc_hook)(size_t, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">void</span>*)
    = &amp;glibc_override_malloc;
<span style="font-weight: bold; text-decoration: underline;">void</span> (* MALLOC_HOOK_MAYBE_VOLATILE __free_hook)(<span style="font-weight: bold; text-decoration: underline;">void</span>*, <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">void</span>*)
    = &amp;glibc_override_free;
} <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">extern "C"</span>
</pre>
</div>

<p>
仔细阅读tcmalloc.cc接口面还发现了下面这些接口非常有意思
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36820;&#22238;&#24403;&#21069;malloc&#20449;&#24687;,&#22312;malloc.h&#37324;&#38754;&#26377;&#23450;&#20041;</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">mallinfo</span> <span style="font-weight: bold;">tc_mallinfo</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>) <span style="font-weight: bold; text-decoration: underline;">__THROW</span> <span style="font-weight: bold;">ATTRIBUTE_SECTION</span>(google_malloc);
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#25351;&#38024;&#23454;&#38469;&#21487;&#29992;&#20869;&#23384;&#22823;&#23567;</span>
<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold;">tc_malloc_size</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">p</span>) <span style="font-weight: bold; text-decoration: underline;">__THROW</span> <span style="font-weight: bold;">ATTRIBUTE_SECTION</span>(google_malloc);
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25171;&#21360;&#24403;&#21069;malloc&#29366;&#24577;</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">tc_malloc_stats</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>) <span style="font-weight: bold; text-decoration: underline;">__THROW</span>  <span style="font-weight: bold;">ATTRIBUTE_SECTION</span>(google_malloc);
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#25913;malloc&#21442;&#25968;,&#22312;malloc.h&#37324;&#38754;&#26377;&#20462;&#25913;&#36873;&#39033;</span>
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">tc_mallopt</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">cmd</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">value</span>) <span style="font-weight: bold; text-decoration: underline;">__THROW</span> <span style="font-weight: bold;">ATTRIBUTE_SECTION</span>(google_malloc);
</pre>
</div>
<p>
可以结合当前的ptmalloc2(glibc.2.3.4)来看看这些接口的行为.了解这些行为主要是对于内存分配器如果出问题的话，那么至少有方法可以了解内部情况.
</p>
</div>
</div>

<div id="outline-container-orgba66fde" class="outline-2">
<h2 id="orgba66fde"><span class="section-number-2">3</span> 全局内存</h2>
<div class="outline-text-2" id="text-3">
<p>
system-alloc.h
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">extern</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">TCMalloc_SystemAlloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> *<span style="font-weight: bold; font-style: italic;">actual_bytes</span>,
                                  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">alignment</span> = 0);
<span style="font-weight: bold;">extern</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">TCMalloc_SystemRelease</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">start</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">length</span>);
</pre>
</div>
<p>
基本可以认为Release部分没有任何操作。对于SystemAlloc底层实现非常巧妙.首先tcmalloc定义了SysAllocator这个接口，然后底层有两个实现：
</p>
<ul class="org-ul">
<li>SbrkSysAllocator.使用sbrk来分配内存</li>
<li>MmapSysAllocator.使用mmap来分配内存</li>
</ul>
<p>
SysAllocator需要实现一个接口void* Alloc(size<sub>t</sub> size, size<sub>t</sub> *actual<sub>size</sub>, size<sub>t</sub> alignment);因为全局只是需要一个这样的对象，
所以这个对象可以静态分配即可.然后定义了一个DefaultSysAllocator允许设置Children.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">sbrk_space</span>[<span style="font-weight: bold;">sizeof</span>(SbrkSysAllocator)];
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">mmap_space</span>[<span style="font-weight: bold;">sizeof</span>(MmapSysAllocator)];
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">default_space</span>[<span style="font-weight: bold;">sizeof</span>(DefaultSysAllocator)];
</pre>
</div>

<p>
在初始化InitSystemAllocators的时候将sbrk<sub>space以及mmap</sub><sub>space作为default</sub><sub>space的两个children</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">MmapSysAllocator</span> *<span style="font-weight: bold; font-style: italic;">mmap</span> = <span style="font-weight: bold;">new</span> (mmap_space) <span style="font-weight: bold; text-decoration: underline;">MmapSysAllocator</span>();
<span style="font-weight: bold; text-decoration: underline;">SbrkSysAllocator</span> *<span style="font-weight: bold; font-style: italic;">sbrk</span> = <span style="font-weight: bold;">new</span> (sbrk_space) <span style="font-weight: bold; text-decoration: underline;">SbrkSysAllocator</span>();
<span style="font-weight: bold; text-decoration: underline;">DefaultSysAllocator</span> *<span style="font-weight: bold; font-style: italic;">sdef</span> = <span style="font-weight: bold;">new</span> (default_space) <span style="font-weight: bold; text-decoration: underline;">DefaultSysAllocator</span>();
<span style="font-weight: bold;">if</span> (kDebugMode &amp;&amp; <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>*) &gt; 4) {
  sdef-&gt;SetChildAllocator(mmap, 0, mmap_name);
  sdef-&gt;SetChildAllocator(sbrk, 1, sbrk_name);
} <span style="font-weight: bold;">else</span> {
  sdef-&gt;SetChildAllocator(sbrk, 0, sbrk_name);
  sdef-&gt;SetChildAllocator(mmap, 1, mmap_name);
}
</pre>
</div>
<p>
实际操作时候都是先sbrk尝试先，然后使用mmap.DefaultAllocator按照children顺序尝试分配，也就意味着首先使用sbrk如果不成功尝试mmap
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; text-decoration: underline;">DefaultSysAllocator</span>::<span style="font-weight: bold;">Alloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> *<span style="font-weight: bold; font-style: italic;">actual_size</span>,
                                 <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">alignment</span>) {
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; kMaxAllocators; i++) {
    <span style="font-weight: bold;">if</span> (!failed_[i] &amp;&amp; allocs_[i] != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">result</span> = allocs_[i]-&gt;Alloc(size, actual_size, alignment);
      <span style="font-weight: bold;">if</span> (result != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
        <span style="font-weight: bold;">return</span> result;
      }
      TCMalloc_MESSAGE(__FILE__, __LINE__, <span style="font-style: italic;">"%s failed.\n"</span>, names_[i]);
      failed_[i] = <span style="font-weight: bold; text-decoration: underline;">true</span>;
    }
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">After both failed, reset "failed_" to false so that a single failed</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">allocation won't make the allocator never work again.</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; kMaxAllocators; i++) {
    failed_[i] = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
}
</pre>
</div>
<p>
可以说系统里面所有使用的内存都是从这个地方分配的，包括thread<sub>cache,page</sub><sub>allocator以及管理对象</sub>。
此外还需要注意的是，因为会有多线程调用这个东西，所以在SystemAlloc之前的话会调用自选锁进行锁定。SpinLockHolder lock<sub>holder</sub>(&amp;spinlock);
</p>
</div>
</div>

<div id="outline-container-org91de354" class="outline-2">
<h2 id="org91de354"><span class="section-number-2">4</span> 管理对象</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>tcmalloc<sub>guard.h</sub></li>
<li>static<sub>vars.h</sub></li>
<li>page<sub>heap</sub><sub>allocator.h</sub></li>
<li>common.h</li>
<li>central<sub>freelist.h</sub></li>
<li>page<sub>heap.h</sub></li>
<li>page<sub>map.h</sub></li>
<li>packed-cache-inl.h</li>
<li>thread<sub>cache.h</sub></li>
</ul>
</div>

<div id="outline-container-orgae134ff" class="outline-3">
<h3 id="orgae134ff"><span class="section-number-3">4.1</span> TCMallocGuard</h3>
<div class="outline-text-3" id="text-4-1">
<p>
tcmalloc<sub>guard.h</sub>
</p>

<p>
TCMallocGuard主要是为了确保在tc<sub>malloc之前所有静态变量都已经完成了初始化</sub>。首先全局存在一个static TCMallocGuard module<sub>enter</sub><sub>exit</sub><sub>hook</sub>;
这个变量来确保静态初始化，但是同时为了防止重复初始化还加了引用计数进行判断
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">tcmallocguard_refcount</span> = 0;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">no lock needed: runs before main()</span>
<span style="font-weight: bold; text-decoration: underline;">TCMallocGuard</span>::<span style="font-weight: bold;">TCMallocGuard</span>() {
  <span style="font-weight: bold;">if</span> (tcmallocguard_refcount++ == 0) {
    ReplaceSystemAlloc();    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">defined in libc_override_*.h // &#36825;&#20010;&#23545;&#20110;Linux&#26469;&#35828;&#27809;&#26377;&#20219;&#20309;&#25805;&#20316;</span>
    tc_free(tc_malloc(1)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#22320;&#26041;&#20010;&#20154;&#35273;&#24471;&#27809;&#26377;&#24517;&#35201;&#65292;&#21487;&#33021;&#21482;&#26159;&#20026;&#20102;&#30475;&#30475;&#26159;&#21542;&#21487;&#20197;&#20877;InitTSD&#20043;&#21069;run&#36215;&#26469;</span>
    <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::InitTSD(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#21270;&#19968;&#19979;tc&#30340;&#32447;&#31243;&#23616;&#37096;&#21464;&#37327;</span>
    tc_free(tc_malloc(1));
    <span style="font-weight: bold;">if</span> (RunningOnValgrind()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;&#20195;&#30721;&#19978;&#30475;&#21487;&#33021;&#26159;&#20174;&#29615;&#22659;&#21464;&#37327;&#37324;&#38754;&#33719;&#21462;&#30340;&#12290;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Let Valgrind uses its own malloc (so don't register our extension).</span>
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; text-decoration: underline;">MallocExtension</span>::Register(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">TCMallocImplementation</span>);
    }
  }
}
</pre>
</div>

<p>
对于释放来说的话也非常简单，可以根据环境变量来选择是否打印统计信息
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">TCMallocGuard</span>::~<span style="font-weight: bold;">TCMallocGuard</span>() {
  <span style="font-weight: bold;">if</span> (--tcmallocguard_refcount == 0) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">env</span> = getenv(<span style="font-style: italic;">"MALLOCSTATS"</span>);
    <span style="font-weight: bold;">if</span> (env != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">level</span> = atoi(env);
      <span style="font-weight: bold;">if</span> (level &lt; 1) level = 1;
      PrintStats(level);
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0cdcd64" class="outline-3">
<h3 id="org0cdcd64"><span class="section-number-3">4.2</span> PageHeapAllocator</h3>
<div class="outline-text-3" id="text-4-2">
<p>
page<sub>heap</sub><sub>allocator.h</sub>
</p>

<p>
如果管理对象预先知道了大小那么可以静态分配使用in-placement new方式完成，但是如果管理对象是动态分配的话，那么如何管理这些对象的分配呢？
答案非常简单使用sample<sub>alloc.所以sample</sub><sub>alloc就是这个分配器知道了每次分配对象的大小</sub>，回收缓存起来挂在free<sub>list上面</sub>，分配首先从free<sub>list尝试分配</sub>，
如果free<sub>list为空的话</sub>，那么久会调用全局内存分配。
</p>

<p>
page<sub>heap</sub><sub>allocator.h里面实现了一个sample</sub><sub>alloc叫做PageHeapAllocator.原理来说非常简单</sub>，这里就不赘述了。需要注意的是每一个节点肯定都是&gt;sizeof(void*)的，
所以每个节点不用分配额外的next指针空间，这个是一个基本上所以写过内存分配器程序员公开的技巧了。另外需要关注的是每次向全局内存空间要的大小是多少
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kAllocIncrement</span> = 128 &lt;&lt; 10; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">128K</span>
</pre>
</div>
<p>
里面还维护了一个inuse()接口表示当前有多少个object正在被使用。
</p>

<p>
另外为了更好的统计管理对象使用的内存，在common.cc里面记录了元信息分配的内存大小
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">metadata_system_bytes_</span> = 0;
<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">MetaDataAlloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span>) {
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">result</span> = TCMalloc_SystemAlloc(bytes, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  <span style="font-weight: bold;">if</span> (result != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    metadata_system_bytes_ += bytes;
  }
  <span style="font-weight: bold;">return</span> result;
}
<span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold;">metadata_system_bytes</span>() { <span style="font-weight: bold;">return</span> metadata_system_bytes_; }
</pre>
</div>
<p>
只要所有的元信息都从MetaDataAlloc这里分配即可。
</p>
</div>
</div>

<div id="outline-container-org2e6f5c1" class="outline-3">
<h3 id="org2e6f5c1"><span class="section-number-3">4.3</span> SizeMap</h3>
<div class="outline-text-3" id="text-4-3">
<p>
common.h
</p>

<p>
SizeMap定义了slab大小，大小到slab编号的映射，一种slab每次分配的多少个pages，一种slab的话在tc和central cache中每次移动多少个对象。
具体定义可以阅读common.h.里面的算法个人觉得还是比较复杂的没有仔细研究。slab的一共有
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#if</span> <span style="font-weight: bold;">defined</span>(TCMALLOC_LARGE_PAGES)
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">kPageShift</span>  = 15;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">kNumClasses</span> = 78;
<span style="font-weight: bold;">#else</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">kPageShift</span>  = 13;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">kNumClasses</span> = 86;
<span style="font-weight: bold;">#endif</span>
</pre>
</div>
<p>
对于我们如果使用大页面的话，32K的话那么有77种slab,否则只有85种。注意这里slab的编号从1开始计算。
</p>

<p>
tcmalloc提供了一个Dump方法可以查看最终这些数值。我们需要和源代码联合编译才有可能看到
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;cstdio&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;src/internal_logging.h&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;src/static_vars.h&gt;</span>

<span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[1024*1024];
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">initialize tcmalloc</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">p</span>=malloc(10);
  free(p);
  <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::<span style="font-weight: bold; text-decoration: underline;">SizeMap</span>* <span style="font-weight: bold; font-style: italic;">sizemap</span>=<span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::<span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap();
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">print aux info</span>
  <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span>=1;i&lt;kNumClasses;i++){
    printf(<span style="font-style: italic;">"SC %d [%d]\n"</span>,i,sizemap-&gt;num_objects_to_move(i));
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">print stats.</span>
  <span style="font-weight: bold; text-decoration: underline;">TCMalloc_Printer</span> <span style="font-weight: bold; font-style: italic;">printer</span>(buf,<span style="font-weight: bold;">sizeof</span>(buf));
  sizemap-&gt;Dump(&amp;printer);
  printf(<span style="font-style: italic;">"%s\n"</span>,buf);
  <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
查看结果是
</p>
<pre class="example">
SC 1 [32]
SC 2 [32]
SC 3 [32]
SC 4 [32]
SC 5 [32]
SC 6 [32]
SC 7 [32]
SC 8 [32]
SC 9 [32]
...

SC   1 [        1 ..        8 ] from     8192 ; 88% maxwaste
SC   2 [        9 ..       16 ] from     8192 ; 44% maxwaste
SC   3 [       17 ..       32 ] from     8192 ; 47% maxwaste
SC   4 [       33 ..       48 ] from     8192 ; 32% maxwaste
SC   5 [       49 ..       64 ] from     8192 ; 23% maxwaste
SC   6 [       65 ..       80 ] from     8192 ; 19% maxwaste
SC   7 [       81 ..       96 ] from     8192 ; 16% maxwaste
....
</pre>
<p>
这个意思就很清楚，对于slab1的对象来说的话，每次会将32个对象在tc(thread cache)和cc(central cache)之间调动。
如果是1-8字节的话那么按照8字节分配，如果分配pages的话那分配8192字节。最大浪费率是88%(8-1)/8.
对于81-96字节的话，那么最大浪费率就是(96-81)/96-16%.
(注意这里打印分配pages的话已经&lt;&lt; kPageShift,如果kPageShift=12的话，8192字节那么相当于2pages)
</p>
</div>
</div>

<div id="outline-container-orgc12dba6" class="outline-3">
<h3 id="orgc12dba6"><span class="section-number-3">4.4</span> Central Cache</h3>
<div class="outline-text-3" id="text-4-4">
<p>
central<sub>freelist.h</sub>
</p>
</div>

<div id="outline-container-org322784c" class="outline-4">
<h4 id="org322784c"><span class="section-number-4">4.4.1</span> Data Structure</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
首先在static里面定义的central<sub>cache是一个数组大小为kNumClasses</sub>，相当于和每一个thread cache里面的slab对应。
数组每个元素是CentralFreeListPadded,在central<sub>freelist.h里面定义的</sub>。阅读CentralFreeListPadded这个结构，就会发现，
实际上这个功能是在CentralFreeList里面的，为了能够进行align进行了padded,还是非常巧妙的
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kFreeListSizeMod64</span>&gt;
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeListPaddedTo</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">pad_</span>[64 - kFreeListSizeMod64];
};

<span style="font-weight: bold;">template</span>&lt;&gt;
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeListPaddedTo</span>&lt;0&gt; : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span> {
};

<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeListPadded</span> : <span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeListPaddedTo</span>&lt;
  <span style="font-weight: bold;">sizeof</span>(CentralFreeList) % 64&gt; {
};
</pre>
</div>
<p>
所以后续的话我们只需要关注CentralFreeList即可。
</p>

<p>
数据结构基本上还是很好理解的:).
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TransferCache is used to cache transfers of</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">sizemap.num_objects_to_move(size_class) back and forth between</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">thread caches and the central cache for a given size class.</span>
  <span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">TCEntry</span> {
    <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">head</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Head of chain of objects.</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">tail</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Tail of chain of objects.</span>
  };
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">A central cache freelist can have anywhere from 0 to kMaxNumTransferEntries</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">slots to put link list chains into.</span>
<span style="font-weight: bold;">#ifdef</span> TCMALLOC_SMALL_BUT_SLOW
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">For the small memory model, the transfer cache is not used.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kMaxNumTransferEntries</span> = 0;
<span style="font-weight: bold;">#else</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Starting point for the the maximum number of entries in the transfer cache.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This actual maximum for a given size class may be lower than this</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">maximum value.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kMaxNumTransferEntries</span> = 64;
<span style="font-weight: bold;">#endif</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This lock protects all the data members.  cached_entries and cache_size_</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">may be looked at without holding the lock.</span>
  <span style="font-weight: bold; text-decoration: underline;">SpinLock</span> <span style="font-weight: bold; font-style: italic;">lock_</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We keep linked lists of empty and non-empty spans.</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span>   <span style="font-weight: bold; font-style: italic;">size_class_</span>;     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">My size class</span>
  <span style="font-weight: bold; text-decoration: underline;">Span</span>     <span style="font-weight: bold; font-style: italic;">empty_</span>;          <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Dummy header for list of empty spans</span>
  <span style="font-weight: bold; text-decoration: underline;">Span</span>     <span style="font-weight: bold; font-style: italic;">nonempty_</span>;       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Dummy header for list of non-empty spans</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span>   <span style="font-weight: bold; font-style: italic;">num_spans_</span>;      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Number of spans in empty_ plus nonempty_</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span>   <span style="font-weight: bold; font-style: italic;">counter_</span>;        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Number of free objects in cache entry</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Here we reserve space for TCEntry cache slots.  Space is preallocated</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">for the largest possible number of entries than any one size class may</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">accumulate.  Not all size classes are allowed to accumulate</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kMaxNumTransferEntries, so there is some wasted space for those size</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">classes.</span>
  <span style="font-weight: bold; text-decoration: underline;">TCEntry</span> <span style="font-weight: bold; font-style: italic;">tc_slots_</span>[kMaxNumTransferEntries];

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Number of currently used cached entries in tc_slots_.  This variable is</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">updated under a lock but can be read without one.</span>
  <span style="font-weight: bold; text-decoration: underline;">int32_t</span> <span style="font-weight: bold; font-style: italic;">used_slots_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#20351;&#29992;&#30340;tc entries.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The current number of slots for this size class.  This is an</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">adaptive value that is increased if there is lots of traffic</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">on a given size class.</span>
  <span style="font-weight: bold; text-decoration: underline;">int32_t</span> <span style="font-weight: bold; font-style: italic;">cache_size_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;&#20801;&#35768;&#30340;&#26368;&#22823;&#30340;tc entries.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Maximum size of the cache for a given size class.</span>
  <span style="font-weight: bold; text-decoration: underline;">int32_t</span> <span style="font-weight: bold; font-style: italic;">max_cache_size_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26368;&#22823;&#20801;&#35768;&#22810;&#23569;&#20010;tc entries.</span>
}
</pre>
</div>

<p>
CentralFreeList的接口非常少
</p>
<ul class="org-ul">
<li>void Init(size<sub>t</sub> cl); // 初始化,cl表示自己是第几个class</li>
<li>void InsertRange(void *start, void *end, int N); // 回收部分objects.</li>
<li>int RemoveRange(void **start, void **end, int N); // 分配部分objects.</li>
<li>length // 在cache里面存在多少个free objects(不包含transfer cache)</li>
<li>tc<sub>length</sub> // transfer cache里面包含多少free objects.</li>
<li>OverheadBytes // 因为内部碎片造成的额外开销</li>
</ul>
<p>
因为cc是被全局操作的，所以这些接口在实际操作的时候内部都会首先尝试加上自选锁。很明显cc里面使用了free list链表结构管理这些free object.
之前说过ptmalloc2会有这么一个问题，就是如果局部线程分配过多的话没有机制将内存返回给主区域。而tcmalloc解决了这个问题。
对于每一个slab的tc返回的对象个数都是固定的，如果cc可以将这个返回的部分特殊处理的话，那么下次tc还需要这个部分的话，
那么就可以很快地进行分配，否则需要遍历如果freelist不够的话那么还需要从pageheap里面进行切片。而这个部分就叫做transfer cache.:)
了解了这些之后就可以看各个接口实现了。
</p>
</div>
</div>

<div id="outline-container-org11f5565" class="outline-4">
<h4 id="org11f5565"><span class="section-number-4">4.4.2</span> Init</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
init主要是计算了tc(transfer cache)的max<sub>cache</sub><sub>size以及cache</sub><sub>size,然后初始化了字段</sub>。
我们这里暂时不关注empty以及nonempty这两个字段的数据结构
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span>::<span style="font-weight: bold;">Init</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">cl</span>) {
  size_class_ = cl;
  <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_Init(&amp;empty_);
  <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_Init(&amp;nonempty_);
  num_spans_ = 0;
  counter_ = 0;

  max_cache_size_ = kMaxNumTransferEntries;
<span style="font-weight: bold;">#ifdef</span> TCMALLOC_SMALL_BUT_SLOW
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Disable the transfer cache for the small footprint case.</span>
  cache_size_ = 0;
<span style="font-weight: bold;">#else</span>
  cache_size_ = 16;
<span style="font-weight: bold;">#endif</span>
  <span style="font-weight: bold;">if</span> (cl &gt; 0) {
    <span style="font-weight: bold; text-decoration: underline;">int32_t</span> <span style="font-weight: bold; font-style: italic;">bytes</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;ByteSizeForClass(cl);
    <span style="font-weight: bold; text-decoration: underline;">int32_t</span> <span style="font-weight: bold; font-style: italic;">objs_to_move</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;num_objects_to_move(cl);
    max_cache_size_ = (min)(max_cache_size_,
                          (max)(1, (1024 * 1024) / (bytes * objs_to_move)));
    cache_size_ = (min)(cache_size_, max_cache_size_);
  }
  used_slots_ = 0;
  ASSERT(cache_size_ &lt;= max_cache_size_);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf01bc66" class="outline-4">
<h4 id="orgf01bc66"><span class="section-number-4">4.4.3</span> InsertRange</h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
这个接口就是为了回收[start,end]并且长度为N objects的内存链。首先注意它加了自选锁确保了线程安全。
然后有一个逻辑就是判断是否可以进入tc,如果不允许进入tc的话那么挂到链上去。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span>::<span style="font-weight: bold;">InsertRange</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">start</span>, <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">end</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">N</span>) {
  SpinLockHolder <span style="font-weight: bold; text-decoration: underline;">h</span>(&amp;<span style="font-weight: bold; font-style: italic;">lock_</span>);
  <span style="font-weight: bold;">if</span> (N == <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;num_objects_to_move(size_class_) &amp;&amp;
    MakeCacheSpace()) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#27809;&#26377;&#30475;&#25026;MakeCacheSpace&#37324;&#38754;&#19968;&#20010;&#36923;&#36753;&#65292;&#25105;&#33258;&#24049;&#35273;&#24471;&#26159;&#26080;&#20851;&#32039;&#35201;&#30340;&#12290;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;&#30475;&#19978;&#21435;&#20687;&#26159;&#25910;&#32553;&#20854;&#20182;&#30340;slab cc(EvictRandomSizeClass).</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#25105;&#20204;&#21487;&#20197;&#31616;&#21333;&#22320;&#35748;&#20026;&#65292;&#23427;&#23601;&#26159;&#22312;&#35745;&#31639;tc_slots&#37324;&#38754;&#26159;&#21542;&#26377;slot&#21487;&#20197;&#20998;&#37197;.</span>
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">slot</span> = used_slots_++;
    ASSERT(slot &gt;=0);
    ASSERT(slot &lt; max_cache_size_);
    <span style="font-weight: bold; text-decoration: underline;">TCEntry</span> *<span style="font-weight: bold; font-style: italic;">entry</span> = &amp;tc_slots_[slot]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#20998;&#37197;&#25104;&#21151;&#30340;&#35805;&#65292;&#37027;&#20040;&#30452;&#25509;&#25346;&#36733;.</span>
    entry-&gt;head = start;
    entry-&gt;tail = end;
    <span style="font-weight: bold;">return</span>;
  }
  ReleaseListToSpans(start); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19981;&#20801;&#35768;&#25346;&#21040;tc&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#38656;&#35201;&#21333;&#29420;&#22788;&#29702;.</span>
}
</pre>
</div>

<p>
回收到tc这个逻辑非常简单，然后看看ReleaseListToSpans这个逻辑。大致逻辑就是遍历start知道end,
然后对于每一个object调用ReleaseToSpans单独进行处理。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span>::<span style="font-weight: bold;">ReleaseToSpans</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">object</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span> = MapObjectToSpan(object); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;object&#26144;&#23556;&#21040;span</span>
  ASSERT(span != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  ASSERT(span-&gt;refcount &gt; 0);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If span is empty, move it to non-empty list</span>
  <span style="font-weight: bold;">if</span> (span-&gt;objects == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;span&#19978;&#38754;&#27809;&#26377;&#20219;&#20309;free objects&#30340;&#35805;.</span>
    <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_Remove(span); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#23558;span&#20174;&#21407;&#26469;&#25346;&#36733;&#38142;&#34920;&#21024;&#38500;(empty).</span>
    <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_Prepend(&amp;nonempty_, span); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25346;&#36733;&#21040;&#36825;&#20010;cc&#30340;nonempty&#38142;&#34920;&#19978;.</span>
    Event(span, <span style="font-style: italic;">'N'</span>, 0);
  }

  counter_++; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24403;&#21069;free objects&#22686;&#21152;&#20102;</span>
  span-&gt;refcount--; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;span&#30340;ref count&#20943;&#23569;&#20102;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">span refcount&#34920;&#31034;&#37324;&#38754;&#26377;&#22810;&#23569;&#20010;objects&#20998;&#37197;&#20986;&#21435;&#20102;.</span>
  <span style="font-weight: bold;">if</span> (span-&gt;refcount == 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;==0&#30340;&#35805;&#65292;&#37027;&#20040;&#35828;&#26126;&#36825;&#20010;span&#21487;&#20197;&#22238;&#25910;&#20102;.</span>
    Event(span, <span style="font-style: italic;">'#'</span>, 0);
    counter_ -= ((span-&gt;length&lt;&lt;kPageShift) /
                 <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;ByteSizeForClass(span-&gt;sizeclass));
    <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_Remove(span);
--num_spans_;

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Release central list lock while operating on pageheap</span>
    lock_.Unlock();
    {
      <span style="font-weight: bold; text-decoration: underline;">SpinLockHolder</span> <span style="font-weight: bold; font-style: italic;">h</span>(<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap_lock());
      <span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;Delete(span); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;span&#22238;&#25910;pageheap&#37324;&#38754;&#21435;&#65292;&#36825;&#20010;&#22320;&#26041;&#21487;&#33021;&#20250;&#36827;&#34892;&#20869;&#23384;&#21512;&#24182;</span>
    }
    lock_.Lock();
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#23601;&#23558;&#36825;&#20010;object&#25346;&#22312;span&#38142;&#19978;.</span>
    *(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>**&gt;(object)) = span-&gt;objects;
    span-&gt;objects = object;
  }
}
</pre>
</div>
<p>
这里有一个最重要的问题就是MapObjectToSpan,object是如何映射到span的。这里我们首先可以大致说一下，
就是tcmalloc因为是按照page来分配的，所以如果知道地址的话，那么其实就知道于第几个页。而span可以管理多个页，
这样的话就可以知道这个页是哪个span来管理的了。具体代码的话会在span管理部分说明。
</p>
</div>
</div>

<div id="outline-container-orgb6ac97e" class="outline-4">
<h4 id="orgb6ac97e"><span class="section-number-4">4.4.4</span> RemoveRange</h4>
<div class="outline-text-4" id="text-4-4-4">
<p>
这个接口就是为了尝试分配N个objects对象，然后将首地址尾地址给start和end.同样内部逻辑会判断是否可以从tc
中直接取出，如果可以取出的话那么分配就非常快。注意函数开始也尝试加锁了。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span>::<span style="font-weight: bold;">RemoveRange</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> **<span style="font-weight: bold; font-style: italic;">start</span>, <span style="font-weight: bold; text-decoration: underline;">void</span> **<span style="font-weight: bold; font-style: italic;">end</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">N</span>) {
  ASSERT(N &gt; 0);
  lock_.Lock();
  <span style="font-weight: bold;">if</span> (N == <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;num_objects_to_move(size_class_) &amp;&amp;
      used_slots_ &gt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#21487;&#20197;&#30452;&#25509;&#20174;tc&#37324;&#38754;&#20998;&#37197;.</span>
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">slot</span> = --used_slots_;
    ASSERT(slot &gt;= 0);
    <span style="font-weight: bold; text-decoration: underline;">TCEntry</span> *<span style="font-weight: bold; font-style: italic;">entry</span> = &amp;tc_slots_[slot];
    *start = entry-&gt;head;
    *end = entry-&gt;tail;
    lock_.Unlock();
    <span style="font-weight: bold;">return</span> N;
  }

  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">result</span> = 0;
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">head</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">tail</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO: Prefetch multiple TCEntries?</span>
  tail = FetchFromSpansSafe(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36923;&#36753;&#26159;&#39318;&#20808;&#25918;&#22312;&#23614;&#37096;,&#28982;&#21518;&#19981;&#26029;&#22320;&#22312;&#22836;&#37096;&#25340;&#25509;.</span>
  <span style="font-weight: bold;">if</span> (tail != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    SLL_SetNext(tail, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    head = tail;
    result = 1;
    <span style="font-weight: bold;">while</span> (result &lt; N) {
      <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">t</span> = FetchFromSpans();
      <span style="font-weight: bold;">if</span> (!t) <span style="font-weight: bold;">break</span>;
      SLL_Push(&amp;head, t);
      result++;
    }
  }
  lock_.Unlock();
  *start = head;
  *end = tail;
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>

<p>
其中FetchFromSpanSafe逻辑也比较简单，就是
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span>::<span style="font-weight: bold;">FetchFromSpansSafe</span>() {
  <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">t</span> = FetchFromSpans();
  <span style="font-weight: bold;">if</span> (!t) {
    Populate(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23581;&#35797;&#36801;&#31227;</span>
    t = FetchFromSpans();
  }
  <span style="font-weight: bold;">return</span> t;
}
</pre>
</div>

<p>
首先我们要看懂FetchFromSpans()逻辑，才能够清楚什么情况下面需要调用Populate
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span>::<span style="font-weight: bold;">FetchFromSpans</span>() {
  <span style="font-weight: bold;">if</span> (<span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_IsEmpty(&amp;nonempty_)) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;span&#37324;&#38754;&#37117;&#31354;&#20102;&#30340;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span> = nonempty_.next;

  ASSERT(span-&gt;objects != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  span-&gt;refcount++;
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">result</span> = span-&gt;objects; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#23601;&#20250;&#20174;span&#37324;&#38754;&#20998;&#37197;object.</span>
  span-&gt;objects = *(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>**&gt;(result));
  <span style="font-weight: bold;">if</span> (span-&gt;objects == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Move to empty list</span>
    <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_Remove(span);
    <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_Prepend(&amp;empty_, span);
    Event(span, <span style="font-style: italic;">'E'</span>, 0);
  }
  counter_--;
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org52c6d71" class="outline-4">
<h4 id="org52c6d71"><span class="section-number-4">4.4.5</span> Populate</h4>
<div class="outline-text-4" id="text-4-4-5">
<p>
基本上了解了调用Populate的时机，是如果cc里面nonempty里面没有span的话。代码有点长.
这里为了减少阻塞的部分，首先进行解锁然后让全局进行分配。只是针对局部操作没有任何问题。
最后加入nonempty的部分的话这个部分需要加锁。非常巧妙。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">CentralFreeList</span>::<span style="font-weight: bold;">Populate</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Release central list lock while operating on pageheap</span>
  lock_.Unlock();  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#38656;&#35201;&#35745;&#31639;&#20986;&#25105;&#20204;&#38656;&#35201;&#22810;&#23569;&#20010;pages</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">npages</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;class_to_pages(size_class_);

  <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span>;
  {
    <span style="font-weight: bold; text-decoration: underline;">SpinLockHolder</span> <span style="font-weight: bold; font-style: italic;">h</span>(<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap_lock());
    span = <span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;New(npages); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20998;&#37197;&#21040;pages&#24471;&#21040;span.</span>
    <span style="font-weight: bold;">if</span> (span) <span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;RegisterSizeClass(span, size_class_);
  }
  <span style="font-weight: bold;">if</span> (span == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    MESSAGE(<span style="font-style: italic;">"tcmalloc: allocation failed"</span>, npages &lt;&lt; kPageShift);
    lock_.Lock();
    <span style="font-weight: bold;">return</span>;
  }
  ASSERT(span-&gt;length == npages);
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; npages; i++) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;span&#21644;size_class&#20043;&#38388;&#20851;&#32852;&#36215;&#26469;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24212;&#35813;&#26159;&#20026;&#20102;&#21518;&#38754;&#26597;&#25214;&#26041;&#20415;&#65292;&#20294;&#26159;&#29616;&#22312;&#36824;&#19981;&#30693;&#36947;&#26377;&#20160;&#20040;&#29992;&#36884;&#12290;&#20294;&#26159;&#19981;&#24433;&#21709;&#38405;&#35835;.</span>
    <span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;CacheSizeClass(span-&gt;start + i, size_class_);
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#36825;&#20010;span&#37324;&#38754;&#30340;&#25152;&#26377;objects&#32452;&#32455;&#25104;&#38142;&#34920;&#24418;&#24335;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Split the block into pieces and add to the free-list</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO: coloring of objects to avoid cache conflicts?</span>
  <span style="font-weight: bold; text-decoration: underline;">void</span>** <span style="font-weight: bold; font-style: italic;">tail</span> = &amp;span-&gt;objects;
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">ptr</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">char</span>*&gt;(span-&gt;start &lt;&lt; kPageShift);
  <span style="font-weight: bold; text-decoration: underline;">char</span>* <span style="font-weight: bold; font-style: italic;">limit</span> = ptr + (npages &lt;&lt; kPageShift);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;ByteSizeForClass(size_class_);
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">num</span> = 0;
  <span style="font-weight: bold;">while</span> (ptr + size &lt;= limit) {
    *tail = ptr;
    tail = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>**&gt;(ptr);
    ptr += size;
    num++;
  }
  ASSERT(ptr &lt;= limit);
  *tail = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  span-&gt;refcount = 0; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No sub-object in use yet</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20010;span&#21152;&#20837;nonempty&#38142;&#34920;&#30340;&#35805;&#38656;&#35201;&#21152;&#38145;&#12290;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Add span to list of non-empty spans</span>
  lock_.Lock();
  <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_Prepend(&amp;nonempty_, span);
  ++num_spans_;
  counter_ += num;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org089f414" class="outline-3">
<h3 id="org089f414"><span class="section-number-3">4.5</span> PageHeap</h3>
<div class="outline-text-3" id="text-4-5">
<p>
page<sub>heap.h</sub>
</p>
</div>

<div id="outline-container-org02128f2" class="outline-4">
<h4 id="org02128f2"><span class="section-number-4">4.5.1</span> Data Structure</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
PageHeap是在page<sub>heap.h里面定义的</sub>，主要是用来分配page的。对于PageHeap结构还是比较复杂的.阅读tcmalloc文档也会发现，
管理page的方法和cc是一样的，也是按照page大小做成数组。每个数组的结构是这样的
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We segregate spans of a given size into two circular linked</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lists: one for normal spans, and one for spans whose memory</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">has been returned to the system.</span>
<span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">SpanList</span> {
  <span style="font-weight: bold; text-decoration: underline;">Span</span>        <span style="font-weight: bold; font-style: italic;">normal</span>;
  <span style="font-weight: bold; text-decoration: underline;">Span</span>        <span style="font-weight: bold; font-style: italic;">returned</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20854;&#23454;&#23545;&#20110;&#36825;&#20010;&#37096;&#20998;&#27809;&#26377;&#24517;&#35201;&#21306;&#20998;&#30340;&#65292;&#22240;&#20026;&#20195;&#30721;&#37324;&#38754;&#22823;&#37096;&#20998;&#37117;&#26159;&#25346;&#22312;normal&#36825;&#20010;&#38142;&#19978;&#30340;&#12290;</span>
};

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">List of free spans of length &gt;= kMaxPages</span>
<span style="font-weight: bold; text-decoration: underline;">SpanList</span> <span style="font-weight: bold; font-style: italic;">large_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23545;&#20110;&gt;=kMaxPages&#30340;&#39029;&#38754;&#21333;&#29420;&#32500;&#25252;&#19968;&#20010;free list.</span>

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Array mapping from span length to a doubly linked list of free spans</span>
<span style="font-weight: bold; text-decoration: underline;">SpanList</span> <span style="font-weight: bold; font-style: italic;">free_</span>[kMaxPages]; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38024;&#23545;&#27599;&#20010;&#39029;&#38754;&#22823;&#23567;&#20570;&#30340;free list.</span>
</pre>
</div>
<p>
span的状态只有三种，一种是IN<sub>USE表示正在被使用</sub>，一种表示ON<sub>NORMAL</sub><sub>FREELIST表示放在了normal</sub> freelist上面。
另外一种是ON<sub>RETURNED</sub><sub>FREELIST表示放在returned</sub> freelist上面。这里简单地说明一下normal freelist与returned freelist差别。
normal freelist是普通的回收进行缓存起来，而returned freelist表示已经完全unmmap回到系统内存部分了。不过因为实际并没有交回给系统内存，
所以这两个仅仅是概念上面的差别.
</p>


<p>
另外在PageHeap里面还定义了如何通过PageID查找到Span这个结构，使用了两种方式，一种是Cache,另外一种是radix tree(32位是另外一个结构). 这个会在下面分析
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Selector class -- general selector uses 3-level map</span>
<span style="font-weight: bold;">template</span> &lt;<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">BITS</span>&gt; <span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">MapSelector</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">TCMalloc_PageMap3</span>&lt;BITS-kPageShift&gt; <span style="font-weight: bold; text-decoration: underline;">Type</span>;
  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">PackedCache</span>&lt;BITS-kPageShift, <span style="font-weight: bold; text-decoration: underline;">uint64_t</span>&gt; <span style="font-weight: bold; text-decoration: underline;">CacheType</span>;
};

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Pick the appropriate map and cache types based on pointer size</span>
  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">MapSelector</span>&lt;kAddressBits&gt;::<span style="font-weight: bold; text-decoration: underline;">Type</span> <span style="font-weight: bold; text-decoration: underline;">PageMap</span>;
  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">MapSelector</span>&lt;kAddressBits&gt;::<span style="font-weight: bold; text-decoration: underline;">CacheType</span> <span style="font-weight: bold; text-decoration: underline;">PageMapCache</span>;
  <span style="font-weight: bold; text-decoration: underline;">PageMap</span> <span style="font-weight: bold; font-style: italic;">pagemap_</span>;
  <span style="font-weight: bold;">mutable</span> <span style="font-weight: bold; text-decoration: underline;">PageMapCache</span> <span style="font-weight: bold; font-style: italic;">pagemap_cache_</span>;
</pre>
</div>
<p>
其中kAddressBits的定义在common.h
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#if</span> <span style="font-weight: bold;">defined</span> __x86_64__
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">All current and planned x86_64 processors only look at the lower 48 bits</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">in virtual to physical address translation.  The top 16 are thus unused.</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO(rus): Under what operating systems can we increase it safely to 17?</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This lets us use smaller page maps.  On first allocation, a 36-bit page map</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">uses only 96 KB instead of the 4.5 MB used by a 52-bit page map.</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kAddressBits</span> = (<span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>*) &lt; 8 ? (8 * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>*)) : 48); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">__x86_64__&#23601;&#26159;64&#20301;</span>
<span style="font-weight: bold;">#else</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kAddressBits</span> = 8 * <span style="font-weight: bold;">sizeof</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>*);
<span style="font-weight: bold;">#endif</span>
</pre>
</div>

<p>
对于PageHeap比较重要的接口包括下面这些：
</p>
<ul class="org-ul">
<li>Span* New(Length n); // 分配n个pages并且返回Span对象</li>
<li>void Delete(Span* span); // 删除Span对象管理的内存</li>
<li>void RegisterSizeClass(Span* span, size<sub>t</sub> sc); // 注册这个span对象管理的slab大小多少(0表示不是用于分配小内存)</li>
<li>Span* Split(Span* span, Length n); // 将当前的span切分，一个管理n个页面的span,一个是剩余的。</li>
<li>inline Span* GetDescriptor(PageID p) const //根据PageID得到管理这个Page的Span对象</li>
<li>void Dump(TCMalloc<sub>Printer</sub>* out); // Dump出PageHeap信息</li>
<li>bool GetNextRange(PageID start, base::MallocRange* r); // 如果page heap管理了&gt;=start的span,那么返回这个信息</li>
<li>Length ReleaseAtLeastNPages(Length num<sub>pages</sub>); // 尝试至少释放num<sub>pages个页面</sub></li>
<li>size<sub>t</sub> GetSizeClassIfCached(PageID p) // 在cache中返回这个page id对应的slab class</li>
<li>void CacheSizeClass(PageID p, size<sub>t</sub> cl) // 在cache中存放page id对应的slab class.</li>
</ul>
<p>
这里有一个点可能有疑问，就是为什么span需要上面标记slab class.原因非常简单，就是如果用户在释放内存的时候，根据ptr查找到对应的span.
然后肯定想知道这个ptr到底应该如何归还，本身带有多少内存。此外还需要注意的是，对于page来说的话，一共管理了(kMaxPages)种页面大小。
tcmalloc代码里面kMaxPages==1 &lt;&lt; (20- kPageShift) 相同于有256种页面。但是最后一种页面大小的话可以超过255 pages,这样才可以用于分配大内存。
</p>
</div>
</div>

<div id="outline-container-org9983943" class="outline-4">
<h4 id="org9983943"><span class="section-number-4">4.5.2</span> New</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
New的逻辑非常简单，首先会尝试在free list里面查找，如果没有的话在lage free list里面查找，不行的话尝试要更多的内存，然后重试。
需要注意的是，因为这个是一个全局的操作，所以前面都会加上自选锁 SpinLockHolder h(Static::pageheap<sub>lock</sub>());
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">New</span>(<span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  ASSERT(Check());
  ASSERT(n &gt; 0);

  <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">result</span> = SearchFreeAndLargeLists(n);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">free list&#28982;&#21518;&#22312;large&#37324;&#38754;&#26597;&#25214;</span>
  <span style="font-weight: bold;">if</span> (result != <span style="font-weight: bold; text-decoration: underline;">NULL</span>)
    <span style="font-weight: bold;">return</span> result;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Grow the heap and try again.</span>
  <span style="font-weight: bold;">if</span> (!GrowHeap(n)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#34892;&#30340;&#35805;&#23581;&#35797;&#20998;&#37197;&#26356;&#22810;&#20869;&#23384;</span>
    ASSERT(Check());
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }
  <span style="font-weight: bold;">return</span> SearchFreeAndLargeLists(n); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#37325;&#26032;&#23581;&#35797;&#20998;&#37197;</span>
}
</pre>
</div>

<p>
SearchFreeAndLargeLists相对来说还是比较简单的，但是里面Carve这个需要单独来看
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">SearchFreeAndLargeLists</span>(<span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  ASSERT(Check());
  ASSERT(n &gt; 0);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Find first size &gt;= n that has a non-empty list</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">s</span> = n; s &lt; kMaxPages; s++) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36941;&#21382;&#25152;&#26377;&#30340;Pages&#30475;&#30475;&#26159;&#21542;&#26377;&#21512;&#36866;&#30340;&#12290;</span>
    <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">ll</span> = &amp;free_[s].normal;
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we're lucky, ll is non-empty, meaning it has a suitable span.</span>
    <span style="font-weight: bold;">if</span> (!DLL_IsEmpty(ll)) {
      ASSERT(ll-&gt;next-&gt;location == <span style="font-weight: bold; text-decoration: underline;">Span</span>::ON_NORMAL_FREELIST);
      <span style="font-weight: bold;">return</span> Carve(ll-&gt;next, n); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26377;&#21512;&#36866;&#30340;&#35805;&#65292;&#37027;&#20040;&#21487;&#33021;&#38656;&#35201;&#20999;&#21106;&#19968;&#19979;,&#20174;&#37324;&#38754;&#20999;&#21106;&#20986;n pages&#20986;&#26469;</span>
    }
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Alternatively, maybe there's a usable returned span.</span>
    ll = &amp;free_[s].returned;
    <span style="font-weight: bold;">if</span> (!DLL_IsEmpty(ll)) {
      ASSERT(ll-&gt;next-&gt;location == <span style="font-weight: bold; text-decoration: underline;">Span</span>::ON_RETURNED_FREELIST);
      <span style="font-weight: bold;">return</span> Carve(ll-&gt;next, n);
    }
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No luck in free lists, our last chance is in a larger class.</span>
  <span style="font-weight: bold;">return</span> AllocLarge(n);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">May be NULL // &#22914;&#26524;&#27809;&#26377;&#20998;&#37197;&#25104;&#21151;&#30340;&#35805;&#37027;&#20040;&#20174;AllocLarge&#37324;&#38754;&#20998;&#37197;</span>
}
</pre>
</div>
<p>
对于AllocLarge部分的话非常简单，就是使用最佳匹配算法。完了之后调用Carve同样进行切割。这里就不贴出代码详细分析。
</p>
</div>
</div>

<div id="outline-container-orgeaab645" class="outline-4">
<h4 id="orgeaab645"><span class="section-number-4">4.5.3</span> Carve</h4>
<div class="outline-text-4" id="text-4-5-3">
<p>
我们看看Carve代码，然后在里面的话会稍微粗略地提到pagemap管理span对象的细节
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">Carve</span>(<span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span>, <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  ASSERT(n &gt; 0);
  ASSERT(span-&gt;location != <span style="font-weight: bold; text-decoration: underline;">Span</span>::IN_USE);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">old_location</span> = span-&gt;location;
  RemoveFromFreeList(span); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;freelist&#37324;&#38754;&#21024;&#38500;&#65292;&#21516;&#26102;&#35760;&#24405;&#20449;&#24687;&#20063;&#20250;&#26356;&#25913;&#12290;</span>
  span-&gt;location = <span style="font-weight: bold; text-decoration: underline;">Span</span>::IN_USE; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20462;&#25913;&#19968;&#19979;location.</span>
  Event(span, <span style="font-style: italic;">'A'</span>, n);

  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">extra</span> = span-&gt;length - n;
  ASSERT(extra &gt;= 0);
  <span style="font-weight: bold;">if</span> (extra &gt; 0) {
    <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">leftover</span> = NewSpan(span-&gt;start + n, extra); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;span&#23545;&#35937;</span>
    leftover-&gt;location = old_location; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#26032;&#30340;&#23545;&#35937;&#37324;&#38754;&#23384;&#25918;&#21040;&#26159;&#21407;&#26469;location.</span>
    Event(leftover, <span style="font-style: italic;">'S'</span>, extra);
    RecordSpan(leftover); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#21097;&#20313;&#30340;span&#35760;&#24405;&#19979;&#26469;&#24182;&#19988;&#25554;&#20837;&#21040;free list&#37324;&#38754;.</span>
    PrependToFreeList(leftover);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Skip coalescing - no candidates possible</span>
    span-&gt;length = n;
    pagemap_.set(span-&gt;start + n - 1, span); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21516;&#26102;&#26631;&#35760;span&#31649;&#29702;&#30340;&#33539;&#22260;.</span>
  }
  ASSERT(Check());
  <span style="font-weight: bold;">return</span> span;
}
</pre>
</div>

<p>
逻辑可以说非常简单，但是如果之前看过文档的话需要知道这里面pagemap为什么需要set.
非常简单，如果span管理的是[p..q]的范围的话，那么在pagemap里面只需要记录(p,span),(q,span).
这样如果有一个span回收的话，那么在pagemap里面查找p-1和q+1的span,然后尝试合并。非常精巧。
所以在RecordSpan里面很明显就是需要设置前后的边界
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">RecordSpan</span>(<span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span>) {
  pagemap_.set(span-&gt;start, span); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#26102;span&#24320;&#22987;</span>
  <span style="font-weight: bold;">if</span> (span-&gt;length &gt; 1) {
    pagemap_.set(span-&gt;start + span-&gt;length - 1, span); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35774;&#32622;span&#32467;&#26463;</span>
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org11a6555" class="outline-4">
<h4 id="org11a6555"><span class="section-number-4">4.5.4</span> GrowHeap</h4>
<div class="outline-text-4" id="text-4-5-4">
<p>
GrowHeap就是需要尝试从系统中拿出更多的内存出来然后好做切分，满足本次allocate n pages的请求。
GrowHeap里面有一些策略
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#23601;&#26159;&#30456;&#24403;&#20110;&#20801;&#35768;&#20998;&#37197;&#30340;&#26368;&#22823;Pages</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">kMaxValidPages</span> = (~<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Length</span>&gt;(0)) &gt;&gt; kPageShift;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kMinSystemAlloc</span> = kMaxPages; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992;GrowHeap&#26368;&#23567;&#30340;&#39029;&#25968;</span>

<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">GrowHeap</span>(<span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  ASSERT(kMaxPages &gt;= kMinSystemAlloc);
  <span style="font-weight: bold;">if</span> (n &gt; kMaxValidPages) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">ask</span> = (n&gt;kMinSystemAlloc) ? n : <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Length</span>&gt;(kMinSystemAlloc); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20250;&#21028;&#26029;&#26159;&#21542;&#36229;&#36807;&#65292;&#22914;&#26524;&#27809;&#26377;&#36229;&#36807;&#30340;&#35805;&#65292;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#25353;&#29031;kMinSystemAlloc&#20998;&#37197;</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">actual_size</span>;
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span> = TCMalloc_SystemAlloc(ask &lt;&lt; kPageShift, &amp;actual_size, kPageSize);
  <span style="font-weight: bold;">if</span> (ptr == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold;">if</span> (n &lt; ask) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Try growing just "n" pages</span>
      ask = n;
      ptr = TCMalloc_SystemAlloc(ask &lt;&lt; kPageShift, &amp;actual_size, kPageSize); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;ask&#20998;&#37197;&#19981;&#20102;&#65292;&#37027;&#20040;&#23581;&#35797;&#20998;&#37197;n</span>
    }
    <span style="font-weight: bold;">if</span> (ptr == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  ask = actual_size &gt;&gt; kPageShift;
  RecordGrowth(ask &lt;&lt; kPageShift);

  <span style="font-weight: bold; text-decoration: underline;">uint64_t</span> <span style="font-weight: bold; font-style: italic;">old_system_bytes</span> = stats_.system_bytes;
  stats_.system_bytes += (ask &lt;&lt; kPageShift);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">PageID</span> <span style="font-weight: bold; font-style: italic;">p</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uintptr_t</span>&gt;(ptr) &gt;&gt; kPageShift;
  ASSERT(p &gt; 0);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we have already a lot of pages allocated, just pre allocate a bunch of</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">memory for the page map. This prevents fragmentation by pagemap metadata</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">when a program keeps allocating and freeing large blocks.</span>

  <span style="font-weight: bold; font-style: italic;">//  </span><span style="font-weight: bold; font-style: italic;">static const size_t kPageMapBigAllocationThreshold = 128 &lt;&lt; 20;(128MB)</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#22320;&#26041;&#21028;&#26029;&#65292;&#36825;&#27425;&#20998;&#37197;&#26159;&#19981;&#26159;&#24050;&#32463;&#36234;&#36807;&#20102;&#19968;&#20010;threshold</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36234;&#36807;&#30340;&#35805;&#65292;&#37027;&#20040;&#24847;&#21619;&#30528;pagemap&#37324;&#38754;&#21487;&#33021;&#38656;&#35201;&#20998;&#37197;&#26356;&#22810;&#30340;&#20869;&#23384;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#26159;&#23545;&#20110;64&#20301;&#26469;&#35828;&#30340;&#35805;&#65292;&#37324;&#38754;&#27809;&#26377;&#20219;&#20309;&#36923;&#36753;.</span>
  <span style="font-weight: bold;">if</span> (old_system_bytes &lt; kPageMapBigAllocationThreshold
      &amp;&amp; stats_.system_bytes &gt;= kPageMapBigAllocationThreshold) {
    pagemap_.PreallocateMoreMemory();
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Make sure pagemap_ has entries for all of the new pages.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Plus ensure one before and one after so coalescing code</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">does not need bounds-checking.</span>
  <span style="font-weight: bold;">if</span> (pagemap_.Ensure(p-1, ask+2)) {   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;&#38656;&#35201;&#25554;&#20837;&#26032;&#30340;span,&#25152;&#20197;&#24517;&#39035;&#30830;&#20445;&#36825;&#20010;pagemap&#30830;&#23454;&#23384;&#22312;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Pretend the new area is allocated and then Delete() it to cause</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">any necessary coalescing to occur.</span>
    <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span> = NewSpan(p, ask);
    RecordSpan(span);
    Delete(span); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#36825;&#20010;Span&#36820;&#22238;&#32473;large_&#37324;&#31561;&#24453;&#19979;&#27425;&#20998;&#37197;</span>
    ASSERT(Check());
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We could not allocate memory within "pagemap_"</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO: Once we can return memory to the system, return the new span</span>
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org441c9ba" class="outline-4">
<h4 id="org441c9ba"><span class="section-number-4">4.5.5</span> Delete</h4>
<div class="outline-text-4" id="text-4-5-5">
<p>
Delete逻辑非常简单
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">Delete</span>(<span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span>) {
  ASSERT(Check());
  ASSERT(span-&gt;location == <span style="font-weight: bold; text-decoration: underline;">Span</span>::IN_USE);
  ASSERT(span-&gt;length &gt; 0);
  ASSERT(GetDescriptor(span-&gt;start) == span);
  ASSERT(GetDescriptor(span-&gt;start + span-&gt;length - 1) == span);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">n</span> = span-&gt;length;
  span-&gt;sizeclass = 0;
  span-&gt;sample = 0;
  span-&gt;location = <span style="font-weight: bold; text-decoration: underline;">Span</span>::ON_NORMAL_FREELIST;
  Event(span, <span style="font-style: italic;">'D'</span>, span-&gt;length);
  MergeIntoFreeList(span);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Coalesces if possible // &#20250;&#23581;&#35797;&#36827;&#34892;&#21512;&#24182;</span>
  IncrementalScavenge(n); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22686;&#37327;&#25910;&#38598;. &#21518;&#38754;&#20250;&#20180;&#32454;&#30475;&#36825;&#20010;&#20989;&#25968;&#30340;&#23450;&#20041;</span>
  ASSERT(Check());
}
</pre>
</div>

<p>
里面有两个函数我们需要仔细关心MergeIntoFreeList以及IncrementalScavenge.首先看看MergeIntoFreeList
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">MergeIntoFreeList</span>(<span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span>) {
  ASSERT(span-&gt;location != <span style="font-weight: bold; text-decoration: underline;">Span</span>::IN_USE);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">PageID</span> <span style="font-weight: bold; font-style: italic;">p</span> = span-&gt;start;
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">n</span> = span-&gt;length;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#23581;&#35797;&#21512;&#24182;p-1 pages&#36825;&#20010;span</span>
  <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">prev</span> = GetDescriptor(p-1);
  <span style="font-weight: bold;">if</span> (prev != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; prev-&gt;location == span-&gt;location) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Merge preceding span into this span</span>
    ASSERT(prev-&gt;start + prev-&gt;length == p);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">len</span> = prev-&gt;length;
    RemoveFromFreeList(prev);
    DeleteSpan(prev);
    span-&gt;start -= len;
    span-&gt;length += len;
    pagemap_.set(span-&gt;start, span);
    Event(span, <span style="font-style: italic;">'L'</span>, len);
  }
 <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23581;&#35797;&#21512;&#24182;p+n pages&#36825;&#20010;span.</span>
  <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">next</span> = GetDescriptor(p+n);
  <span style="font-weight: bold;">if</span> (next != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; next-&gt;location == span-&gt;location) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Merge next span into this span</span>
    ASSERT(next-&gt;start == p+n);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">len</span> = next-&gt;length;
    RemoveFromFreeList(next);
    DeleteSpan(next);
    span-&gt;length += len;
    pagemap_.set(span-&gt;start + span-&gt;length - 1, span);
    Event(span, <span style="font-style: italic;">'R'</span>, len);
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21512;&#24182;&#23436;&#25104;&#20043;&#21518;&#23601;&#20250;&#25918;&#20837;free list&#37324;&#38754;&#21435;</span>
  PrependToFreeList(span);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7f99d7c" class="outline-4">
<h4 id="org7f99d7c"><span class="section-number-4">4.5.6</span> IncrementalScavenge</h4>
<div class="outline-text-4" id="text-4-5-6">
<p>
IncrementalScavenge这个意思就是增量回收，大致内容就是说将一部分的页面交回给系统内存。虽然在tcmalloc里面实现并没有完全交回给系统内存，
而只是简单地挂在了<sub>returned</sub><sub>free</sub><sub>list上面</sub>，但是里面的策略还是值得看看的。这里所谓的scavenge<sub>counter</sub><sub>意思就是如果归还了多少内存之后</sub>，
那么我们就会尝试进行一次完全交回给系统内存.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">IncrementalScavenge</span>(<span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">n</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fast path; not yet time to release memory</span>
  scavenge_counter_ -= n;
  <span style="font-weight: bold;">if</span> (scavenge_counter_ &gt;= 0) <span style="font-weight: bold;">return</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Not yet time to scavenge</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#40664;&#35748;&#20540;&#30340;&#35805;&#26159;1.0,&#36825;&#20010;&#21487;&#20197;&#26377;&#29615;&#22659;&#21464;&#37327;&#35774;&#32622;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#22238;&#25910;&#29575;&#24456;&#20302;&#30340;&#21704;&#65292;&#37027;&#20040;&#30456;&#24403;&#20110;&#19981;&#20250;&#24402;&#36824;&#32473;&#31995;&#32479;&#20869;&#23384;</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">rate</span> = FLAGS_tcmalloc_release_rate;
  <span style="font-weight: bold;">if</span> (rate &lt;= 1e-6) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Tiny release rate means that releasing is disabled.</span>
    <span style="font-weight: bold; font-style: italic;">//   </span><span style="font-weight: bold; font-style: italic;">static const int kDefaultReleaseDelay = 1 &lt;&lt; 18;</span>
    scavenge_counter_ = kDefaultReleaseDelay;
    <span style="font-weight: bold;">return</span>;
  }

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23581;&#35797;&#33267;&#24402;&#36824;&#19968;&#20010;&#39029;&#38754;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20855;&#20307;&#36825;&#20010;&#20989;&#25968;&#23454;&#29616;&#22312;&#21518;&#38754;&#20250;&#25552;&#21040;.</span>
  <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">released_pages</span> = ReleaseAtLeastNPages(1);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#23454;&#38469;&#19978;&#27809;&#26377;&#24402;&#36824;&#30340;&#35805;&#65292;&#37027;&#20040;&#19979;&#27425;&#38656;&#35201;&#31561;&#24453;&#36825;&#20040;&#22810;&#27425;&#20043;&#21518;&#23581;&#35797;&#24402;&#36824;.</span>
  <span style="font-weight: bold;">if</span> (released_pages == 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Nothing to scavenge, delay for a while.</span>
    scavenge_counter_ = kDefaultReleaseDelay;
  } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21542;&#21017;&#20250;&#25353;&#29031;&#19968;&#23450;&#30340;&#31574;&#30053;&#35774;&#23450;&#27425;&#25968;&#28982;&#21518;&#23581;&#35797;&#24402;&#36824;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Compute how long to wait until we return memory.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">FLAGS_tcmalloc_release_rate==1 means wait for 1000 pages</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">after releasing one page.</span>
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">mult</span> = 1000.0 / rate;
    <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">wait</span> = mult * <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">double</span>&gt;(released_pages);
    <span style="font-weight: bold;">if</span> (wait &gt; kMaxReleaseDelay) {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Avoid overflow and bound to reasonable range.</span>
       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">static const int kMaxReleaseDelay = 1 &lt;&lt; 20;</span>
      wait = kMaxReleaseDelay;
    }
    scavenge_counter_ = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int64_t</span>&gt;(wait);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf5fde78" class="outline-4">
<h4 id="orgf5fde78"><span class="section-number-4">4.5.7</span> ReleaseAtLeastNPages</h4>
<div class="outline-text-4" id="text-4-5-7">
<p>
这个函数的语义就是至少尝试释放n pages.实现方式非常简单，每次都从一种pages里面取出一个东西并且进行释放，直到全部释放为止。
算是一种round-robin的方式吧，我猜想这样释放的方式对于后面分配的性能影响比较小，每一种大小都释放一些。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">ReleaseAtLeastNPages</span>(<span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">num_pages</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">released_pages</span> = 0;
  <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">prev_released_pages</span> = -1;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Round robin through the lists of free spans, releasing the last</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">span in each list.  Stop after releasing at least num_pages.</span>
  <span style="font-weight: bold;">while</span> (released_pages &lt; num_pages) {
    <span style="font-weight: bold;">if</span> (released_pages == prev_released_pages) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#33258;&#19978;&#27425;&#20381;&#36182;&#27809;&#26377;&#22810;&#20313;&#37322;&#25918;&#30340;&#35805;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Last iteration of while loop made no progress.</span>
      <span style="font-weight: bold;">break</span>;
    }
    prev_released_pages = released_pages;

    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; kMaxPages+1 &amp;&amp; released_pages &lt; num_pages;
         i++, release_index_++) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010;&#22823;&#23567;&#31867;&#22411;&#37117;&#20250;&#23581;&#35797;&#37322;&#25918;&#19968;&#20010;.</span>
      <span style="font-weight: bold;">if</span> (release_index_ &gt; kMaxPages) release_index_ = 0;
      <span style="font-weight: bold; text-decoration: underline;">SpanList</span>* <span style="font-weight: bold; font-style: italic;">slist</span> = (release_index_ == kMaxPages) ?
          &amp;large_ : &amp;free_[release_index_];
      <span style="font-weight: bold;">if</span> (!DLL_IsEmpty(&amp;slist-&gt;normal)) {
        <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">released_len</span> = ReleaseLastNormalSpan(slist);
        released_pages += released_len;
      }
    }
  }
  <span style="font-weight: bold;">return</span> released_pages;
}
</pre>
</div>

<p>
然后我们看看ReleaseLastNormalSpan这个过程，非常简单
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">ReleaseLastNormalSpan</span>(<span style="font-weight: bold; text-decoration: underline;">SpanList</span>* <span style="font-weight: bold; font-style: italic;">slist</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">s</span> = slist-&gt;normal.prev;
  ASSERT(s-&gt;location == <span style="font-weight: bold; text-decoration: underline;">Span</span>::ON_NORMAL_FREELIST);
  RemoveFromFreeList(s); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20174;&#24403;&#21069;&#38142;&#20013;&#37322;&#25918;&#25481;.</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">n</span> = s-&gt;length;
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23454;&#38469;&#19978;&#36825;&#20010;&#37096;&#20998;&#24182;&#27809;&#26377;&#37322;&#25918;&#21734;.</span>
  TCMalloc_SystemRelease(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">void</span>*&gt;(s-&gt;start &lt;&lt; kPageShift),
                         <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">size_t</span>&gt;(s-&gt;length &lt;&lt; kPageShift));
  s-&gt;location = <span style="font-weight: bold; text-decoration: underline;">Span</span>::ON_RETURNED_FREELIST; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26631;&#35760;&#20026;returned&#29366;&#24577;</span>
   <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20002;&#22238;return free list&#26102;&#20505;&#20250;&#23581;&#35797;&#21512;&#24182;.</span>
  MergeIntoFreeList(s);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Coalesces if possible.</span>
  <span style="font-weight: bold;">return</span> n;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf0bcf1a" class="outline-4">
<h4 id="orgf0bcf1a"><span class="section-number-4">4.5.8</span> Split</h4>
<div class="outline-text-4" id="text-4-5-8">
<p>
Split过程和Carve过程是非常相似的，只不过Split针对的是IN<sub>USE状态的这种span</sub>.
代码阅读到这里暂时还不知道这个Split什么时候调用:(.what a shame.
</p>
</div>
</div>

<div id="outline-container-orgb16d51b" class="outline-4">
<h4 id="orgb16d51b"><span class="section-number-4">4.5.9</span> GetNextRange</h4>
<div class="outline-text-4" id="text-4-5-9">
<p>
得到page id &gt;=start的span的具体内容。首先看看MallocRange的内容
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">struct</span> <span style="font-weight: bold; text-decoration: underline;">MallocRange</span> {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;malloc&#33539;&#22260;&#26159;&#20160;&#20040;&#31867;&#22411;</span>
  <span style="font-weight: bold;">enum</span> <span style="font-weight: bold; text-decoration: underline;">Type</span> {
    <span style="font-weight: bold; font-style: italic;">INUSE</span>,                <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Application is using this range</span>
    <span style="font-weight: bold; font-style: italic;">FREE</span>,                 <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Range is currently free</span>
    <span style="font-weight: bold; font-style: italic;">UNMAPPED</span>,             <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Backing physical memory has been returned to the OS</span>
    <span style="font-weight: bold; font-style: italic;">UNKNOWN</span>,
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">More enum values may be added in the future</span>
  };
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22320;&#22336;&#65292;&#38271;&#24230;&#65292;&#31867;&#22411;</span>
  <span style="font-weight: bold; text-decoration: underline;">uintptr_t</span> <span style="font-weight: bold; font-style: italic;">address</span>;    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Address of range</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">length</span>;        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Byte length of range</span>
  <span style="font-weight: bold; text-decoration: underline;">Type</span> <span style="font-weight: bold; font-style: italic;">type</span>;            <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Type of this range</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">=0 !INUSE,&#22914;&#26524;=1&#34920;&#31034;&#36825;&#20010;&#34987;&#24403;&#20570;page&#20351;&#29992;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;[0,1]&#20043;&#38388;&#30340;&#35805;&#65292;&#34920;&#26126;&#34987;&#20570;&#25104;&#20102;&#23567;&#23545;&#35937;&#20998;&#37197;</span>
  <span style="font-weight: bold; text-decoration: underline;">double</span> <span style="font-weight: bold; font-style: italic;">fraction</span>;      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Fraction of range that is being used (0 if !INUSE)</span>
};
</pre>
</div>
<p>
然后来看看这个过程
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">PageHeap</span>::<span style="font-weight: bold;">GetNextRange</span>(<span style="font-weight: bold; text-decoration: underline;">PageID</span> <span style="font-weight: bold; font-style: italic;">start</span>, <span style="font-weight: bold; text-decoration: underline;">base</span>::<span style="font-weight: bold; text-decoration: underline;">MallocRange</span>* <span style="font-weight: bold; font-style: italic;">r</span>) {
  <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Span</span>*&gt;(pagemap_.Next(start));
  <span style="font-weight: bold;">if</span> (span == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  r-&gt;address = span-&gt;start &lt;&lt; kPageShift;
  r-&gt;length = span-&gt;length &lt;&lt; kPageShift;
  r-&gt;fraction = 0;
  <span style="font-weight: bold;">switch</span> (span-&gt;location) {
    <span style="font-weight: bold;">case</span> <span style="font-weight: bold; text-decoration: underline;">Span</span>::IN_USE:
      r-&gt;type = <span style="font-weight: bold; text-decoration: underline;">base</span>::<span style="font-weight: bold; text-decoration: underline;">MallocRange</span>::INUSE;
      r-&gt;fraction = 1;
      <span style="font-weight: bold;">if</span> (span-&gt;sizeclass &gt; 0) {
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Only some of the objects in this span may be in use.</span>
        <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">osize</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;class_to_size(span-&gt;sizeclass); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#30693;&#36947;&#36825;&#20010;class&#27599;&#20010;object size&#22810;&#23569;</span>
       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">refcount&#34920;&#31034;&#24050;&#32463;&#20351;&#29992;&#20102;&#22810;&#23569;&#20010;objects.,&#36825;&#26679;&#23601;&#21487;&#20197;&#24471;&#21040;&#20351;&#29992;&#29575;</span>
        r-&gt;fraction = (1.0 * osize * span-&gt;refcount) / r-&gt;length;
      }
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold;">case</span> <span style="font-weight: bold; text-decoration: underline;">Span</span>::ON_NORMAL_FREELIST:
      r-&gt;type = <span style="font-weight: bold; text-decoration: underline;">base</span>::<span style="font-weight: bold; text-decoration: underline;">MallocRange</span>::FREE;
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold;">case</span> <span style="font-weight: bold; text-decoration: underline;">Span</span>::ON_RETURNED_FREELIST:
      r-&gt;type = <span style="font-weight: bold; text-decoration: underline;">base</span>::<span style="font-weight: bold; text-decoration: underline;">MallocRange</span>::UNMAPPED;
      <span style="font-weight: bold;">break</span>;
    <span style="font-weight: bold;">default</span>:
      r-&gt;type = <span style="font-weight: bold; text-decoration: underline;">base</span>::<span style="font-weight: bold; text-decoration: underline;">MallocRange</span>::UNKNOWN;
      <span style="font-weight: bold;">break</span>;
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfc63d19" class="outline-3">
<h3 id="orgfc63d19"><span class="section-number-3">4.6</span> TCMalloc<sub>PageMap3</sub></h3>
<div class="outline-text-3" id="text-4-6">
<p>
page<sub>map.h</sub>
</p>

<p>
之前pageheap里面可以看到有这么一个要求，就是从一个page ID映射到span这么一个过程。在64位下面的话逻辑地址空间有1 &lt;&lt; 64，
如果按照4K per page计算的话，那么最多会存在1&lt;&lt;52个page.如果使用数组存储的话那么是会存在问题的。所以这里使用了radix tree来进行映射。
对于64位的话使用了3-level radix tree.每段分别是(18,18,16)
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">How many bits should we consume at each interior level</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">INTERIOR_BITS</span> = (BITS + 2) / 3; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Round-up</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">INTERIOR_LENGTH</span> = 1 &lt;&lt; INTERIOR_BITS;

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">How many bits should we consume at leaf level</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">LEAF_BITS</span> = BITS - 2*INTERIOR_BITS;
<span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">LEAF_LENGTH</span> = 1 &lt;&lt; LEAF_BITS;
</pre>
</div>
<p>
对于一个地址映射称为每一个level的number index的函数可以参看get这个方法
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">get</span>(<span style="font-weight: bold; text-decoration: underline;">Number</span> <span style="font-weight: bold; font-style: italic;">k</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Number</span> <span style="font-weight: bold; font-style: italic;">i1</span> = k &gt;&gt; (LEAF_BITS + INTERIOR_BITS);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Number</span> <span style="font-weight: bold; font-style: italic;">i2</span> = (k &gt;&gt; LEAF_BITS) &amp; (INTERIOR_LENGTH-1);
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Number</span> <span style="font-weight: bold; font-style: italic;">i3</span> = k &amp; (LEAF_LENGTH-1);
  <span style="font-weight: bold;">if</span> ((k &gt;&gt; BITS) &gt; 0 ||
      root_-&gt;ptrs[i1] == <span style="font-weight: bold; text-decoration: underline;">NULL</span> || root_-&gt;ptrs[i1]-&gt;ptrs[i2] == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Leaf</span>*&gt;(root_-&gt;ptrs[i1]-&gt;ptrs[i2])-&gt;values[i3];
}
</pre>
</div>
<p>
初次之外，这个pagemap还有两个比较重要的接口
</p>
<ul class="org-ul">
<li>bool Ensure(Number start, size<sub>t</sub> n)</li>
</ul>
<p>
因为get,set接口的话都是假设每一层对应的array都是存在的，所以基本上在调用之前的话都必须确保这个array存在。
而Ensure就是做这件事情的，确保[start,start+n-1]这些PageId对应的每一层array都存在。
</p>

<ul class="org-ul">
<li>void* Next(Number k) const</li>
</ul>
<p>
Next接口就纯粹想知道&gt;=k的这些PageId首先映射到的span对象是什么，实现起来非常巧妙可以仔细阅读一下
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">Next</span>(<span style="font-weight: bold; text-decoration: underline;">Number</span> <span style="font-weight: bold; font-style: italic;">k</span>) <span style="font-weight: bold;">const</span> {
  <span style="font-weight: bold;">while</span> (k &lt; (Number(1) &lt;&lt; BITS)) {
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Number</span> <span style="font-weight: bold; font-style: italic;">i1</span> = k &gt;&gt; (LEAF_BITS + INTERIOR_BITS);
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">Number</span> <span style="font-weight: bold; font-style: italic;">i2</span> = (k &gt;&gt; LEAF_BITS) &amp; (INTERIOR_LENGTH-1);
    <span style="font-weight: bold;">if</span> (root_-&gt;ptrs[i1] == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36825;&#23618;&#20026;&#31354;&#30340;&#35805;&#65292;&#37027;&#20040;&#30452;&#25509;&#36339;&#21040;&#19979;&#19968;&#23618;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Advance to next top-level entry</span>
      k = (i1 + 1) &lt;&lt; (LEAF_BITS + INTERIOR_BITS);
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; text-decoration: underline;">Leaf</span>* <span style="font-weight: bold; font-style: italic;">leaf</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">Leaf</span>*&gt;(root_-&gt;ptrs[i1]-&gt;ptrs[i2]);
      <span style="font-weight: bold;">if</span> (leaf != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
        <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">Number</span> <span style="font-weight: bold; font-style: italic;">i3</span> = (k &amp; (LEAF_LENGTH-1)); i3 &lt; LEAF_LENGTH; i3++) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36941;&#21382;&#36825;&#19968;&#23618;(&#31532;&#19977;&#23618;)&#30475;&#30475;&#26159;&#21542;&#23384;&#22312;.</span>
          <span style="font-weight: bold;">if</span> (leaf-&gt;values[i3] != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
            <span style="font-weight: bold;">return</span> leaf-&gt;values[i3];
          }
        }
      }
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Advance to next interior entry</span>
      k = ((k &gt;&gt; LEAF_BITS) + 1) &lt;&lt; LEAF_BITS; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#31532;&#20108;&#23618;&#20026;&#31354;&#30340;&#35805;&#65292;&#37027;&#20040;&#21516;&#26679;&#36827;&#20837;&#19979;&#19968;&#23618;.</span>
    }
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc2f035e" class="outline-3">
<h3 id="orgc2f035e"><span class="section-number-3">4.7</span> PackedCache</h3>
<div class="outline-text-3" id="text-4-7">
<p>
packed-cache-inl.h
</p>

<p>
PackedCache是一种非常精巧的数据结构。它的作用主要是想知道对于一个pageId所管理的span而言的话，对应的sizeclass是什么。
在pageheap里面是这样定义的   typedef PackedCache&lt;BITS-kPageShift, uint64<sub>t</sub>&gt; CacheType;  我们还是看看这个结构是什么样的
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">template</span> &lt;<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kKeybits</span>, <span style="font-weight: bold;">typename</span> <span style="font-weight: bold; text-decoration: underline;">T</span>&gt;
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">PackedCache</span> {
 <span style="font-weight: bold;">public</span>:
  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">uintptr_t</span> <span style="font-weight: bold; text-decoration: underline;">K</span>;
  <span style="font-weight: bold;">typedef</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; text-decoration: underline;">V</span>;
<span style="font-weight: bold;">#ifdef</span> TCMALLOC_SMALL_BUT_SLOW
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Decrease the size map cache if running in the small memory mode.</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kHashbits</span> = 12;
<span style="font-weight: bold;">#else</span>
  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">kHashbits</span> = 16;
<span style="font-weight: bold;">#endif</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">array_ is the cache.  Its elements are volatile because any</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">thread can write any array element at any time.</span>
  <span style="font-weight: bold;">volatile</span> <span style="font-weight: bold; text-decoration: underline;">T</span> <span style="font-weight: bold; font-style: italic;">array_</span>[1 &lt;&lt; kHashbits];
};
</pre>
</div>
<p>
首先它还是一个KV结构，只不过K+V大小可以放在sizeof(T)字节里面。回顾一下对于64位而言，PageId 52位，而sizeclass只有85中，完全可以存放在sizeof(uint64<sub>t</sub>)里面。
将K放在高字节，而V放在低字节，组成一个&lt;sizeof(uint64<sub>t</sub>)大小的值存放在array<sub>里面</sub>。此外还需要注意一个问题就是，这个有可能被多线程访问，
但是如果我们将这个内容设置称为volatile的话，那么是不需要加锁就可以完成的。
</p>
</div>
</div>

<div id="outline-container-org4961989" class="outline-3">
<h3 id="org4961989"><span class="section-number-3">4.8</span> Thread Cache</h3>
<div class="outline-text-3" id="text-4-8">
<p>
thread<sub>cache.h</sub>
</p>
</div>

<div id="outline-container-org67d42ea" class="outline-4">
<h4 id="org67d42ea"><span class="section-number-4">4.8.1</span> Data Structure</h4>
<div class="outline-text-4" id="text-4-8-1">
<p>
Thread Cache就是每一个线程里面管理小对象分配的cache.tcmalloc应该是假设局部线程里面通常分配的都是小对象，这样可以减少锁竞争。
而如果是分配大对象的话，那么会直接从page heap里面进行分配。如果本地小对象不够的话，那么会尝试从central cache里面要。
Thread Cache比较重要的接口有下面这些：
</p>
<ul class="org-ul">
<li>void Init(pthread<sub>t</sub> tid); // 初始化</li>
<li>void Cleanup();</li>
<li>void* Allocate(size<sub>t</sub> size, size<sub>t</sub> cl); // 从class里面分配size大小</li>
<li>void Deallocate(void* ptr, size<sub>t</sub> size<sub>class</sub>); // 将ptr放回class对应slab里面</li>
<li>void Scavenge(); // 回收内存到central cache.就是文档里面说的GC</li>
<li>bool SampleAllocation(size<sub>t</sub> k); // 是否认为这次分配的k字节需要进行采样.</li>
</ul>
<p>
还有一些静态方法也非常值得关注
</p>
<ul class="org-ul">
<li>InitModule // 初始化模块</li>
<li>InitTSD // 初始化thread storage data.</li>
<li>GetThreadHeap // thread cache.</li>
<li>GetCache // tc</li>
<li>GetCacheIfPresent // tc</li>
<li>CreateCacheIfNecessary // 如果tc不存在就创建</li>
<li>BecomeIdle // 标记这个thread已经idle，所以可以释放这个tc了</li>
</ul>

<p>
涉及到的静态变量有下面这些
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">namespace</span> <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span> {

<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">phinited</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>;

<span style="font-weight: bold;">volatile</span> <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold; font-style: italic;">per_thread_cache_size_</span> = kMaxThreadCacheSize; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#20010;tc&#30340;&#22823;&#23567; (4 &lt;&lt; 20,4MB)</span>
<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold; font-style: italic;">overall_thread_cache_size_</span> = kDefaultOverallThreadCacheSize;<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#25152;&#26377;tc&#22823;&#23567; (8 * kMaxThreadCacheSize = 32MB)</span>
<span style="font-weight: bold; text-decoration: underline;">ssize_t</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold; font-style: italic;">unclaimed_cache_space_</span> = kDefaultOverallThreadCacheSize;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31649;&#29702;&#23545;&#35937;&#25152;&#25345;&#26377;&#30340;tc&#22823;&#23567;(&#30456;&#24403;&#20110;&#24635;tc&#37324;&#38754;&#36824;&#26377;&#22810;&#23569;&#21487;&#29992;).</span>
<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(= overall_thread_cache_size_ - sum(tc.max_size))</span>
<span style="font-weight: bold; text-decoration: underline;">PageHeapAllocator</span>&lt;ThreadCache&gt; <span style="font-weight: bold; font-style: italic;">threadcache_allocator</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">tc sample alloc.</span>
<span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold; font-style: italic;">thread_heaps_</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">tc&#38142;.</span>
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold; font-style: italic;">thread_heap_count_</span> = 0; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22810;&#23569;&#20010;tc</span>
<span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold; font-style: italic;">next_memory_steal_</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19979;&#19968;&#27425;steal&#30340;tc.</span>
<span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold; font-style: italic;">tsd_inited_</span> = <span style="font-weight: bold; text-decoration: underline;">false</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26159;&#21542;&#24050;&#32463;&#21021;&#22987;&#21270;&#20102;&#32447;&#31243;&#23616;&#37096;&#25968;&#25454;</span>
<span style="font-weight: bold; text-decoration: underline;">pthread_key_t</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold; font-style: italic;">heap_key_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#20351;&#29992;pthread&#32447;&#31243;&#23616;&#37096;&#25968;&#25454;&#35299;&#20915;&#21150;&#27861;</span>

}
</pre>
</div>
</div>
</div>

<div id="outline-container-org54f5166" class="outline-4">
<h4 id="org54f5166"><span class="section-number-4">4.8.2</span> InitModule</h4>
<div class="outline-text-4" id="text-4-8-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">InitModule</span>() {
  <span style="font-weight: bold; text-decoration: underline;">SpinLockHolder</span> <span style="font-weight: bold; font-style: italic;">h</span>(<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap_lock());  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20840;&#23616;&#33258;&#36873;&#38145;</span>
  <span style="font-weight: bold;">if</span> (!phinited) {
    <span style="font-weight: bold; text-decoration: underline;">Static</span>::InitStaticVars(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#21270;&#19968;&#20123;&#38745;&#24577;&#25968;&#25454;</span>
    threadcache_allocator.Init(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">PageHeapAllocator&lt;ThreadCache&gt;,sample_alloc&#21021;&#22987;&#21270;</span>
    phinited = 1;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge832814" class="outline-4">
<h4 id="orge832814"><span class="section-number-4">4.8.3</span> InitTSD</h4>
<div class="outline-text-4" id="text-4-8-3">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">InitTSD</span>() {
  ASSERT(!tsd_inited_); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#21464;&#37327;&#26631;&#35760;&#26159;&#21542;&#24050;&#32463;&#21021;&#22987;&#21270;&#20102;&#32447;&#31243;&#23616;&#37096;&#21464;&#37327;&#65292;&#22914;&#26524;&#27809;&#26377;&#30340;&#35805;&#37027;&#20040;&#26159;&#27809;&#26377;&#20219;&#20309;tc&#30340;.</span>
  perftools_pthread_key_create(&amp;heap_key_, DestroyThreadCache); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#23601;&#26159;&#35774;&#32622;&#22909;&#32447;&#31243;&#23616;&#37096;&#21464;&#37327;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;&#27599;&#19968;&#20010;&#32447;&#31243;&#37117;&#20250;&#26377;&#19968;&#20010;&#32447;&#31243;&#23616;&#37096;&#21464;&#37327;thread cache.</span>
  tsd_inited_ = <span style="font-weight: bold; text-decoration: underline;">true</span>;
}
</pre>
</div>
<p>
然后我们看看DestroyThreadCache.很容易想到其实这个方法就是销毁掉线程的tc
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">DestroyThreadCache</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Note that "ptr" cannot be NULL since pthread promises not</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">to invoke the destructor on NULL values, but for safety,</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we check anyway.</span>
  <span style="font-weight: bold;">if</span> (ptr == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) <span style="font-weight: bold;">return</span>;
  DeleteCache(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>*&gt;(ptr));
}
</pre>
</div>
<p>
我们可能会很想看看这个调用InitTSD的时机是什么？这个是放在一个全局静态变量里面一起调用的。之前已经提到了TCMallocGuard
</p>
</div>
</div>

<div id="outline-container-org9ce3377" class="outline-4">
<h4 id="org9ce3377"><span class="section-number-4">4.8.4</span> GetCache</h4>
<div class="outline-text-4" id="text-4-8-4">
<p>
关于GetCache我们也可以一起看看GetThreadHeap,GetCacheIfPresent,CreateCacheIfNecessary
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">GetCache</span>() {
  <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; font-style: italic;">ptr</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold;">if</span> (!tsd_inited_) {
    InitModule(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#21270;&#27169;&#22359;</span>
  } <span style="font-weight: bold;">else</span> {
    ptr = GetThreadHeap(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30452;&#25509;&#26597;&#30475;&#26159;&#21542;&#23384;&#22312;</span>
  }
  <span style="font-weight: bold;">if</span> (ptr == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) ptr = CreateCacheIfNecessary(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#19981;&#23384;&#22312;&#30340;&#35805;&#37027;&#20040;&#23601;&#21019;&#24314;</span>
  <span style="font-weight: bold;">return</span> ptr;
}
</pre>
</div>

<p>
GetThreadHeap非常简单直接从线程局部变量里面取出即可
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">GetThreadHeap</span>() {
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ThreadCache</span> *&gt;(
      perftools_pthread_getspecific(heap_key_));
}
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">GetCacheIfPresent</span>() {
  <span style="font-weight: bold;">if</span> (!tsd_inited_) <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold;">return</span> GetThreadHeap();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0978d7d" class="outline-4">
<h4 id="org0978d7d"><span class="section-number-4">4.8.5</span> CreateCacheIfNecessary</h4>
<div class="outline-text-4" id="text-4-8-5">
<p>
然后看看CreateCacheIfNecessary这个实现,看看是如何创建tc的
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">CreateCacheIfNecessary</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Initialize per-thread data if necessary</span>
  <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; font-style: italic;">heap</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  {
    <span style="font-weight: bold; text-decoration: underline;">SpinLockHolder</span> <span style="font-weight: bold; font-style: italic;">h</span>(<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap_lock());
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">pthread_t</span> <span style="font-weight: bold; font-style: italic;">me</span> = pthread_self();
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26597;&#25214;&#37324;&#38754;&#26159;&#21542;&#24050;&#32463;&#23384;&#22312;,&#27599;&#20010;&#32447;&#31243;&#37117;&#21019;&#24314;&#19968;&#20010;ThreadCache.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24182;&#19988;&#36825;&#20010;&#26159;&#25353;&#29031;&#38142;&#32452;&#32455;&#36215;&#26469;&#30340;&#12290;</span>
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; font-style: italic;">h</span> = thread_heaps_; h != <span style="font-weight: bold; text-decoration: underline;">NULL</span>; h = h-&gt;next_) {
      <span style="font-weight: bold;">if</span> (h-&gt;tid_ == me) {
        heap = h;
        <span style="font-weight: bold;">break</span>;
      }
    }
    <span style="font-weight: bold;">if</span> (heap == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) heap = NewHeap(me);
  }
  <span style="font-weight: bold;">if</span> (!heap-&gt;in_setspecific_ &amp;&amp; tsd_inited_) {
    heap-&gt;in_setspecific_ = <span style="font-weight: bold; text-decoration: underline;">true</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36991;&#20813;setspecific&#37324;&#38754;&#36824;&#35843;&#29992;</span>
    perftools_pthread_setspecific(heap_key_, heap);
    heap-&gt;in_setspecific_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  }
  <span style="font-weight: bold;">return</span> heap;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org16e1431" class="outline-4">
<h4 id="org16e1431"><span class="section-number-4">4.8.6</span> NewHeap</h4>
<div class="outline-text-4" id="text-4-8-6">
<p>
NewHeap是产生一个新的tc调用Init.将这个tc插入到队列里面.注意这里NewHeap已经加了锁了。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">NewHeap</span>(<span style="font-weight: bold; text-decoration: underline;">pthread_t</span> <span style="font-weight: bold; font-style: italic;">tid</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Create the heap and add it to the linked list</span>
  <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span> *<span style="font-weight: bold; font-style: italic;">heap</span> = threadcache_allocator.New();
  heap-&gt;Init(tid); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#29992;Init</span>
  heap-&gt;next_ = thread_heaps_; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32452;&#32455;&#25104;&#20026;&#19968;&#20010;&#21452;&#21521;&#38142;&#34920;</span>
  heap-&gt;prev_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold;">if</span> (thread_heaps_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
    thread_heaps_-&gt;prev_ = heap;
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">This is the only thread heap at the momment.</span>
    ASSERT(next_memory_steal_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    next_memory_steal_ = heap; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36825;&#20010;&#26159;&#31532;&#19968;&#20010;&#20803;&#32032;&#30340;&#35805;&#65292;&#37027;&#20040;&#35774;&#32622;next_memory_steal.</span>
  }
  thread_heaps_ = heap;
  thread_heap_count_++; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">tc&#25968;&#37327;.</span>
  <span style="font-weight: bold;">return</span> heap;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org29b7da7" class="outline-4">
<h4 id="org29b7da7"><span class="section-number-4">4.8.7</span> BecomeIdle</h4>
<div class="outline-text-4" id="text-4-8-7">
<p>
BecomeIdle触发条件现在还不是很清楚，但是作用是认为这个tc没有必要了可以删除。不过在大部分使用应该不会有这个调用吧。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">BecomeIdle</span>() {
  <span style="font-weight: bold;">if</span> (!tsd_inited_) <span style="font-weight: bold;">return</span>;              <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No caches yet</span>
  <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; font-style: italic;">heap</span> = GetThreadHeap();
  <span style="font-weight: bold;">if</span> (heap == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) <span style="font-weight: bold;">return</span>;             <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">No thread cache to remove</span>
  <span style="font-weight: bold;">if</span> (heap-&gt;in_setspecific_) <span style="font-weight: bold;">return</span>;    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Do not disturb the active caller</span>

  heap-&gt;in_setspecific_ = <span style="font-weight: bold; text-decoration: underline;">true</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#38450;&#27490;&#36882;&#24402;&#35843;&#29992;</span>
  perftools_pthread_setspecific(heap_key_, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
  heap-&gt;in_setspecific_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold;">if</span> (GetThreadHeap() == heap) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24212;&#35813;&#26159;&#19981;&#20250;&#35843;&#29992;&#36825;&#20010;&#37096;&#20998;&#36923;&#36753;&#30340;.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Somehow heap got reinstated by a recursive call to malloc</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">from pthread_setspecific.  We give up in this case.</span>
    <span style="font-weight: bold;">return</span>;
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#23558;&#36825;&#20010;heap&#37322;&#25918;&#25481;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We can now get rid of the heap</span>
  DeleteCache(heap);
}
</pre>
</div>

<p>
这里我想到一个问题，就是如果不断地启动线程然后关闭线程，如果tid是不允许复用的话那么会导致thread<sub>cache不断地开辟</sub>。
如果使用gettid的话那么可能会有这个情况，而如果用pthread<sub>self的话可能就不会有了</sub>(至少从程序上看可以复用)
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;cstdio&gt;</span>
<span style="font-weight: bold;">#include</span> <span style="font-style: italic;">&lt;pthread.h&gt;</span>

<span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buf</span>[1024*1024];
<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">foo</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">arg</span>){
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
}
<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold;">main</span>() {
  <span style="font-weight: bold; text-decoration: underline;">pthread_t</span> <span style="font-weight: bold; font-style: italic;">tid</span>;
  <span style="font-weight: bold;">for</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span>=0;i&lt;10;i++){
    pthread_create(&amp;tid,<span style="font-weight: bold; text-decoration: underline;">NULL</span>,foo,<span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    pthread_join(tid,<span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    printf(<span style="font-style: italic;">"%zu\n"</span>,<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">size_t</span>&gt;(tid));
    pthread_create(&amp;tid,<span style="font-weight: bold; text-decoration: underline;">NULL</span>,foo,<span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    pthread_join(tid,<span style="font-weight: bold; text-decoration: underline;">NULL</span>);
    printf(<span style="font-style: italic;">"%zu\n"</span>,<span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">size_t</span>&gt;(tid));
  }
  <span style="font-weight: bold;">return</span> 0;
}
</pre>
</div>
<p>
从程序运行结果来看的话都是一样的tid.
</p>
</div>
</div>

<div id="outline-container-org1b67568" class="outline-4">
<h4 id="org1b67568"><span class="section-number-4">4.8.8</span> Init</h4>
<div class="outline-text-4" id="text-4-8-8">
<p>
注意这里Init已经在外围的NewHeap加锁了。这个地方进行初始化。设置一下最大分配多少空间以及初始化每一个slab
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">Init</span>(<span style="font-weight: bold; text-decoration: underline;">pthread_t</span> <span style="font-weight: bold; font-style: italic;">tid</span>) {
  size_ = 0;

  max_size_ = 0;
  IncreaseCacheLimitLocked(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#22320;&#26041;&#22312;&#35745;&#31639;&#21040;&#24213;&#21487;&#20197;&#20998;&#37197;&#22810;&#23569;max size.</span>
  <span style="font-weight: bold;">if</span> (max_size_ == 0) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">There isn't enough memory to go around.  Just give the minimum to</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">this thread.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">static const size_t kMaxSize    = 256 * 1024;(256K)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">static const size_t kMinThreadCacheSize = kMaxSize * 2;(512K)</span>
    max_size_ = kMinThreadCacheSize; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">512K.</span>

    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Take unclaimed_cache_space_ negative.</span>
    unclaimed_cache_space_ -= kMinThreadCacheSize; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#30456;&#24403;&#20110;tc&#25345;&#26377;&#31354;&#38386;&#31354;&#38388;&#20063;&#23545;&#24212;&#20943;&#23569;</span>
    ASSERT(unclaimed_cache_space_ &lt; 0);
  }

  next_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  prev_ = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  tid_  = tid;
  in_setspecific_ = <span style="font-weight: bold; text-decoration: underline;">false</span>;
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">cl</span> = 0; cl &lt; kNumClasses; ++cl) {
    list_[cl].Init(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#21270;&#27599;&#20010;slab</span>
  }

  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">sampler_seed</span>;
  memcpy(&amp;sampler_seed, &amp;tid, <span style="font-weight: bold;">sizeof</span>(sampler_seed));
  sampler_.Init(sampler_seed); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21021;&#22987;&#21270;sampler</span>
}
</pre>
</div>
<p>
这里我们有两个问题没有搞懂，一个是slab到底结构是怎么样的，一个就是IncreaseCacheLimitLocked里面是如何计算max<sub>size</sub><sub>的</sub>。
</p>
</div>
</div>

<div id="outline-container-org8ceb193" class="outline-4">
<h4 id="org8ceb193"><span class="section-number-4">4.8.9</span> ThreadCache::FreeList</h4>
<div class="outline-text-4" id="text-4-8-9">
<p>
freelist就是对应的slab.本质上数据结构就是一个单向链表，毕竟这个分配对于顺序没有任何要求。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">FreeList</span> {
 <span style="font-weight: bold;">private</span>:
  <span style="font-weight: bold; text-decoration: underline;">void</span>*    <span style="font-weight: bold; font-style: italic;">list_</span>;       <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Linked list of nodes</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">On 64-bit hardware, manipulating 16-bit values may be slightly slow.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">length_</span>;      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Current length. // &#24403;&#21069;&#38271;&#24230;&#22810;&#23569;</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">lowater_</span>;     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Low water mark for list length. // &#38271;&#24230;&#26368;&#23569;&#26102;&#20505;&#36798;&#21040;&#20102;&#22810;&#23569;</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">max_length_</span>;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Dynamic max list length based on usage. // &#35748;&#20026;&#30340;&#26368;&#22823;&#38271;&#24230;&#22810;&#23569;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Tracks the number of times a deallocation has caused</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">length_ &gt; max_length_.  After the kMaxOverages'th time, max_length_</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">shrinks and length_overages_ is reset to zero.</span>
  <span style="font-weight: bold; text-decoration: underline;">uint32_t</span> <span style="font-weight: bold; font-style: italic;">length_overages_</span>; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36229;&#36807;&#26368;&#22823;&#38271;&#24230;&#30340;&#27425;&#25968;</span>
};
</pre>
</div>
<p>
所有的这些参数其实都是为了进行方便做一些策略。
</p>
</div>
</div>

<div id="outline-container-org06eaadb" class="outline-4">
<h4 id="org06eaadb"><span class="section-number-4">4.8.10</span> IncreaseCacheLimitLocked</h4>
<div class="outline-text-4" id="text-4-8-10">
<p>
之前说到这个函数是在计算这个tc里面最多可以分配多少内存，那么看看这个函数的实现.调用这个函数的时候必然都是已经加了自旋锁的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">IncreaseCacheLimitLocked</span>() {
  <span style="font-weight: bold;">if</span> (unclaimed_cache_space_ &gt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;tc&#37324;&#38754;&#36824;&#26377;&#31354;&#38386;&#30340;&#20869;&#23481;&#30340;&#35805;&#65292;&#37027;&#20040;&#33719;&#21462;64KB&#36807;&#26469;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">static const size_t kStealAmount = 1 &lt;&lt; 16;(64KB)</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Possibly make unclaimed_cache_space_ negative.</span>
    unclaimed_cache_space_ -= kStealAmount;
    max_size_ += kStealAmount;
    <span style="font-weight: bold;">return</span>;
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#21457;&#29616;&#20381;&#28982;&#19981;&#22815;&#30340;&#35805;&#65292;&#37027;&#20040;&#20250;&#20174;&#27599;&#19968;&#20010;&#20197;&#21518;&#30340;tc&#37324;&#38754;&#33719;&#21462;&#20599;&#21462;&#37096;&#20998;&#20986;&#26469;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#38142;&#26159;&#25353;&#29031;next_memory_steal_&#21462;&#20986;&#26469;&#30340;&#65292;&#22914;&#26524;==NULL&#37027;&#20040;&#20174;&#22836;&#24320;&#22987;&#12290;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20294;&#26159;&#24456;&#24555;&#20250;&#21457;&#29616;&#36825;&#20010;max_size&#20854;&#23454;&#24182;&#19981;&#26159;&#19968;&#25104;&#19981;&#21464;&#30340;.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Don't hold pageheap_lock too long.  Try to steal from 10 other</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">threads before giving up.  The i &lt; 10 condition also prevents an</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">infinite loop in case none of the existing thread heaps are</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">suitable places to steal from.</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; 10;
       ++i, next_memory_steal_ = next_memory_steal_-&gt;next_) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Reached the end of the linked list.  Start at the beginning.</span>
    <span style="font-weight: bold;">if</span> (next_memory_steal_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      ASSERT(thread_heaps_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
      next_memory_steal_ = thread_heaps_;
    }
    <span style="font-weight: bold;">if</span> (next_memory_steal_ == <span style="font-weight: bold;">this</span> ||
        next_memory_steal_-&gt;max_size_ &lt;= kMinThreadCacheSize) {
      <span style="font-weight: bold;">continue</span>;
    }
    next_memory_steal_-&gt;max_size_ -= kStealAmount;
    max_size_ += kStealAmount;

    next_memory_steal_ = next_memory_steal_-&gt;next_;
    <span style="font-weight: bold;">return</span>;
  }
}
</pre>
</div>
<p>
总之tc的max<sub>size分配策略的话就是根据当前所有tc剩余的空间</sub>，如果没有空间的话那么尝试从其他的tc里面获取。应该是想限制一开始每个tc的最大大小。
但是需要注意的是，这个tc最大大小并不是一成不变的，可能会随着时间变化而增加。
</p>
</div>
</div>

<div id="outline-container-org1135bdb" class="outline-4">
<h4 id="org1135bdb"><span class="section-number-4">4.8.11</span> DeleteCache</h4>
<div class="outline-text-4" id="text-4-8-11">
<p>
DeleteCache作用就是删除一个tc.大致逻辑非常简单，首先将自己持有的内存归还给central cache,然后将自己从tc的链中删除即可。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">DeleteCache</span>(<span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; font-style: italic;">heap</span>) {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Remove all memory from heap</span>
  heap-&gt;Cleanup(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#31245;&#21518;&#25105;&#20204;&#26597;&#30475;Cleanup&#23454;&#29616;&#12290;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Remove from linked list</span>
  <span style="font-weight: bold; text-decoration: underline;">SpinLockHolder</span> <span style="font-weight: bold; font-style: italic;">h</span>(<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap_lock());
  <span style="font-weight: bold;">if</span> (heap-&gt;next_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) heap-&gt;next_-&gt;prev_ = heap-&gt;prev_;
  <span style="font-weight: bold;">if</span> (heap-&gt;prev_ != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) heap-&gt;prev_-&gt;next_ = heap-&gt;next_;
  <span style="font-weight: bold;">if</span> (thread_heaps_ == heap) thread_heaps_ = heap-&gt;next_;
  thread_heap_count_--;

  <span style="font-weight: bold;">if</span> (next_memory_steal_ == heap) next_memory_steal_ = heap-&gt;next_;
  <span style="font-weight: bold;">if</span> (next_memory_steal_ == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) next_memory_steal_ = thread_heaps_;
  unclaimed_cache_space_ += heap-&gt;max_size_;

  threadcache_allocator.Delete(heap);
}
</pre>
</div>
<p>
将自己删除之后需要重新计算thread<sub>heaps以及next</sub><sub>memory</sub><sub>steal这两个变量</sub>。
</p>
</div>
</div>

<div id="outline-container-org6b28061" class="outline-4">
<h4 id="org6b28061"><span class="section-number-4">4.8.12</span> Cleanup</h4>
<div class="outline-text-4" id="text-4-8-12">
<p>
Cleanup是在DeleteCache，会在BecomeIdle里面可以调用，也会在销毁线程局部变量里面调用。作用就是将自己持有的内存归还给系统
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">Cleanup</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Put unused memory back into central cache</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">cl</span> = 0; cl &lt; kNumClasses; ++cl) {
    <span style="font-weight: bold;">if</span> (list_[cl].length() &gt; 0) {
      ReleaseToCentralCache(&amp;list_[cl], cl, list_[cl].length());
    }
  }
}
</pre>
</div>
<p>
遍历所有的slab并且将上面挂在的free list归还给central cache.这个在ReleaseToCentralCache里面调用
</p>
</div>
</div>

<div id="outline-container-org9f0a8e4" class="outline-4">
<h4 id="org9f0a8e4"><span class="section-number-4">4.8.13</span> ReleaseToCentralCache</h4>
<div class="outline-text-4" id="text-4-8-13">
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">ReleaseToCentralCache</span>(<span style="font-weight: bold; text-decoration: underline;">FreeList</span>* <span style="font-weight: bold; font-style: italic;">src</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">cl</span>, <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">N</span>) {
  ASSERT(src == &amp;list_[cl]);
  <span style="font-weight: bold;">if</span> (N &gt; src-&gt;length()) N = src-&gt;length(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#22320;&#26041;&#24863;&#35273;&#19981;&#26159;&#24456;&#26377;&#24517;&#35201;.&#19981;&#36807;&#20854;&#20182;&#22320;&#26041;&#30340;&#35805;&#21487;&#33021;&#36825;&#20004;&#20010;&#21442;&#25968;&#19981;&#21516;</span>
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">delta_bytes</span> = N * <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;ByteSizeForClass(cl); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20102;&#35299;&#26377;&#22810;&#23569;&#20010;&#23545;&#35937;&#21344;&#29992;&#20869;&#23384;&#22823;&#23567;&#37322;&#25918;.</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We return prepackaged chains of the correct size to the central cache.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">TODO: Use the same format internally in the thread caches?</span>
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">batch_size</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;num_objects_to_move(cl);
  <span style="font-weight: bold;">while</span> (N &gt; batch_size) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#27599;&#27425;&#24402;&#36824;batch_size&#20010;&#20869;&#23481;&#65292;&#36825;&#26679;central cache&#21487;&#20197;&#25918;&#22312;transfer cache&#37324;&#38754;</span>
    <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">tail</span>, *<span style="font-weight: bold; font-style: italic;">head</span>;
    src-&gt;PopRange(batch_size, &amp;head, &amp;tail);
    <span style="font-weight: bold; text-decoration: underline;">Static</span>::central_cache()[cl].InsertRange(head, tail, batch_size);
    N -= batch_size;
  }
  <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">tail</span>, *<span style="font-weight: bold; font-style: italic;">head</span>;
  src-&gt;PopRange(N, &amp;head, &amp;tail);
  <span style="font-weight: bold; text-decoration: underline;">Static</span>::central_cache()[cl].InsertRange(head, tail, N);
  size_ -= delta_bytes;
}
</pre>
</div>
<p>
PopRange这个语义非常简单，但是我们稍微看看这个的实现，
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">PopRange</span>(<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">N</span>, <span style="font-weight: bold; text-decoration: underline;">void</span> **<span style="font-weight: bold; font-style: italic;">start</span>, <span style="font-weight: bold; text-decoration: underline;">void</span> **<span style="font-weight: bold; font-style: italic;">end</span>) {
  SLL_PopRange(&amp;list_, N, start, end);
  ASSERT(length_ &gt;= N);
  length_ -= N;
  <span style="font-weight: bold;">if</span> (length_ &lt; lowater_) lowater_ = length_;
}
</pre>
</div>
<p>
问题就在于，这里设置了lowater mark.如果当前的长度小于最低水位的话，那么需要更新最低水位。
</p>
</div>
</div>

<div id="outline-container-orge7ae4aa" class="outline-4">
<h4 id="orge7ae4aa"><span class="section-number-4">4.8.14</span> Allocate</h4>
<div class="outline-text-4" id="text-4-8-14">
<p>
Allocate就是从对应的slab里面分配出一个object.注意在Init时候的话每个tc里面是没有任何内容的，size_=0.FreeList也是空的。
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">Allocate</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">cl</span>) {
  ASSERT(size &lt;= kMaxSize);
  ASSERT(size == <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;ByteSizeForClass(cl));

  <span style="font-weight: bold; text-decoration: underline;">FreeList</span>* <span style="font-weight: bold; font-style: italic;">list</span> = &amp;list_[cl];
  <span style="font-weight: bold;">if</span> (list-&gt;empty()) {
    <span style="font-weight: bold;">return</span> FetchFromCentralCache(cl, size); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;list&#37324;&#38754;&#20026;&#31354;&#30340;&#35805;&#65292;&#37027;&#20040;&#23581;&#35797;&#20174;cc&#30340;cl&#37324;&#38754;&#20998;&#37197;size&#20986;&#26469;.</span>
  }
  size_ -= size; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#23384;&#22312;&#30340;&#35805;&#37027;&#20040;&#23601;&#30452;&#25509;-size&#24182;&#19988;&#24377;&#20986;&#19968;&#20010;&#20803;&#32032;</span>
  <span style="font-weight: bold;">return</span> list-&gt;Pop();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge99c1f3" class="outline-4">
<h4 id="orge99c1f3"><span class="section-number-4">4.8.15</span> FetchFromCentralCache</h4>
<div class="outline-text-4" id="text-4-8-15">
<p>
这个部分的逻辑是从cc里面取出一系列的slab对象出来。里面有很多策略，非常精巧
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">FetchFromCentralCache</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">cl</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">byte_size</span>) {
  <span style="font-weight: bold; text-decoration: underline;">FreeList</span>* <span style="font-weight: bold; font-style: italic;">list</span> = &amp;list_[cl];
  ASSERT(list-&gt;empty());
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">batch_size</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;num_objects_to_move(cl);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#30475;&#30475;&#27599;&#27425;&#20801;&#35768;&#30340;&#20998;&#37197;&#30340;&#20010;&#25968;&#26159;&#22810;&#23569;</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">num_to_move</span> = min&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;(list-&gt;max_length(), batch_size);
  <span style="font-weight: bold; text-decoration: underline;">void</span> *<span style="font-weight: bold; font-style: italic;">start</span>, *<span style="font-weight: bold; font-style: italic;">end</span>;
  <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">fetch_count</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::central_cache()[cl].RemoveRange(
      &amp;start, &amp;end, num_to_move);

  ASSERT((start == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) == (fetch_count == 0));
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21462;&#20986;&#26469;&#24182;&#19988;&#35774;&#32622;&#19968;&#19979;&#24403;&#21069;&#32500;&#25252;&#30340;&#31354;&#38386;&#22823;&#23567;&#26159;&#22810;&#23569;</span>
  <span style="font-weight: bold;">if</span> (--fetch_count &gt;= 0) {
    size_ += byte_size * fetch_count;
    list-&gt;PushRange(fetch_count, SLL_Next(start), end);
  }
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#38656;&#35201;&#22686;&#38271;max_length.&#22914;&#26524;&lt;batch_size&#30340;&#35805;&#37027;&#20040;+1</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&gt;=batch_size&#30340;&#35805;&#65292;&#37027;&#20040;&#20250;&#35774;&#32622;&#25104;&#20026;&#26576;&#20010;&#19978;&#32447;</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">static const int kMaxDynamicFreeListLength = 8192;</span>
  <span style="font-weight: bold;">if</span> (list-&gt;max_length() &lt; batch_size) {
    list-&gt;set_max_length(list-&gt;max_length() + 1);
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">new_length</span> = min&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;(list-&gt;max_length() + batch_size,
                              kMaxDynamicFreeListLength);
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#20063;&#38750;&#24120;&#22909;&#29702;&#35299;&#65292;&#25353;&#29031;batch_size&#26469;&#20998;&#37197;&#30340;&#35805;&#65292;&#21487;&#20197;&#30452;&#25509;&#20174;tc&#37324;&#38754;&#24471;&#21040;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#20351;&#29992;&#36825;&#20010;&#20316;&#20026;max_kength&#30340;&#35805;&#36890;&#24120;&#24847;&#21619;&#30528;&#20998;&#37197;&#36895;&#24230;&#20250;&#26356;&#24555;.</span>
    new_length -= new_length % batch_size;
    ASSERT(new_length % batch_size == 0);
    list-&gt;set_max_length(new_length);
  }
  <span style="font-weight: bold;">return</span> start;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2156eb7" class="outline-4">
<h4 id="org2156eb7"><span class="section-number-4">4.8.16</span> Deallocate</h4>
<div class="outline-text-4" id="text-4-8-16">
<p>
释放内存部分非常简单，但是同样里面有很多策略。并且里面涉及到了tc的GC问题
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">Deallocate</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">cl</span>) {
  <span style="font-weight: bold; text-decoration: underline;">FreeList</span>* <span style="font-weight: bold; font-style: italic;">list</span> = &amp;list_[cl];
  size_ += <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;ByteSizeForClass(cl); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37322;&#25918;&#20102;&#36825;&#20010;&#20869;&#23384;&#25152;&#20197;&#31354;&#38386;&#22823;&#23567;&#22686;&#22823;</span>
  <span style="font-weight: bold; text-decoration: underline;">ssize_t</span> <span style="font-weight: bold; font-style: italic;">size_headroom</span> = max_size_ - size_ - 1;  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;size&#19978;&#38754;&#30340;&#35805;&#36824;&#26377;&#22810;&#23569;&#31354;&#38386;.</span>

  list-&gt;Push(ptr); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24402;&#36824;</span>
  <span style="font-weight: bold; text-decoration: underline;">ssize_t</span> <span style="font-weight: bold; font-style: italic;">list_headroom</span> =
      <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">ssize_t</span>&gt;(list-&gt;max_length()) - list-&gt;length(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22312;&#38271;&#24230;&#19978;&#36824;&#26377;&#22810;&#23569;&#31354;&#38386;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">There are two relatively uncommon things that require further work.</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">In the common case we're done, and in that case we need a single branch</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">because of the bitwise-or trick that follows.</span>
  <span style="font-weight: bold;">if</span> ((list_headroom | size_headroom) &lt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#37096;&#20998;&#24212;&#35813;&#26159;&#26377;&#20219;&#24847;&#19968;&#20010;&lt;0&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#24212;&#35813;&#36827;&#20837;&#12290;&#20248;&#21270;&#25163;&#27573;&#21543;.</span>
    <span style="font-weight: bold;">if</span> (list_headroom &lt; 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#24403;&#21069;&#38271;&#24230;&gt;max_length&#30340;&#35805;&#65292;&#37027;&#20040;&#38656;&#35201;&#37325;&#26032;&#35774;&#32622;max_length.</span>
      ListTooLong(list, cl);
    }
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26465;&#20214;&#30456;&#24403; if(size_headroom &lt; 0)</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22240;&#20026;ListTooLog&#20250;&#23581;&#35797;&#20462;&#25913;size_&#25152;&#20197;&#36825;&#37324;&#37325;&#26032;&#21028;&#26029;..:(tricky:(.</span>
    <span style="font-weight: bold;">if</span> (size_ &gt;= max_size_) Scavenge(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#24403;&#21069;size&gt;max_size&#30340;&#35805;&#65292;&#37027;&#20040;&#38656;&#35201;&#36827;&#34892;GC.</span>
  }
}
</pre>
</div>
<p>
然后我们这里看看这两个触发动作时如何执行的。
</p>
</div>
</div>

<div id="outline-container-org03121c3" class="outline-4">
<h4 id="org03121c3"><span class="section-number-4">4.8.17</span> ListTooLong</h4>
<div class="outline-text-4" id="text-4-8-17">
<p>
到这个地方必须思考一个问题，就是什么时候max<sub>length会发生变化以及如何变化的</sub>(触发这些变化的意义是什么).
我们可以看到Allocate里面如果从cc里面取在不断地增加max<sub>length</sub>(存在上限).问题是我们不能够让这个部分缓存太多的内容，
所以我们必须在一段时间内缩小max<sub>length</sub>，一旦length&gt;max<sub>length的话就会触发ListTooLong</sub>.
而ListTooLong里面的操作就是将max<sub>length尝试缩小并且将一部分object归还给cc</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">ListTooLong</span>(<span style="font-weight: bold; text-decoration: underline;">FreeList</span>* <span style="font-weight: bold; font-style: italic;">list</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">cl</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">batch_size</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;num_objects_to_move(cl);
  ReleaseToCentralCache(list, cl, batch_size); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#23581;&#35797;&#23558;batch_size&#30340;&#20869;&#23481;&#24402;&#36824;&#21040;tc&#37324;&#38754;&#21462;</span>

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If the list is too long, we need to transfer some number of</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">objects to the central cache.  Ideally, we would transfer</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">num_objects_to_move, so the code below tries to make max_length</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">converge on num_objects_to_move.</span>

  <span style="font-weight: bold;">if</span> (list-&gt;max_length() &lt; batch_size) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Slow start the max_length so we don't overreserve.</span>
    list-&gt;set_max_length(list-&gt;max_length() + 1);
  } <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (list-&gt;max_length() &gt; batch_size) {
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If we consistently go over max_length, shrink max_length.  If we don't</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">shrink it, some amount of memory will always stay in this freelist.</span>
    list-&gt;set_length_overages(list-&gt;length_overages() + 1); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35760;&#24405;&#19979;overage&#30340;&#27425;&#25968;</span>
    <span style="font-weight: bold;">if</span> (list-&gt;length_overages() &gt; kMaxOverages) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&gt; kMaxOverages&#30340;&#35805;&#37027;&#20040;&#38656;&#35201;&#23545;max_length&#36827;&#34892;&#32553;&#20943;.</span>
      ASSERT(list-&gt;max_length() &gt; batch_size);
      list-&gt;set_max_length(list-&gt;max_length() - batch_size); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#32553;&#20943;batch_size.</span>
      list-&gt;set_length_overages(0);
    }
  }
}
</pre>
</div>
<p>
ListTooLong是第一个确保在tc里面不会持有太多内存的机制.虽然对这里的整个过程算是比较了解，但是没有从大体上想清楚这个是如何设计的:(
</p>
</div>
</div>

<div id="outline-container-orgff0422c" class="outline-4">
<h4 id="orgff0422c"><span class="section-number-4">4.8.18</span> Scavenge</h4>
<div class="outline-text-4" id="text-4-8-18">
<p>
同样Scavenge是第二个确保在tc里不会持有太多内存的机制。同样虽然对这个过程比较了解但是也没有从大体生了解这个策略是如何设计出来的。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Release idle memory to the central cache</span>
<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::<span style="font-weight: bold;">Scavenge</span>() {
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">If the low-water mark for the free list is L, it means we would</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">not have had to allocate anything from the central cache even if</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">we had reduced the free list size by L.  We aim to get closer to</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">that situation by dropping L/2 nodes from the free list.  This</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">may not release much memory, but if so we will call scavenge again</span>
  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pretty soon and the low-water marks will be high on that call.</span>
  <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">int64 start = CycleClock::Now();</span>
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">cl</span> = 0; cl &lt; kNumClasses; cl++) {
    <span style="font-weight: bold; text-decoration: underline;">FreeList</span>* <span style="font-weight: bold; font-style: italic;">list</span> = &amp;list_[cl];
    <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">lowmark</span> = list-&gt;lowwatermark(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19978;&#19968;&#27425;&#26368;&#30701;&#30340;free list length&#26159;&#22810;&#23569;.&#22914;&#26524;free list length&#36234;&#38271;</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#24847;&#21619;&#30528;&#22312;&#22823;&#22810;&#25968;&#26102;&#20505;&#26377;&#24456;&#22810;&#31354;&#38386;&#20869;&#23384;&#26159;&#27809;&#26377;&#20351;&#29992;&#65292;&#25152;&#20197;&#21487;&#20197;&#23558;&#20854;&#24402;&#36824;.</span>
    <span style="font-weight: bold;">if</span> (lowmark &gt; 0) {
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">drop</span> = (lowmark &gt; 1) ? lowmark/2 : 1; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23558;&#26368;&#26368;&#30701;&#30340;&#37096;&#20998;&#30340;1/2&#24402;&#36824;&#32473;cc.</span>
      ReleaseToCentralCache(list, cl, drop);

      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Shrink the max length if it isn't used.  Only shrink down to</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">batch_size -- if the thread was active enough to get the max_length</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">above batch_size, it will likely be that active again.  If</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">max_length shinks below batch_size, the thread will have to</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">go through the slow-start behavior again.  The slow-start is useful</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">mainly for threads that stay relatively idle for their entire</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">lifetime.</span>
      <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">batch_size</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;num_objects_to_move(cl);
      <span style="font-weight: bold;">if</span> (list-&gt;max_length() &gt; batch_size) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35843;&#25972;max_length.</span>
        list-&gt;set_max_length(
            max&lt;<span style="font-weight: bold; text-decoration: underline;">int</span>&gt;(list-&gt;max_length() - batch_size, batch_size));
      }
    }
    list-&gt;clear_lowwatermark();
  }

  IncreaseCacheLimit(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#35302;&#21457;&#36825;&#20010;Scavenge&#26412;&#36523;&#30340;&#21407;&#22240;&#23601;&#26159;&#22240;&#20026;size_&gt;max_size_&#25152;&#20197;&#26377;&#24517;&#35201;&#25552;&#39640;max_size_.</span>
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf7bf644" class="outline-2">
<h2 id="orgf7bf644"><span class="section-number-2">5</span> 用户对象</h2>
<div class="outline-text-2" id="text-5">
<p>
tcmalloc.h
</p>
</div>

<div id="outline-container-org1d6c654" class="outline-3">
<h3 id="org1d6c654"><span class="section-number-3">5.1</span> 函数入口</h3>
<div class="outline-text-3" id="text-5-1">
<p>
我们还是以最初的函数入门进行分析，我们只是关注tc<sub>malloc与tc</sub><sub>free</sub>.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">extern</span> <span style="font-style: italic;">"C"</span> PERFTOOLS_DLL_DECL <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">tc_malloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>) __THROW {
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">result</span> = do_malloc_or_cpp_alloc(size);
  <span style="font-weight: bold; text-decoration: underline;">MallocHook</span>::InvokeNewHook(result, size);
  <span style="font-weight: bold;">return</span> result;
}

<span style="font-weight: bold;">extern</span> <span style="font-style: italic;">"C"</span> PERFTOOLS_DLL_DECL <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">tc_free</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>) __THROW {
  <span style="font-weight: bold; text-decoration: underline;">MallocHook</span>::InvokeDeleteHook(ptr);
  do_free(ptr);
}
</pre>
</div>
<p>
可以看到两个函数调用之前都有hook存在。hook是在malloc<sub>hook</sub><sub>inl.h以及malloc</sub><sub>hook.cc里面定义的</sub>，通过一个HookList来进行管理。
调用Invoke时候就是遍历里面的内容，这个后续可以仔细分析。do<sub>malloc</sub><sub>or</sub><sub>cpp</sub><sub>alloc里面可以看到</sub>，因为tc<sub>new</sub><sub>mode</sub>==0所以实际调用的就是do<sub>malloc这个函数</sub>。
我们首先关注malloc的过程，对于malloc过程了解清楚之后，那么free过程就非常直接了。
</p>
</div>
</div>

<div id="outline-container-org23eb231" class="outline-3">
<h3 id="org23eb231"><span class="section-number-3">5.2</span> 分配逻辑</h3>
<div class="outline-text-3" id="text-5-2">
<p>
我们先看看do<sub>malloc这个过程</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">do_malloc</span>(<span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>) {
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ret</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The following call forces module initialization</span>
  <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; font-style: italic;">heap</span> = <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>::GetCache(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#24471;&#21040;thread_cache</span>
  <span style="font-weight: bold;">if</span> (size &lt;= kMaxSize) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">kMaxSize = 256K</span>
    <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">cl</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;SizeClass(size);
    size = <span style="font-weight: bold; text-decoration: underline;">Static</span>::sizemap()-&gt;class_to_size(cl);
     <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#23581;&#35797;&#36827;&#34892;&#37319;&#26679;&#20998;&#37197;.</span>
         <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#37324;&#25105;&#20204;&#26242;&#26102;&#24573;&#30053;&#37319;&#26679;&#37096;&#20998;&#30340;&#36923;&#36753;</span>
    <span style="font-weight: bold;">if</span> ((FLAGS_tcmalloc_sample_parameter &gt; 0) &amp;&amp; heap-&gt;SampleAllocation(size)) {
      ret = DoSampledAllocation(size);
    } <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The common case, and also the simplest.  This just pops the</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">size-appropriate freelist, after replenishing it if it's empty.</span>
      ret = CheckedMallocResult(heap-&gt;Allocate(size, cl)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#37096;&#20998;&#30340;&#23601;&#26159;&#30452;&#25509;&#22312;tc&#19978;&#38754;&#35843;&#29992;Allocate&#36827;&#34892;&#20998;&#37197;</span>
    }
  } <span style="font-weight: bold;">else</span> {
    ret = do_malloc_pages(heap, size); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#20998;&#37197;&#23545;&#35937;&#36807;&#22823;&#30340;&#35805;</span>
  }
  <span style="font-weight: bold;">if</span> (ret == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) errno = ENOMEM;
  <span style="font-weight: bold;">return</span> ret;
}
</pre>
</div>

<p>
对于小对象分配逻辑已经清楚了，接着看看大对象分配调用do<sub>malloc</sub><sub>pages这个部分</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold;">do_malloc_pages</span>(<span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; font-style: italic;">heap</span>, <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">size</span>) {
  <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">result</span>;
  <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold; font-style: italic;">report_large</span>;

  <span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">num_pages</span> = <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::pages(size); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36716;&#25442;&#38656;&#35201;&#20998;&#37197;&#22810;&#23569;&#20010;pages.</span>
  size = num_pages &lt;&lt; kPageShift;

  <span style="font-weight: bold;">if</span> ((FLAGS_tcmalloc_sample_parameter &gt; 0) &amp;&amp; heap-&gt;SampleAllocation(size)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21516;&#26679;&#25105;&#20204;&#26242;&#26102;&#24573;&#30053;&#37319;&#26679;&#37096;&#20998;</span>
    result = DoSampledAllocation(size);

    <span style="font-weight: bold; text-decoration: underline;">SpinLockHolder</span> <span style="font-weight: bold; font-style: italic;">h</span>(<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap_lock());
    report_large = should_report_large(num_pages);
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; text-decoration: underline;">SpinLockHolder</span> <span style="font-weight: bold; font-style: italic;">h</span>(<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap_lock());
    <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;New(num_pages);
    result = (span == <span style="font-weight: bold; text-decoration: underline;">NULL</span> ? <span style="font-weight: bold; text-decoration: underline;">NULL</span> : SpanToMallocResult(span)); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;&#37096;&#20998;&#23601;&#26159;&#26816;&#26597;&#19968;&#19979;span&#26159;&#21542;OK,&#24050;&#32463;&#23558;span&#30340;slab(0)cache&#20303;.</span>
    report_large = should_report_large(num_pages);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#21028;&#26029;&#36825;&#20010;pages&#26159;&#21542;&#24320;&#36767;&#36807;&#22823;</span>
  }

  <span style="font-weight: bold;">if</span> (report_large) {
    ReportLargeAlloc(num_pages, result); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#24320;&#36767;&#36807;&#22823;&#30340;&#35805;&#37027;&#20040;&#21487;&#20197;&#36873;&#25321;&#36827;&#34892;report.</span>
  }
  <span style="font-weight: bold;">return</span> result;
}
</pre>
</div>

<p>
然后稍微看看should<sub>report</sub><sub>large是如何判断的以及如何report</sub>
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36890;&#36807;&#33719;&#21462;&#29615;&#22659;&#21464;&#37327;&#21363;&#21487;&#24471;&#21040;</span>
<span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int64</span> <span style="font-weight: bold; font-style: italic;">kDefaultLargeAllocReportThreshold</span> = <span style="font-weight: bold;">static_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">int64</span>&gt;(1) &lt;&lt; 30; <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#40664;&#35748;&#26159;1GB</span>
DEFINE_int64(tcmalloc_large_alloc_report_threshold,
             EnvToInt64(<span style="font-style: italic;">"TCMALLOC_LARGE_ALLOC_REPORT_THRESHOLD"</span>,
                        kDefaultLargeAllocReportThreshold),
             <span style="font-style: italic;">"Allocations larger than this value cause a stack "</span>
             <span style="font-style: italic;">"trace to be dumped to stderr.  The threshold for "</span>
             <span style="font-style: italic;">"dumping stack traces is increased by a factor of 1.125 "</span>
             <span style="font-style: italic;">"every time we print a message so that the threshold "</span>
             <span style="font-style: italic;">"automatically goes up by a factor of ~1000 every 60 "</span>
             <span style="font-style: italic;">"messages.  This bounds the amount of extra logging "</span>
             <span style="font-style: italic;">"generated by this flag.  Default value of this flag "</span>
             <span style="font-style: italic;">"is very large and therefore you should see no extra "</span>
             <span style="font-style: italic;">"logging unless the flag is overridden.  Set to 0 to "</span>
             <span style="font-style: italic;">"disable reporting entirely."</span>);

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#36825;&#20010;large_alloc_threshold&#32943;&#23450;&#35201;&#27604;kPageSize&#35201;&#25171;</span>
<span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">int64_t</span> <span style="font-weight: bold; font-style: italic;">large_alloc_threshold</span> =
  (kPageSize &gt; FLAGS_tcmalloc_large_alloc_report_threshold
   ? kPageSize : FLAGS_tcmalloc_large_alloc_report_threshold);

<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">bool</span> <span style="font-weight: bold;">should_report_large</span>(<span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">num_pages</span>) {
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int64</span> <span style="font-weight: bold; font-style: italic;">threshold</span> = large_alloc_threshold;
  <span style="font-weight: bold;">if</span> (threshold &gt; 0 &amp;&amp; num_pages &gt;= (threshold &gt;&gt; kPageShift)) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#36229;&#36807;large_alloc_threshold&#30340;&#35805;</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Increase the threshold by 1/8 every time we generate a report.</span>
    <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">We cap the threshold at 8GiB to avoid overflow problems.</span>
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#36825;&#27425;&#30340;threshold&#21487;&#33021;&#38656;&#35201;&#36827;&#34892;&#35843;&#25972;</span>
    large_alloc_threshold = (threshold + threshold/8 &lt; 8ll&lt;&lt;30 <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">8GB</span>
                             ? threshold + threshold/8 : 8ll&lt;&lt;30);
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">true</span>;
  }
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">false</span>;
}
</pre>
</div>
<p>
然后看看如果进行report的.代码上看基本上就是打印出这个函数调用堆栈到stderr上面，使用的buffer空间1000B.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">static</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">ReportLargeAlloc</span>(<span style="font-weight: bold; text-decoration: underline;">Length</span> <span style="font-weight: bold; font-style: italic;">num_pages</span>, <span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">result</span>) {
  <span style="font-weight: bold; text-decoration: underline;">StackTrace</span> <span style="font-weight: bold; font-style: italic;">stack</span>;
  stack.depth = GetStackTrace(stack.stack, <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::kMaxStackDepth, 1);

  <span style="font-weight: bold;">static</span> <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">N</span> = 1000;
  <span style="font-weight: bold; text-decoration: underline;">char</span> <span style="font-weight: bold; font-style: italic;">buffer</span>[N];
  <span style="font-weight: bold; text-decoration: underline;">TCMalloc_Printer</span> <span style="font-weight: bold; font-style: italic;">printer</span>(buffer, N);
  printer.printf(<span style="font-style: italic;">"tcmalloc: large alloc %"</span>PRIu64<span style="font-style: italic;">" bytes == %p @ "</span>,
                 <span style="font-weight: bold;">static_cast</span>&lt;uint64&gt;(num_pages) &lt;&lt; kPageShift,
                 result);
  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold; text-decoration: underline;">int</span> <span style="font-weight: bold; font-style: italic;">i</span> = 0; i &lt; stack.depth; i++) {
    printer.printf(<span style="font-style: italic;">" %p"</span>, stack.stack[i]);
  }
  printer.printf(<span style="font-style: italic;">"\n"</span>);
  write(STDERR_FILENO, buffer, strlen(buffer));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfa7bb8f" class="outline-3">
<h3 id="orgfa7bb8f"><span class="section-number-3">5.3</span> 释放逻辑</h3>
<div class="outline-text-3" id="text-5-3">
<p>
相对分配来说，释放逻辑要稍微简单一些.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">do_free_with_callback</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>, <span style="font-weight: bold; text-decoration: underline;">void</span> (*<span style="font-weight: bold;">invalid_free_fn</span>)(<span style="font-weight: bold; text-decoration: underline;">void</span>*)) {
  <span style="font-weight: bold;">if</span> (ptr == <span style="font-weight: bold; text-decoration: underline;">NULL</span>) <span style="font-weight: bold;">return</span>;
  ASSERT(<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap() != <span style="font-weight: bold; text-decoration: underline;">NULL</span>);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Should not call free() before malloc()</span>
  <span style="font-weight: bold;">const</span> <span style="font-weight: bold; text-decoration: underline;">PageID</span> <span style="font-weight: bold; font-style: italic;">p</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uintptr_t</span>&gt;(ptr) &gt;&gt; kPageShift;
  <span style="font-weight: bold; text-decoration: underline;">Span</span>* <span style="font-weight: bold; font-style: italic;">span</span> = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
  <span style="font-weight: bold; text-decoration: underline;">size_t</span> <span style="font-weight: bold; font-style: italic;">cl</span> = <span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;GetSizeClassIfCached(p); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#39318;&#20808;&#26597;&#30475;cache&#37324;&#38754;&#26159;&#21542;&#26377;class&#30340;&#20449;&#24687;</span>

  <span style="font-weight: bold;">if</span> (cl == 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#27809;&#26377;class&#30340;&#20449;&#24687;&#30340;&#35805;&#65292;&#37027;&#20040;&#38656;&#35201;&#21435;pagemap&#37324;&#38754;&#26597;&#35810;&#21040;span.</span>
    span = <span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;GetDescriptor(p);
    <span style="font-weight: bold;">if</span> (!span) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26597;&#35810;&#19981;&#21040;span&#30340;&#35805;&#37027;&#20040;&#35748;&#20026;&#36825;&#20010;&#25351;&#38024;&#24335;&#38169;&#35823;&#30340;</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">span can be NULL because the pointer passed in is invalid</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">(not something returned by malloc or friends), or because the</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">pointer was allocated with some other allocator besides</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">tcmalloc.  The latter can happen if tcmalloc is linked in via</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">a dynamic library, but is not listed last on the link line.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">In that case, libraries after it on the link line will</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">allocate with libc malloc, but free with tcmalloc's free.</span>
      (*invalid_free_fn)(ptr);  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Decide how to handle the bad free request</span>
      <span style="font-weight: bold;">return</span>;
    }
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#21462;&#20986;slab class&#24182;&#19988;cache&#20303;.</span>
    cl = span-&gt;sizeclass;
    <span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;CacheSizeClass(p, cl);
  }
  <span style="font-weight: bold;">if</span> (cl != 0) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;&#23567;&#23545;&#35937;&#37322;&#25918;&#30340;&#35805;</span>
    ASSERT(!<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;GetDescriptor(p)-&gt;sample);
    <span style="font-weight: bold; text-decoration: underline;">ThreadCache</span>* <span style="font-weight: bold; font-style: italic;">heap</span> = GetCacheIfPresent(); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#37027;&#20040;&#33719;&#24471;&#21040;&#24403;&#21069;&#32447;&#31243;&#30340;tc</span>
    <span style="font-weight: bold;">if</span> (heap != <span style="font-weight: bold; text-decoration: underline;">NULL</span>) {
      heap-&gt;Deallocate(ptr, cl); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#28982;&#21518;&#22238;&#25910;&#21040;&#36825;&#20010;tc&#37324;&#38754;</span>
    } <span style="font-weight: bold;">else</span> { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#19981;&#30693;&#36947;&#36825;&#20010;&#24773;&#20917;&#20160;&#20040;&#26102;&#20505;&#20986;&#29616;&#65292;&#22914;&#26524;&#20986;&#29616;&#30340;&#35805;&#65292;&#37027;&#20040;&#23601;&#25918;&#21040;cc&#37324;&#38754;,&#38750;&#24120;&#30452;&#25509;.</span>
      <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Delete directly into central cache</span>
      <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::SLL_SetNext(ptr, <span style="font-weight: bold; text-decoration: underline;">NULL</span>);
      <span style="font-weight: bold; text-decoration: underline;">Static</span>::central_cache()[cl].InsertRange(ptr, ptr, 1);
    }
  } <span style="font-weight: bold;">else</span> {
    <span style="font-weight: bold; text-decoration: underline;">SpinLockHolder</span> <span style="font-weight: bold; font-style: italic;">h</span>(<span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap_lock());
    ASSERT(<span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">uintptr_t</span>&gt;(ptr) % kPageSize == 0);
    ASSERT(span != <span style="font-weight: bold; text-decoration: underline;">NULL</span> &amp;&amp; span-&gt;start == p);
    <span style="font-weight: bold;">if</span> (span-&gt;sample) { <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#26242;&#26102;&#19981;&#29702;&#20250;&#36825;&#20010;sample&#36923;&#36753;</span>
      <span style="font-weight: bold; text-decoration: underline;">StackTrace</span>* <span style="font-weight: bold; font-style: italic;">st</span> = <span style="font-weight: bold;">reinterpret_cast</span>&lt;<span style="font-weight: bold; text-decoration: underline;">StackTrace</span>*&gt;(span-&gt;objects);
      <span style="font-weight: bold; text-decoration: underline;">tcmalloc</span>::DLL_Remove(span);
      <span style="font-weight: bold; text-decoration: underline;">Static</span>::stacktrace_allocator()-&gt;Delete(st);
      span-&gt;objects = <span style="font-weight: bold; text-decoration: underline;">NULL</span>;
    }
        <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#22914;&#26524;&#26159;&#22823;&#23545;&#35937;&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;&#30001;pageheap&#37322;&#25918;.</span>
    <span style="font-weight: bold; text-decoration: underline;">Static</span>::pageheap()-&gt;Delete(span);
  }
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">The default "do_free" that uses the default callback.</span>
<span style="font-weight: bold;">inline</span> <span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold;">do_free</span>(<span style="font-weight: bold; text-decoration: underline;">void</span>* <span style="font-weight: bold; font-style: italic;">ptr</span>) {
  <span style="font-weight: bold;">return</span> do_free_with_callback(ptr, &amp;InvalidFree); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">&#40664;&#35748;&#24773;&#20917;&#23601;&#26159;&#25171;&#21360;&#19968;&#20010;log&#24182;&#19988;&#30452;&#25509;crash&#25481;.</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge35f3db" class="outline-2">
<h2 id="orge35f3db"><span class="section-number-2">6</span> 扩展组件</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org8be9c0d" class="outline-3">
<h3 id="org8be9c0d"><span class="section-number-3">6.1</span> Sampler</h3>
<div class="outline-text-3" id="text-6-1">
<p>
#todo:
</p>
</div>
</div>

<div id="outline-container-org6e556ef" class="outline-3">
<h3 id="org6e556ef"><span class="section-number-3">6.2</span> MallocExtension</h3>
<div class="outline-text-3" id="text-6-2">
<p>
#todo:
</p>
</div>
</div>

<div id="outline-container-orgf102b40" class="outline-3">
<h3 id="orgf102b40"><span class="section-number-3">6.3</span> MallocHook</h3>
<div class="outline-text-3" id="text-6-3">
<p>
#todo:
</p>
</div>
</div>

<div id="outline-container-orgb4e8cda" class="outline-3">
<h3 id="orgb4e8cda"><span class="section-number-3">6.4</span> HeapChecker</h3>
<div class="outline-text-3" id="text-6-4">
<p>
#todo:
</p>
</div>
</div>

<div id="outline-container-orga91a73a" class="outline-3">
<h3 id="orga91a73a"><span class="section-number-3">6.5</span> HeapProfiler</h3>
<div class="outline-text-3" id="text-6-5">
<p>
#todo:
</p>
</div>
</div>

<div id="outline-container-orgd136e23" class="outline-3">
<h3 id="orgd136e23"><span class="section-number-3">6.6</span> CPUProfiler</h3>
<div class="outline-text-3" id="text-6-6">
<p>
#todo:
</p>
</div>
</div>
</div>

<div id="outline-container-orge5efaba" class="outline-2">
<h2 id="orge5efaba"><span class="section-number-2">7</span> Discussion</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org8b951da" class="outline-3">
<h3 id="org8b951da"><span class="section-number-3">7.1</span> tcmalloc中的 MmapSysAllocator::Alloc 疑问(nwlzee)</h3>
<div class="outline-text-3" id="text-7-1">
<p>
<b>Question</b>
</p>

<pre class="example">
您好，我看到这函数有点不了解。
在MmapSysAllocator::Alloc 中：

// 。。。
  if ((ptr &amp; (alignment - 1)) != 0) {
    adjust = alignment - (ptr &amp; (alignment - 1));
  }

  // Return the unused memory to the system
  if (adjust &gt; 0) {
    munmap(reinterpret_cast&lt;void*&gt;(ptr), adjust);
  }
  if (adjust &lt; extra) {
    munmap(reinterpret_cast&lt;void*&gt;(ptr + adjust + size), extra - adjust);
  }

  ptr += adjust;
  return reinterpret_cast&lt;void*&gt;(ptr);

我从man 手册知道munmap 是以page 单位大小释放的内存的，
当 munmap(reinterpret_cast&lt;void*&gt;(ptr), adjust); 释放adjust所
包含的页了，则返回 ptr += adjust (可能指向刚才释放的页中某一地址)，这地址ptr不是无效了？
</pre>

<hr />

<p>
<b>Answer</b>
</p>

<p>
看看MmapSysAllocator::Alloc这个函数吧，假设这里的alignment==page<sub>size的情况的话</sub>，
</p>
<ol class="org-ol">
<li>extra = alignment - pagesize; 所以extra==0</li>
<li>ptr肯定和page<sub>size对齐</sub>，因此adjust==0</li>
</ol>
<p>
所以你可以看到其实两个分支都没有走到的。
</p>

<p>
其实在实际使用的时候alignment通常也是page<sub>size的倍数</sub>。如果alignment==k*page<sub>size的话</sub>，你会发现
</p>
<ol class="org-ol">
<li>extra也是page<sub>size倍数</sub></li>
<li>adjust也是page<sub>size倍数</sub></li>
</ol>
<p>
因此在munmap的时候不会存在跨越page<sub>size边界这样的问题的</sub>。
</p>

<p>
最后你看看tcmalloc是怎么使用MmapSysAllocator对象的。相信你也看得非常仔细，tcmalloc是 DefaultSysAllocator创建两个对象
</p>
<ol class="org-ol">
<li>SbrkSysAllocator</li>
<li>MmapSysAllocator</li>
</ol>
<p>
你看看DefaultSysAllocator调用情况，
</p>
<pre class="example">
[dirlt@umeng-ubuntu-pc] &gt; grep "TCMalloc_SystemAlloc" *
common.cc:  void* result = TCMalloc_SystemAlloc(bytes, NULL);
page_heap.cc:#include "system-alloc.h"      // for TCMalloc_SystemAlloc, etc
page_heap.cc:  void* ptr = TCMalloc_SystemAlloc(ask &lt;&lt; kPageShift, &amp;actual_size, kPageSize);
page_heap.cc:      ptr = TCMalloc_SystemAlloc(ask &lt;&lt; kPageShift, &amp;actual_size, kPageSize);
system-alloc.cc:  // This doesn't overflow because TCMalloc_SystemAlloc has already
system-alloc.cc:    // NOTE: not a devmem_failure - we'd like TCMalloc_SystemAlloc to
system-alloc.cc:void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size,
system-alloc.h:extern void* TCMalloc_SystemAlloc(size_t bytes, size_t *actual_bytes,
</pre>

<p>
你会看到实际上调用TCMalloc<sub>SystemAlloc时候</sub>，alignment都是==kPageSize的。因此实际tcmalloc 使用时候不会出现这个问题。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: work</p>
<p class="date">Created: 2019-04-03 Wed 04:57</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://maypeppa.github.io/html/tcmalloc.html';this.page.identifier = 'tcmalloc.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://cdnjs.cloudflare.com/ajax/libs/embed-js/4.2.1/embed.min.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
